{"version":3,"sources":["webpack:///../../dist/ReScope.browser.min.js","webpack:///webpack/bootstrap 0f0ee85f5c769cc22e98","webpack:///./src/index.js","webpack:///./~/is/index.js","webpack:///./~/shortid/lib/alphabet.js","webpack:///./src/Scope.js","webpack:///./src/utils/Emitter.js","webpack:///./src/utils/utils.js","webpack:///./~/shortid/index.js","webpack:///./~/shortid/lib/encode.js","webpack:///./src/Store.js","webpack:///./src/utils/TaskSequencer.js","webpack:///./~/process/browser.js","webpack:///./~/shortid/lib/build.js","webpack:///./~/shortid/lib/decode.js","webpack:///./~/shortid/lib/index.js","webpack:///./~/shortid/lib/is-valid.js","webpack:///./~/shortid/lib/random/random-byte-browser.js","webpack:///./~/shortid/lib/random/random-from-seed.js","webpack:///./~/shortid/lib/util/cluster-worker-id-browser.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","global","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_Scope","_Scope2","_Store","_Store2","$global","window","RS","___rescope","Scope","Store","scopeRef","map","key","this","symbolValueOf","objProto","prototype","owns","hasOwnProperty","toStr","toString","Symbol","valueOf","isActualNaN","NON_HOST_TYPES","boolean","number","string","undefined","base64Regex","hexRegex","is","a","type","defined","empty","length","equal","other","getTime","hosted","host","instance","instanceof","constructor","nil","null","undef","args","arguments","isStandardArguments","isOldArguments","array","arraylike","object","fn","callee","Array","isArray","bool","isFinite","false","Boolean","Number","true","date","valid","isNaN","element","HTMLElement","nodeType","error","function","isAlert","alert","str","infinite","Infinity","decimal","divisibleBy","n","isDividendInfinite","isDivisorInfinite","isNonZeroNumber","integer","int","maximum","others","TypeError","len","minimum","nan","even","odd","ge","gt","le","lt","within","start","finish","isAnyInfinite","primitive","hash","setInterval","regexp","base64","test","hex","symbol","reset","shuffled","setCharacters","_alphabet_","alphabet","ORIGINAL","Error","unique","split","filter","item","ind","arr","lastIndexOf","join","characters","setSeed","seed","randomFromSeed","previousSeed","shuffle","characterIndex","sourceArray","targetArray","r","nextValue","Math","floor","push","splice","getShuffled","lookup","index","alphabetShuffled","_toConsumableArray","i","arr2","from","_defineProperty","enumerable","configurable","writable","_classCallCheck","Constructor","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","_extends","assign","target","source","_createClass","defineProperties","props","descriptor","protoProps","staticProps","_is","_is2","_shortid","_shortid2","_Emitter","_Emitter2","_utils","__proto__push","parent","_","allScopes","_EventEmitter","storesMap","_ref2","upperScope","snapshot","state","data","_ref2$incrementId","incrementId","persistenceTm","autoDestroy","rootEmitter","boundedActions","_this","getPrototypeOf","keyPID","_id","shortid","generate","baseId","isLocalId","_ret","register","_rev","actions","stores","_autoDestroy","dead","sources","childScopes","childScopesList","unStableChilds","seenChilds","_listening","_scope","_mixed","_mixedList","followers","__retains","all","__locks","_boundedActions","includes","bind","retain","on","_parentList","update","s","_propag","_stable","wait","stable","release","unstable","_addChild","restore","setTimeout","tm","dispose","sm","_refs","path","applier","keys","forEach","cpath","Function","as","scopes","skey","sort","b","firstname","storeIdList","_this2","storeId","_mount","apply","ref","parseRef","_parent","reduceRight","mounted","ctx","store","taskQueue","isStoreClass","name","shift","isScopeClass","$parent","mount","slice","isStore","setState","_watchStore","_this3","relink","singleton","srcCtx","targetCtx","_this4","external","force","hotReloading","tmp","nextState","destroy","get","set","v","activeActions","isScope","act","__targetStores","dispatch","_this5","isStable","propag","_this6","lists","__origin","_this7","setInitial","revMap","lastRevs","refKeys","reduce","revs","rev","refs","retainStores","getUpdates","disposeStores","_this8","refList","mixedCWUnmount","unMountKey","isReactComponent","unBind","walknSet","alias","retrieve","cScope","retrieveStore","storesRevMap","local","updated","getStoresRevs","_getRevMap","output","_this9","_this10","childs","_getAllChilds","cfg","_ref3","parentAlias","sid","serialize_ex","exclude","_cfg$withChilds","withChilds","_cfg$withMixed","withMixed","norefs","keyWalknGet","keyWalknSet","serialize","withChild","withParents","h","k","_this11","snap","takeSnapshotByKey","startsWith","substr","getSnapshotByKey","deleteSnapshotByKey","replace","pState","_this12","_ref","action","_parent2","_this13","_len","argz","_key","bActs","_$_scope$id","trigger","concat","cb","_this14","once","e","then","_this15","onceStableTree","_this16","reason","_this17","emit","_this18","stabilizerTM","clearTimeout","propagTM","_this19","_this20","_ref4","scope","_this21","stableTree","unstableTree","wasStable","indexOf","un","_this22","destroyTM","_this23","removeListener","follower","_rmChild","EventEmitter","isPrototypeOf","Emitter","_events","evt","stack","walknGet","isKey","encode","done","loopCounter","randomByte","pow","_get","property","receiver","desc","getOwnPropertyDescriptor","getter","_require","TaskSequencer","_this$_require","_this$_require2","_static","getScope","staticScope","watchs","use","initialState","defaultState","_uid","_onStabilize","_persistenceTm","_cfg","scopeObj","$scope","$stores","$actions","$dispatch","_revs","_sources","_use","match","ref2","require","_followers","_changesSW","_afterConstructor","initialData","applied","shouldApply","managed","nDatas","cDatas","isComplete","follow","changes","_stabilizer","pushTask","_scopeObj","_key2","_actions$action","_len2","_key3","ns","hasDataChange","_nextState","nextData","sync","change","pushState","stabilize","sId","refsCount","persistent","shouldSerialize","dataRefs","stateKeys","stateRefs","inRefsCount","inRefs","_restore","_x","_x2","immediate","restoreRefPath","previous","me","shouldPropag","_destroyTM","removeAllListeners","cStore","origin","targetRevs","targetScope","initialOutputs","_cStore$_sources","defaultName","o","process","runNow","isRunning","run","Date","now","errorCatcher","enable","taskCount","curWeight","task","disable","maxWeight","lastError","handleError","addEventListener","removeEventListener","weight","max","min","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","Item","noop","nextTick","title","browser","env","argv","version","versions","addListener","off","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","build","clusterWorkerId","seconds","REDUCE_TIME","previousSeconds","counter","decode","worker","seedValue","workerId","newCharacters","isValid","isShortId","crypto","getRandomValues","random","dest","Uint8Array","msCrypto","getNextValue","_seed_"],"mappings":"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","file":"../../dist/ReScope.browser.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Scope = __webpack_require__(3);\n\t\n\tvar _Scope2 = _interopRequireDefault(_Scope);\n\t\n\tvar _Store = __webpack_require__(8);\n\t\n\tvar _Store2 = _interopRequireDefault(_Store);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/*\n\t * The MIT License (MIT)\n\t * Copyright (c) 2019. Wise Wild Web\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t *\n\t *  @author : Nathanael Braun\n\t *  @contact : n8tz.js@gmail.com\n\t */\n\t\n\tvar $global = typeof window !== 'undefined' ? window : global;\n\t\n\tvar RS = $global.___rescope || {};\n\t\n\tif ($global.___rescope) {\n\t  console.warn(\"ReScope is defined multiple times !! \\nCheck you're packaging\");\n\t} else {\n\t\n\t  $global.___rescope = RS;\n\t  _Scope2.default.Store = _Store2.default;\n\t  RS.Scope = _Scope2.default;\n\t  RS.Store = _Store2.default;\n\t  RS.scopeRef = function scopeRef(map, key) {\n\t    map[key] = new _Scope2.default.scopeRef(map[key]);\n\t    return map;\n\t  };\n\t}\n\texports.default = RS;\n\tmodule.exports = exports[\"default\"];\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/* globals window, HTMLElement */\n\t\n\t'use strict';\n\t\n\t/**!\n\t * is\n\t * the definitive JavaScript type testing library\n\t *\n\t * @copyright 2013-2014 Enrico Marino / Jordan Harband\n\t * @license MIT\n\t */\n\t\n\tvar objProto = Object.prototype;\n\tvar owns = objProto.hasOwnProperty;\n\tvar toStr = objProto.toString;\n\tvar symbolValueOf;\n\tif (typeof Symbol === 'function') {\n\t  symbolValueOf = Symbol.prototype.valueOf;\n\t}\n\tvar isActualNaN = function (value) {\n\t  return value !== value;\n\t};\n\tvar NON_HOST_TYPES = {\n\t  'boolean': 1,\n\t  number: 1,\n\t  string: 1,\n\t  undefined: 1\n\t};\n\t\n\tvar base64Regex = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$/;\n\tvar hexRegex = /^[A-Fa-f0-9]+$/;\n\t\n\t/**\n\t * Expose `is`\n\t */\n\t\n\tvar is = {};\n\t\n\t/**\n\t * Test general.\n\t */\n\t\n\t/**\n\t * is.type\n\t * Test if `value` is a type of `type`.\n\t *\n\t * @param {Mixed} value value to test\n\t * @param {String} type type\n\t * @return {Boolean} true if `value` is a type of `type`, false otherwise\n\t * @api public\n\t */\n\t\n\tis.a = is.type = function (value, type) {\n\t  return typeof value === type;\n\t};\n\t\n\t/**\n\t * is.defined\n\t * Test if `value` is defined.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if 'value' is defined, false otherwise\n\t * @api public\n\t */\n\t\n\tis.defined = function (value) {\n\t  return typeof value !== 'undefined';\n\t};\n\t\n\t/**\n\t * is.empty\n\t * Test if `value` is empty.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is empty, false otherwise\n\t * @api public\n\t */\n\t\n\tis.empty = function (value) {\n\t  var type = toStr.call(value);\n\t  var key;\n\t\n\t  if (type === '[object Array]' || type === '[object Arguments]' || type === '[object String]') {\n\t    return value.length === 0;\n\t  }\n\t\n\t  if (type === '[object Object]') {\n\t    for (key in value) {\n\t      if (owns.call(value, key)) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  return !value;\n\t};\n\t\n\t/**\n\t * is.equal\n\t * Test if `value` is equal to `other`.\n\t *\n\t * @param {Mixed} value value to test\n\t * @param {Mixed} other value to compare with\n\t * @return {Boolean} true if `value` is equal to `other`, false otherwise\n\t */\n\t\n\tis.equal = function equal(value, other) {\n\t  if (value === other) {\n\t    return true;\n\t  }\n\t\n\t  var type = toStr.call(value);\n\t  var key;\n\t\n\t  if (type !== toStr.call(other)) {\n\t    return false;\n\t  }\n\t\n\t  if (type === '[object Object]') {\n\t    for (key in value) {\n\t      if (!is.equal(value[key], other[key]) || !(key in other)) {\n\t        return false;\n\t      }\n\t    }\n\t    for (key in other) {\n\t      if (!is.equal(value[key], other[key]) || !(key in value)) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  if (type === '[object Array]') {\n\t    key = value.length;\n\t    if (key !== other.length) {\n\t      return false;\n\t    }\n\t    while (key--) {\n\t      if (!is.equal(value[key], other[key])) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  if (type === '[object Function]') {\n\t    return value.prototype === other.prototype;\n\t  }\n\t\n\t  if (type === '[object Date]') {\n\t    return value.getTime() === other.getTime();\n\t  }\n\t\n\t  return false;\n\t};\n\t\n\t/**\n\t * is.hosted\n\t * Test if `value` is hosted by `host`.\n\t *\n\t * @param {Mixed} value to test\n\t * @param {Mixed} host host to test with\n\t * @return {Boolean} true if `value` is hosted by `host`, false otherwise\n\t * @api public\n\t */\n\t\n\tis.hosted = function (value, host) {\n\t  var type = typeof host[value];\n\t  return type === 'object' ? !!host[value] : !NON_HOST_TYPES[type];\n\t};\n\t\n\t/**\n\t * is.instance\n\t * Test if `value` is an instance of `constructor`.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is an instance of `constructor`\n\t * @api public\n\t */\n\t\n\tis.instance = is['instanceof'] = function (value, constructor) {\n\t  return value instanceof constructor;\n\t};\n\t\n\t/**\n\t * is.nil / is.null\n\t * Test if `value` is null.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is null, false otherwise\n\t * @api public\n\t */\n\t\n\tis.nil = is['null'] = function (value) {\n\t  return value === null;\n\t};\n\t\n\t/**\n\t * is.undef / is.undefined\n\t * Test if `value` is undefined.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is undefined, false otherwise\n\t * @api public\n\t */\n\t\n\tis.undef = is.undefined = function (value) {\n\t  return typeof value === 'undefined';\n\t};\n\t\n\t/**\n\t * Test arguments.\n\t */\n\t\n\t/**\n\t * is.args\n\t * Test if `value` is an arguments object.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is an arguments object, false otherwise\n\t * @api public\n\t */\n\t\n\tis.args = is.arguments = function (value) {\n\t  var isStandardArguments = toStr.call(value) === '[object Arguments]';\n\t  var isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);\n\t  return isStandardArguments || isOldArguments;\n\t};\n\t\n\t/**\n\t * Test array.\n\t */\n\t\n\t/**\n\t * is.array\n\t * Test if 'value' is an array.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is an array, false otherwise\n\t * @api public\n\t */\n\t\n\tis.array = Array.isArray || function (value) {\n\t  return toStr.call(value) === '[object Array]';\n\t};\n\t\n\t/**\n\t * is.arguments.empty\n\t * Test if `value` is an empty arguments object.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is an empty arguments object, false otherwise\n\t * @api public\n\t */\n\tis.args.empty = function (value) {\n\t  return is.args(value) && value.length === 0;\n\t};\n\t\n\t/**\n\t * is.array.empty\n\t * Test if `value` is an empty array.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is an empty array, false otherwise\n\t * @api public\n\t */\n\tis.array.empty = function (value) {\n\t  return is.array(value) && value.length === 0;\n\t};\n\t\n\t/**\n\t * is.arraylike\n\t * Test if `value` is an arraylike object.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is an arguments object, false otherwise\n\t * @api public\n\t */\n\t\n\tis.arraylike = function (value) {\n\t  return !!value && !is.bool(value)\n\t    && owns.call(value, 'length')\n\t    && isFinite(value.length)\n\t    && is.number(value.length)\n\t    && value.length >= 0;\n\t};\n\t\n\t/**\n\t * Test boolean.\n\t */\n\t\n\t/**\n\t * is.bool\n\t * Test if `value` is a boolean.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is a boolean, false otherwise\n\t * @api public\n\t */\n\t\n\tis.bool = is['boolean'] = function (value) {\n\t  return toStr.call(value) === '[object Boolean]';\n\t};\n\t\n\t/**\n\t * is.false\n\t * Test if `value` is false.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is false, false otherwise\n\t * @api public\n\t */\n\t\n\tis['false'] = function (value) {\n\t  return is.bool(value) && Boolean(Number(value)) === false;\n\t};\n\t\n\t/**\n\t * is.true\n\t * Test if `value` is true.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is true, false otherwise\n\t * @api public\n\t */\n\t\n\tis['true'] = function (value) {\n\t  return is.bool(value) && Boolean(Number(value)) === true;\n\t};\n\t\n\t/**\n\t * Test date.\n\t */\n\t\n\t/**\n\t * is.date\n\t * Test if `value` is a date.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is a date, false otherwise\n\t * @api public\n\t */\n\t\n\tis.date = function (value) {\n\t  return toStr.call(value) === '[object Date]';\n\t};\n\t\n\t/**\n\t * is.date.valid\n\t * Test if `value` is a valid date.\n\t *\n\t * @param {Mixed} value value to test\n\t * @returns {Boolean} true if `value` is a valid date, false otherwise\n\t */\n\tis.date.valid = function (value) {\n\t  return is.date(value) && !isNaN(Number(value));\n\t};\n\t\n\t/**\n\t * Test element.\n\t */\n\t\n\t/**\n\t * is.element\n\t * Test if `value` is an html element.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is an HTML Element, false otherwise\n\t * @api public\n\t */\n\t\n\tis.element = function (value) {\n\t  return value !== undefined\n\t    && typeof HTMLElement !== 'undefined'\n\t    && value instanceof HTMLElement\n\t    && value.nodeType === 1;\n\t};\n\t\n\t/**\n\t * Test error.\n\t */\n\t\n\t/**\n\t * is.error\n\t * Test if `value` is an error object.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is an error object, false otherwise\n\t * @api public\n\t */\n\t\n\tis.error = function (value) {\n\t  return toStr.call(value) === '[object Error]';\n\t};\n\t\n\t/**\n\t * Test function.\n\t */\n\t\n\t/**\n\t * is.fn / is.function (deprecated)\n\t * Test if `value` is a function.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is a function, false otherwise\n\t * @api public\n\t */\n\t\n\tis.fn = is['function'] = function (value) {\n\t  var isAlert = typeof window !== 'undefined' && value === window.alert;\n\t  if (isAlert) {\n\t    return true;\n\t  }\n\t  var str = toStr.call(value);\n\t  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';\n\t};\n\t\n\t/**\n\t * Test number.\n\t */\n\t\n\t/**\n\t * is.number\n\t * Test if `value` is a number.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is a number, false otherwise\n\t * @api public\n\t */\n\t\n\tis.number = function (value) {\n\t  return toStr.call(value) === '[object Number]';\n\t};\n\t\n\t/**\n\t * is.infinite\n\t * Test if `value` is positive or negative infinity.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is positive or negative Infinity, false otherwise\n\t * @api public\n\t */\n\tis.infinite = function (value) {\n\t  return value === Infinity || value === -Infinity;\n\t};\n\t\n\t/**\n\t * is.decimal\n\t * Test if `value` is a decimal number.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is a decimal number, false otherwise\n\t * @api public\n\t */\n\t\n\tis.decimal = function (value) {\n\t  return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 !== 0;\n\t};\n\t\n\t/**\n\t * is.divisibleBy\n\t * Test if `value` is divisible by `n`.\n\t *\n\t * @param {Number} value value to test\n\t * @param {Number} n dividend\n\t * @return {Boolean} true if `value` is divisible by `n`, false otherwise\n\t * @api public\n\t */\n\t\n\tis.divisibleBy = function (value, n) {\n\t  var isDividendInfinite = is.infinite(value);\n\t  var isDivisorInfinite = is.infinite(n);\n\t  var isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && n !== 0;\n\t  return isDividendInfinite || isDivisorInfinite || (isNonZeroNumber && value % n === 0);\n\t};\n\t\n\t/**\n\t * is.integer\n\t * Test if `value` is an integer.\n\t *\n\t * @param value to test\n\t * @return {Boolean} true if `value` is an integer, false otherwise\n\t * @api public\n\t */\n\t\n\tis.integer = is['int'] = function (value) {\n\t  return is.number(value) && !isActualNaN(value) && value % 1 === 0;\n\t};\n\t\n\t/**\n\t * is.maximum\n\t * Test if `value` is greater than 'others' values.\n\t *\n\t * @param {Number} value value to test\n\t * @param {Array} others values to compare with\n\t * @return {Boolean} true if `value` is greater than `others` values\n\t * @api public\n\t */\n\t\n\tis.maximum = function (value, others) {\n\t  if (isActualNaN(value)) {\n\t    throw new TypeError('NaN is not a valid value');\n\t  } else if (!is.arraylike(others)) {\n\t    throw new TypeError('second argument must be array-like');\n\t  }\n\t  var len = others.length;\n\t\n\t  while (--len >= 0) {\n\t    if (value < others[len]) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * is.minimum\n\t * Test if `value` is less than `others` values.\n\t *\n\t * @param {Number} value value to test\n\t * @param {Array} others values to compare with\n\t * @return {Boolean} true if `value` is less than `others` values\n\t * @api public\n\t */\n\t\n\tis.minimum = function (value, others) {\n\t  if (isActualNaN(value)) {\n\t    throw new TypeError('NaN is not a valid value');\n\t  } else if (!is.arraylike(others)) {\n\t    throw new TypeError('second argument must be array-like');\n\t  }\n\t  var len = others.length;\n\t\n\t  while (--len >= 0) {\n\t    if (value > others[len]) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * is.nan\n\t * Test if `value` is not a number.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is not a number, false otherwise\n\t * @api public\n\t */\n\t\n\tis.nan = function (value) {\n\t  return !is.number(value) || value !== value;\n\t};\n\t\n\t/**\n\t * is.even\n\t * Test if `value` is an even number.\n\t *\n\t * @param {Number} value value to test\n\t * @return {Boolean} true if `value` is an even number, false otherwise\n\t * @api public\n\t */\n\t\n\tis.even = function (value) {\n\t  return is.infinite(value) || (is.number(value) && value === value && value % 2 === 0);\n\t};\n\t\n\t/**\n\t * is.odd\n\t * Test if `value` is an odd number.\n\t *\n\t * @param {Number} value value to test\n\t * @return {Boolean} true if `value` is an odd number, false otherwise\n\t * @api public\n\t */\n\t\n\tis.odd = function (value) {\n\t  return is.infinite(value) || (is.number(value) && value === value && value % 2 !== 0);\n\t};\n\t\n\t/**\n\t * is.ge\n\t * Test if `value` is greater than or equal to `other`.\n\t *\n\t * @param {Number} value value to test\n\t * @param {Number} other value to compare with\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tis.ge = function (value, other) {\n\t  if (isActualNaN(value) || isActualNaN(other)) {\n\t    throw new TypeError('NaN is not a valid value');\n\t  }\n\t  return !is.infinite(value) && !is.infinite(other) && value >= other;\n\t};\n\t\n\t/**\n\t * is.gt\n\t * Test if `value` is greater than `other`.\n\t *\n\t * @param {Number} value value to test\n\t * @param {Number} other value to compare with\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tis.gt = function (value, other) {\n\t  if (isActualNaN(value) || isActualNaN(other)) {\n\t    throw new TypeError('NaN is not a valid value');\n\t  }\n\t  return !is.infinite(value) && !is.infinite(other) && value > other;\n\t};\n\t\n\t/**\n\t * is.le\n\t * Test if `value` is less than or equal to `other`.\n\t *\n\t * @param {Number} value value to test\n\t * @param {Number} other value to compare with\n\t * @return {Boolean} if 'value' is less than or equal to 'other'\n\t * @api public\n\t */\n\t\n\tis.le = function (value, other) {\n\t  if (isActualNaN(value) || isActualNaN(other)) {\n\t    throw new TypeError('NaN is not a valid value');\n\t  }\n\t  return !is.infinite(value) && !is.infinite(other) && value <= other;\n\t};\n\t\n\t/**\n\t * is.lt\n\t * Test if `value` is less than `other`.\n\t *\n\t * @param {Number} value value to test\n\t * @param {Number} other value to compare with\n\t * @return {Boolean} if `value` is less than `other`\n\t * @api public\n\t */\n\t\n\tis.lt = function (value, other) {\n\t  if (isActualNaN(value) || isActualNaN(other)) {\n\t    throw new TypeError('NaN is not a valid value');\n\t  }\n\t  return !is.infinite(value) && !is.infinite(other) && value < other;\n\t};\n\t\n\t/**\n\t * is.within\n\t * Test if `value` is within `start` and `finish`.\n\t *\n\t * @param {Number} value value to test\n\t * @param {Number} start lower bound\n\t * @param {Number} finish upper bound\n\t * @return {Boolean} true if 'value' is is within 'start' and 'finish'\n\t * @api public\n\t */\n\tis.within = function (value, start, finish) {\n\t  if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {\n\t    throw new TypeError('NaN is not a valid value');\n\t  } else if (!is.number(value) || !is.number(start) || !is.number(finish)) {\n\t    throw new TypeError('all arguments must be numbers');\n\t  }\n\t  var isAnyInfinite = is.infinite(value) || is.infinite(start) || is.infinite(finish);\n\t  return isAnyInfinite || (value >= start && value <= finish);\n\t};\n\t\n\t/**\n\t * Test object.\n\t */\n\t\n\t/**\n\t * is.object\n\t * Test if `value` is an object.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is an object, false otherwise\n\t * @api public\n\t */\n\tis.object = function (value) {\n\t  return toStr.call(value) === '[object Object]';\n\t};\n\t\n\t/**\n\t * is.primitive\n\t * Test if `value` is a primitive.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is a primitive, false otherwise\n\t * @api public\n\t */\n\tis.primitive = function isPrimitive(value) {\n\t  if (!value) {\n\t    return true;\n\t  }\n\t  if (typeof value === 'object' || is.object(value) || is.fn(value) || is.array(value)) {\n\t    return false;\n\t  }\n\t  return true;\n\t};\n\t\n\t/**\n\t * is.hash\n\t * Test if `value` is a hash - a plain object literal.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is a hash, false otherwise\n\t * @api public\n\t */\n\t\n\tis.hash = function (value) {\n\t  return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;\n\t};\n\t\n\t/**\n\t * Test regexp.\n\t */\n\t\n\t/**\n\t * is.regexp\n\t * Test if `value` is a regular expression.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is a regexp, false otherwise\n\t * @api public\n\t */\n\t\n\tis.regexp = function (value) {\n\t  return toStr.call(value) === '[object RegExp]';\n\t};\n\t\n\t/**\n\t * Test string.\n\t */\n\t\n\t/**\n\t * is.string\n\t * Test if `value` is a string.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if 'value' is a string, false otherwise\n\t * @api public\n\t */\n\t\n\tis.string = function (value) {\n\t  return toStr.call(value) === '[object String]';\n\t};\n\t\n\t/**\n\t * Test base64 string.\n\t */\n\t\n\t/**\n\t * is.base64\n\t * Test if `value` is a valid base64 encoded string.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if 'value' is a base64 encoded string, false otherwise\n\t * @api public\n\t */\n\t\n\tis.base64 = function (value) {\n\t  return is.string(value) && (!value.length || base64Regex.test(value));\n\t};\n\t\n\t/**\n\t * Test base64 string.\n\t */\n\t\n\t/**\n\t * is.hex\n\t * Test if `value` is a valid hex encoded string.\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if 'value' is a hex encoded string, false otherwise\n\t * @api public\n\t */\n\t\n\tis.hex = function (value) {\n\t  return is.string(value) && (!value.length || hexRegex.test(value));\n\t};\n\t\n\t/**\n\t * is.symbol\n\t * Test if `value` is an ES6 Symbol\n\t *\n\t * @param {Mixed} value value to test\n\t * @return {Boolean} true if `value` is a Symbol, false otherise\n\t * @api public\n\t */\n\t\n\tis.symbol = function (value) {\n\t  return typeof Symbol === 'function' && toStr.call(value) === '[object Symbol]' && typeof symbolValueOf.call(value) === 'symbol';\n\t};\n\t\n\tmodule.exports = is;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar randomFromSeed = __webpack_require__(16);\n\t\n\tvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\n\tvar alphabet;\n\tvar previousSeed;\n\t\n\tvar shuffled;\n\t\n\tfunction reset() {\n\t    shuffled = false;\n\t}\n\t\n\tfunction setCharacters(_alphabet_) {\n\t    if (!_alphabet_) {\n\t        if (alphabet !== ORIGINAL) {\n\t            alphabet = ORIGINAL;\n\t            reset();\n\t        }\n\t        return;\n\t    }\n\t\n\t    if (_alphabet_ === alphabet) {\n\t        return;\n\t    }\n\t\n\t    if (_alphabet_.length !== ORIGINAL.length) {\n\t        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n\t    }\n\t\n\t    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n\t       return ind !== arr.lastIndexOf(item);\n\t    });\n\t\n\t    if (unique.length) {\n\t        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n\t    }\n\t\n\t    alphabet = _alphabet_;\n\t    reset();\n\t}\n\t\n\tfunction characters(_alphabet_) {\n\t    setCharacters(_alphabet_);\n\t    return alphabet;\n\t}\n\t\n\tfunction setSeed(seed) {\n\t    randomFromSeed.seed(seed);\n\t    if (previousSeed !== seed) {\n\t        reset();\n\t        previousSeed = seed;\n\t    }\n\t}\n\t\n\tfunction shuffle() {\n\t    if (!alphabet) {\n\t        setCharacters(ORIGINAL);\n\t    }\n\t\n\t    var sourceArray = alphabet.split('');\n\t    var targetArray = [];\n\t    var r = randomFromSeed.nextValue();\n\t    var characterIndex;\n\t\n\t    while (sourceArray.length > 0) {\n\t        r = randomFromSeed.nextValue();\n\t        characterIndex = Math.floor(r * sourceArray.length);\n\t        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n\t    }\n\t    return targetArray.join('');\n\t}\n\t\n\tfunction getShuffled() {\n\t    if (shuffled) {\n\t        return shuffled;\n\t    }\n\t    shuffled = shuffle();\n\t    return shuffled;\n\t}\n\t\n\t/**\n\t * lookup shuffled letter\n\t * @param index\n\t * @returns {string}\n\t */\n\tfunction lookup(index) {\n\t    var alphabetShuffled = getShuffled();\n\t    return alphabetShuffled[index];\n\t}\n\t\n\tmodule.exports = {\n\t    characters: characters,\n\t    seed: setSeed,\n\t    lookup: lookup,\n\t    shuffled: getShuffled\n\t};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _is = __webpack_require__(1);\n\t\n\tvar _is2 = _interopRequireDefault(_is);\n\t\n\tvar _shortid = __webpack_require__(6);\n\t\n\tvar _shortid2 = _interopRequireDefault(_shortid);\n\t\n\tvar _Emitter = __webpack_require__(4);\n\t\n\tvar _Emitter2 = _interopRequireDefault(_Emitter);\n\t\n\tvar _utils = __webpack_require__(5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * The MIT License (MIT)\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (c) 2019. Wise Wild Web\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  @author : Nathanael Braun\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  @contact : n8tz.js@gmail.com\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\tvar __proto__push = function __proto__push(target, id, parent) {\n\t\tvar fn = function fn() {};\n\t\tfn.prototype = parent ? new parent._[id]() : target[id] || {};\n\t\ttarget[id] = new fn();\n\t\ttarget._[id] = fn;\n\t},\n\t    allScopes = {};\n\t\n\t/**\n\t * Base Scope object\n\t */\n\t\n\tvar Scope = function (_EventEmitter) {\n\t\t_inherits(Scope, _EventEmitter);\n\t\n\t\t_createClass(Scope, null, [{\n\t\t\tkey: \"stateMapToRefList\",\n\t\t\t// all active scopes\n\t\t\t/**\n\t   * get a parsed reference list from stateMap\n\t   * @param _ref\n\t   * @returns {{storeId, path, alias: *, ref: *}}\n\t   */\n\t\t\tvalue: function stateMapToRefList(sm) {\n\t\t\t\tvar state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t\t\t\tvar _refs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t\n\t\t\t\tvar actions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\t\t\tvar path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n\t\n\t\t\t\tvar applier = void 0;\n\t\t\t\tObject.keys(sm).forEach(function (key) {\n\t\t\t\t\tvar cpath = path ? path + '.' + key : key;\n\t\n\t\t\t\t\tsm[key] instanceof Scope.scopeRef ? _refs.push(sm[key].path + ':' + cpath) : sm[key] && sm[key] instanceof Function ? key == \"$apply\" ? applier = sm[key] : actions[key] = sm[key] : sm[key] && sm[key].prototype instanceof Scope.Store ? _refs.push(sm[key].as(cpath)) : state[cpath] = sm[key];\n\t\t\t\t\t//: this.stateMapToRefList(sm[key], _refs, path + '.' + key)\n\t\t\t\t});\n\t\t\t\treturn applier;\n\t\t\t} // if > 0, will wait 'persistenceTm' ms before destroy when dispose reach 0\n\t\n\t\t}, {\n\t\t\tkey: \"getScope\",\n\t\t\tvalue: function getScope(scopes) {\n\t\t\t\tvar skey = _is2.default.array(scopes) ? scopes.sort(function (a, b) {\n\t\t\t\t\tif (a.firstname < b.firstname) return -1;\n\t\t\t\t\tif (a.firstname > b.firstname) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t}).join('+') : scopes;\n\t\t\t\treturn allScopes[skey] = allScopes[skey] || new Scope({}, { id: skey });\n\t\t\t}\n\t\t}]);\n\t\n\t\t/**\n\t  * Init a ReScope scope\n\t  *\n\t  * @param storesMap {Object} Object with the initial stores definition / instances\n\t  * @param config {Object} Scope config\n\t  * {\n\t  *     parent {scope} @optional parent scope\n\t  *\n\t  *     id {string} @optional id ( if this id exist storesMap will be merge on the 'id'\n\t  *     scope)\n\t  *     key {string} @optional key of the scope ( if no id is set, the scope id will be (parent.id+'>'+key)\n\t  *     incrementId {bool} @optional true to add a suffix id, if the provided key or id globally exist\n\t  *\n\t  *     state {Object} @optional initial state by store alias\n\t  *     data {Object} @optional initial data by store alias\n\t  *\n\t  *     rootEmitter {bool} @optional true to not being destabilized by parent\n\t  *     boundedActions {array | regexp} @optional list or regexp of actions not propagated to the parent\n\t  *     autoDestroy {true | false | 'inherit'}\n\t  *     persistenceTm {number) if > 0, will wait 'persistenceTm' ms before destroy when\n\t  *     dispose reach 0 autoDestroy  {bool} will trigger retain & dispose after start\n\t  *  }\n\t  * @returns {Scope}\n\t  */\n\t\tfunction Scope(storesMap) {\n\t\t\tvar _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t\t\t    parent = _ref2.parent,\n\t\t\t    upperScope = _ref2.upperScope,\n\t\t\t    key = _ref2.key,\n\t\t\t    id = _ref2.id,\n\t\t\t    snapshot = _ref2.snapshot,\n\t\t\t    state = _ref2.state,\n\t\t\t    data = _ref2.data,\n\t\t\t    _ref2$incrementId = _ref2.incrementId,\n\t\t\t    incrementId = _ref2$incrementId === undefined ? !!key : _ref2$incrementId,\n\t\t\t    persistenceTm = _ref2.persistenceTm,\n\t\t\t    autoDestroy = _ref2.autoDestroy,\n\t\t\t    rootEmitter = _ref2.rootEmitter,\n\t\t\t    boundedActions = _ref2.boundedActions;\n\t\n\t\t\t_classCallCheck(this, Scope);\n\t\n\t\t\tvar _this = _possibleConstructorReturn(this, (Scope.__proto__ || Object.getPrototypeOf(Scope)).call(this));\n\t\n\t\t\tvar _ = {\n\t\t\t\tkeyPID: upperScope && upperScope._id || parent && parent._id || _shortid2.default.generate(),\n\t\t\t\tkey: key,\n\t\t\t\tincrementId: incrementId,\n\t\t\t\tbaseId: id\n\t\t\t};\n\t\n\t\t\t// generate / set this scope id\n\t\t\tid = id || key && _.keyPID + '>' + key;\n\t\n\t\t\t_.isLocalId = !id;\n\t\n\t\t\tid = id || \"_____\" + _shortid2.default.generate();\n\t\n\t\t\tif (allScopes[id] && !incrementId) {\n\t\t\t\tvar _ret;\n\t\n\t\t\t\t// overwrite existing scope\n\t\t\t\t_this._id = id;\n\t\t\t\tallScopes[id].register(storesMap);\n\t\t\t\treturn _ret = allScopes[id], _possibleConstructorReturn(_this, _ret);\n\t\t\t} else if (allScopes[id] && incrementId) {\n\t\t\t\t// generate key id\n\t\t\t\tvar i = -1;\n\t\t\t\twhile (allScopes[id + '[' + ++i + ']']) {}\n\t\t\t\tid = id + '[' + i + ']';\n\t\t\t}\n\t\n\t\t\t// register this scope in the static Scope.scopes\n\t\t\tallScopes[id] = _this;\n\t\n\t\t\t_this._id = id;\n\t\t\t_this._rev = 0;\n\t\n\t\t\t_this._ = _;\n\t\n\t\t\t_this.actions = {};\n\t\t\t_this.stores = {};\n\t\t\t_this.state = {};\n\t\t\t_this.data = {};\n\t\n\t\t\t_this.parent = parent;\n\t\n\t\t\tif (autoDestroy == 'inherit') autoDestroy = parent && parent._autoDestroy;\n\t\n\t\t\t_this._autoDestroy = autoDestroy;\n\t\t\t_.persistenceTm = persistenceTm || _this.constructor.persistenceTm;\n\t\n\t\t\tif (parent && parent.dead) throw new Error(\"Can't use a dead scope as parent !\");\n\t\n\t\t\t__proto__push(_this, 'actions', parent);\n\t\t\t__proto__push(_this, 'stores', parent);\n\t\t\t__proto__push(_this, 'state', parent);\n\t\t\t__proto__push(_this, 'data', parent);\n\t\n\t\t\t_this.sources = [];\n\t\t\t_.childScopes = [];\n\t\t\t_.childScopesList = [];\n\t\t\t_.unStableChilds = 0;\n\t\t\t_.seenChilds = 0;\n\t\t\t_._listening = {};\n\t\t\t_._scope = {};\n\t\t\t_._mixed = [];\n\t\t\t_._mixedList = [];\n\t\t\t_.followers = [];\n\t\n\t\t\t_this.__retains = { all: 0 };\n\t\t\t_this.__locks = { all: 1 };\n\t\n\t\t\t// todo\n\t\t\t_._boundedActions = _is2.default.array(boundedActions) ? { test: boundedActions.includes.bind(boundedActions) } : boundedActions;\n\t\n\t\t\t// register to the parent scope\n\t\t\tif (parent) {\n\t\t\t\tparent.retain(\"isMyParent\");\n\t\t\t\tif (!rootEmitter) {\n\t\t\t\t\t!parent._stable && _this.wait(\"waitingParent\");\n\t\t\t\t\tparent.on(_._parentList = {\n\t\t\t\t\t\t'stable': function stable(s) {\n\t\t\t\t\t\t\treturn _this.release(\"waitingParent\");\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'unstable': function unstable(s) {\n\t\t\t\t\t\t\treturn _this.wait(\"waitingParent\");\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'update': function update(s) {\n\t\t\t\t\t\t\treturn _this._propag();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tparent.on(_._parentList = {\n\t\t\t\t\t\t'update': function update(s) {\n\t\t\t\t\t\t\treturn _this._propag();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// this.register(parent.__scope, state, data);\n\t\t\t}\n\t\n\t\t\t// register this scope stores\n\t\t\t_this.register(storesMap, state, data);\n\t\t\t_this.__locks.all--;\n\t\t\t_this._stable = !_this.__locks.all;\n\t\n\t\t\tif (parent) {\n\t\t\t\tparent._addChild(_this);\n\t\t\t}\n\t\n\t\t\t// restore snapshots\n\t\t\t_this.restore(snapshot);\n\t\n\t\t\tif (autoDestroy) setTimeout(function (tm) {\n\t\t\t\t_this.retain(\"autoDestroy\");\n\t\t\t\t_this.dispose(\"autoDestroy\");\n\t\t\t});\n\t\n\t\t\treturn _this;\n\t\t}\n\t\n\t\t/**\n\t  *\n\t  * Mount the stores in storesList, in this scope or in its parents or mixed scopes\n\t  *\n\t  * @param storeIdList {string|storeRef} Store name, Array of Store names, or Rescope\n\t  *     store ref from Store::as or Store:as\n\t  * @param state\n\t  * @param data\n\t  * @returns {Scope}\n\t  */\n\t\n\t\n\t\t_createClass(Scope, [{\n\t\t\tkey: \"mount\",\n\t\t\tvalue: function mount(storeIdList, snapshot, state, data) {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\tif (_is2.default.array(storeIdList)) {\n\t\t\t\t\tstoreIdList.forEach(function (storeId) {\n\t\t\t\t\t\treturn _this2._mount(storeId, snapshot, state, data);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis._mount.apply(this, arguments);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"_mount\",\n\t\t\tvalue: function _mount(id, snapshot, state, data) {\n\t\t\t\tvar ref = void 0,\n\t\t\t\t    _ = this._;\n\t\n\t\t\t\tref = this.parseRef(id);\n\t\n\t\t\t\tif (id == \"$parent\") return;\n\t\t\t\tif (!_._scope[ref.storeId]) {\n\t\t\t\t\tvar _parent;\n\t\n\t\t\t\t\t//ask mixed || parent\n\t\t\t\t\tif (_._mixed.reduceRight(function (mounted, ctx) {\n\t\t\t\t\t\treturn mounted || ctx._mount(id, snapshot, state, data);\n\t\t\t\t\t}, false) || !this.parent) return;\n\t\t\t\t\treturn (_parent = this.parent)._mount.apply(_parent, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tvar store = _._scope[ref.storeId],\n\t\t\t\t\t    taskQueue = [];\n\t\t\t\t\tif (Scope.isStoreClass(store)) {\n\t\t\t\t\t\t_._scope[ref.storeId] = new store(this, {\n\t\t\t\t\t\t\t//snapshot,\n\t\t\t\t\t\t\tname: ref.storeId,\n\t\t\t\t\t\t\tstate: state,\n\t\t\t\t\t\t\tdata: data\n\t\t\t\t\t\t}, taskQueue);\n\t\t\t\t\t\twhile (taskQueue.length) {\n\t\t\t\t\t\t\ttaskQueue.shift()();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (Scope.isScopeClass(store)) {\n\t\t\t\t\t\tstore = _._scope[ref.storeId] = new store({ $parent: this }, {\n\t\t\t\t\t\t\tkey: ref.storeId,\n\t\t\t\t\t\t\tincrementId: true,\n\t\t\t\t\t\t\tupperScope: this\n\t\t\t\t\t\t\t//autoDestroy: true\n\t\t\t\t\t\t\t//parent: this\n\t\t\t\t\t\t});\n\t\t\t\t\t\t//_._scope[ ref.storeId ].retain(\"scopedChildScope\");\n\t\t\t\t\t\t//_watchStore(ref.storeId);\n\t\t\t\t\t\tif (ref.path.length > 1) _._scope[ref.storeId].mount(ref.path.slice(1).join('.'), snapshot, state, data);\n\t\t\t\t\t\t//else return _._scope[ ref.storeId ];\n\t\t\t\t\t}\n\t\t\t\t\tif (Scope.isStore(store)) {\n\t\t\t\t\t\tif (state !== undefined && data === undefined) store.setState(state);else if (state !== undefined) store.state = state;\n\t\n\t\t\t\t\t\tif (data !== undefined) store.push(data);\n\t\t\t\t\t}\n\t\t\t\t\tthis._watchStore(ref.storeId);\n\t\t\t\t}\n\t\n\t\t\t\treturn _._scope[ref.storeId];\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Register stores in storesMap & link them in the protos\n\t   * @param storesMap\n\t   * @param state\n\t   * @param data\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"register\",\n\t\t\tvalue: function register(storesMap) {\n\t\t\t\tvar _this3 = this;\n\t\n\t\t\t\tvar state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\t\t\tvar data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t\t\t\tthis.relink(storesMap, this, false, false);\n\t\t\t\tObject.keys(storesMap).forEach(function (id) {\n\t\t\t\t\tif (id == \"$parent\") return;\n\t\t\t\t\tif (storesMap[id].singleton || _is2.default.fn(storesMap[id]) && (state[id] || data[id])) {\n\t\t\t\t\t\t_this3._mount(id, undefined, state[id], data[id]);\n\t\t\t\t\t} else if (state[id] || data[id]) {\n\t\t\t\t\t\tif (data[id]) {\n\t\t\t\t\t\t\tif (state[id]) _this3.stores[id].state = state[id];\n\t\t\t\t\t\t\t_this3.stores[id].push(data[id]);\n\t\t\t\t\t\t} else if (state[id]) {\n\t\t\t\t\t\t\t_this3.stores[id].setState(state[id]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_this3._watchStore(id);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Map srcCtx store's on targetCtx headers proto's\n\t   * @param srcCtx\n\t   * @param targetCtx\n\t   * @param state\n\t   * @param data\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"relink\",\n\t\t\tvalue: function relink(srcCtx) {\n\t\t\t\tvar targetCtx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\t\n\t\t\t\tvar _this4 = this;\n\t\n\t\t\t\tvar external = arguments[2];\n\t\t\t\tvar force = arguments[3];\n\t\n\t\t\t\tvar _ = this._;\n\t\t\t\tObject.keys(srcCtx).forEach(function (id) {\n\t\t\t\t\tvar hotReloading = void 0;\n\t\n\t\t\t\t\t// same store def : ignore\n\t\t\t\t\tif (!force && targetCtx._._scope[id] === srcCtx[id] || targetCtx._._scope[id] && targetCtx._._scope[id].constructor === srcCtx[id]) return;\n\t\n\t\t\t\t\t// hot switch\n\t\t\t\t\tif (!force && targetCtx._._scope[id]) {\n\t\n\t\t\t\t\t\tif (!external && !_is2.default.fn(targetCtx._._scope[id])) {\n\t\t\t\t\t\t\tconsole.info(\"Rescope Store : \", id, \" already exist in this scope ! ( Hot switching the store ) !!!\");\n\t\t\t\t\t\t\tvar tmp = targetCtx._._scope[id];\n\t\t\t\t\t\t\ttargetCtx._._scope[id] = srcCtx[id];\n\t\t\t\t\t\t\thotReloading = tmp.nextState;\n\t\t\t\t\t\t\ttmp.destroy();\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (!external && _is2.default.fn(targetCtx._._scope[id])) targetCtx._._scope[id] = srcCtx[id];\n\t\t\t\t\t} else if (!force && !external) _._scope[id] = srcCtx[id];\n\t\n\t\t\t\t\t// map the store id\n\t\t\t\t\tObject.defineProperty(targetCtx._.stores.prototype, id, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tget: function get() {\n\t\t\t\t\t\t\treturn _._scope[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\t// not mapping hierarchic scopes\n\t\t\t\t\tif (id === \"$parent\") return;\n\t\n\t\t\t\t\t// map state & data\n\t\t\t\t\tObject.defineProperty(targetCtx._.state.prototype, id, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tget: function get() {\n\t\t\t\t\t\t\treturn _._scope[id] && _._scope[id].state;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset: function set(v) {\n\t\t\t\t\t\t\treturn _this4._mount(id, undefined, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tObject.defineProperty(targetCtx._.data.prototype, id, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tget: function get() {\n\t\t\t\t\t\t\treturn _._scope[id] && _._scope[id].data;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset: function set(v) {\n\t\t\t\t\t\t\treturn _this4._mount(id, undefined, undefined, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\t// action mapping\n\t\t\t\t\tvar actions = srcCtx[id] instanceof Scope.Store ? srcCtx[id].constructor.actions : srcCtx[id].actions,\n\t\t\t\t\t    activeActions = targetCtx._.actions.prototype;\n\t\t\t\t\tif (Scope.isScope(_._scope[id].prototype)) _this4._mount(id);\n\t\t\t\t\tif (Scope.isScope(_._scope[id])) {\n\t\t\t\t\t\tactiveActions[id] = _._scope[id].actions;\n\t\t\t\t\t}\n\t\t\t\t\tif (!Scope.isStore(_._scope[id]) && !Scope.isStoreClass(_._scope[id])) return;\n\t\n\t\t\t\t\tactions && Object.keys(actions).forEach(function (act) {\n\t\t\t\t\t\tif (activeActions.hasOwnProperty(act)) activeActions[act].__targetStores++;else {\n\t\t\t\t\t\t\tactiveActions[act] = _this4.dispatch.bind(_this4, act);\n\t\t\t\t\t\t\tactiveActions[act].__targetStores = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\t// remount the store if it was hot reloaded\n\t\t\t\t\tif (hotReloading) _this4._mount(id, null, hotReloading);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Make this scope watching the local store 'id'\n\t   * @param id\n\t   * @returns {boolean}\n\t   * @private\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"_watchStore\",\n\t\t\tvalue: function _watchStore(id) {\n\t\t\t\tvar _this5 = this;\n\t\n\t\t\t\tvar _ = this._;\n\t\t\t\tif (!_._listening[id] && !_is2.default.fn(_._scope[id])) {\n\t\t\t\t\t!_._scope[id]._autoDestroy && _._scope[id].retain(\"scoped\");\n\t\t\t\t\t!_._scope[id].isStable() && this.wait(id);\n\t\t\t\t\t_._scope[id].on(_._listening[id] = {\n\t\t\t\t\t\t'destroy': function destroy(s) {\n\t\t\t\t\t\t\tdelete _._listening[id];\n\t\t\t\t\t\t\t_._scope[id] = _._scope[id].constructor;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'update': function update(s) {\n\t\t\t\t\t\t\treturn _this5.propag();\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'stable': function stable(s) {\n\t\t\t\t\t\t\treturn _this5.release(id);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'unstable': function unstable(s) {\n\t\t\t\t\t\t\treturn _this5.wait(id);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Mix targetCtx on this scope\n\t   * Mixed scope parents are NOT mapped\n\t   * @param targetCtx\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"mixin\",\n\t\t\tvalue: function mixin(targetCtx) {\n\t\t\t\tvar _this6 = this;\n\t\n\t\t\t\tvar parent = this.parent,\n\t\t\t\t    lists = void 0,\n\t\t\t\t    _ = this._;\n\t\n\t\t\t\t_._mixed.push(targetCtx);\n\t\n\t\t\t\ttargetCtx.retain(\"mixedTo\");\n\t\n\t\t\t\tif (!targetCtx._stable) this.wait(targetCtx._id);\n\t\n\t\t\t\t_._mixedList.push(lists = {\n\t\t\t\t\t'stable': function stable(s) {\n\t\t\t\t\t\treturn _this6.release(targetCtx._id);\n\t\t\t\t\t},\n\t\t\t\t\t'unstable': function unstable(s) {\n\t\t\t\t\t\treturn _this6.wait(targetCtx._id);\n\t\t\t\t\t},\n\t\t\t\t\t'update': function update(s) {\n\t\t\t\t\t\treturn _this6._propag();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\ttargetCtx.on(lists);\n\t\n\t\t\t\t// reset protos\n\t\t\t\t// push new proto with parent\n\t\t\t\t__proto__push(this, 'actions', parent);\n\t\t\t\t__proto__push(this, 'stores', parent);\n\t\t\t\t__proto__push(this, 'state', parent);\n\t\t\t\t__proto__push(this, 'data', parent);\n\t\n\t\t\t\t// bind local accessors in the new proto\n\t\t\t\tthis.relink(_._scope, this, false, true);\n\t\n\t\t\t\t_._mixed.forEach(function (ctx) {\n\t\t\t\t\t// push protos\n\t\t\t\t\t__proto__push(_this6, 'actions');\n\t\t\t\t\t__proto__push(_this6, 'stores');\n\t\t\t\t\t__proto__push(_this6, 'state');\n\t\t\t\t\t__proto__push(_this6, 'data');\n\t\t\t\t\t_this6.stores.__origin = \"mixed \" + ctx._id;\n\t\t\t\t\t// write mixed accessors\n\t\t\t\t\tctx.relink(ctx._._scope, _this6, true, true);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Bind stores from this scope, his parents or mixed scopes to obj\n\t   *\n\t   * @param target {React.Component|Store|function}\n\t   * @param key {string} stores keys to bind updates\n\t   * @param as\n\t   * @param setInitial {boolean} false to not propag initial value (default : true)\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"bind\",\n\t\t\tvalue: function bind(target, key, as) {\n\t\t\t\tvar _this7 = this;\n\t\n\t\t\t\tvar setInitial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\t\t\t\tvar revMap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\t\n\t\t\t\tvar lastRevs = void 0,\n\t\t\t\t    data = void 0,\n\t\t\t\t    refKeys = void 0;\n\t\t\t\tif (key && !_is2.default.array(key)) key = [key];\n\t\n\t\t\t\tif (as === false || as === true) {\n\t\t\t\t\tsetInitial = as;\n\t\t\t\t\tas = null;\n\t\t\t\t}\n\t\n\t\t\t\trefKeys = key.map(function (id) {\n\t\t\t\t\treturn _is2.default.string(id) ? id : id.name;\n\t\t\t\t}).map(function (id) {\n\t\t\t\t\treturn _this7.parseRef(id);\n\t\t\t\t});\n\t\n\t\t\t\tthis._.followers.push([target, key, as || undefined, lastRevs = refKeys.reduce(function (revs, ref) {\n\t\t\t\t\trevs[ref.storeId] = revs[ref.storeId] || {\n\t\t\t\t\t\trev: 0,\n\t\t\t\t\t\trefs: []\n\t\t\t\t\t};\n\t\t\t\t\trevs[ref.storeId].refs.push(ref);\n\t\t\t\t\treturn revs;\n\t\t\t\t}, revMap)]);\n\t\n\t\t\t\tthis.mount(key);\n\t\t\t\tthis.retainStores(Object.keys(lastRevs), 'listeners');\n\t\n\t\t\t\tif (setInitial && this._stable) {\n\t\t\t\t\tdata = this.getUpdates(lastRevs);\n\t\t\t\t\tif (!data) return this;\n\t\t\t\t\tif (typeof target != \"function\") {\n\t\t\t\t\t\tif (as) target.setState(_defineProperty({}, as, data));else target.setState(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Un bind this scope off the given component-keys\n\t   * @param target\n\t   * @param key\n\t   * @returns {Array.<*>}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"unBind\",\n\t\t\tvalue: function unBind(target, key, as) {\n\t\t\t\tvar followers = this._.followers,\n\t\t\t\t    i = followers && followers.length;\n\t\t\t\twhile (followers && i--) {\n\t\t\t\t\tif (followers[i][0] === target && '' + followers[i][1] == '' + key && followers[i][2] == as) {\n\t\t\t\t\t\tthis.disposeStores(Object.keys(followers[i][3]), 'listeners');\n\t\t\t\t\t\treturn followers.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Mount the stores in storeIdList from this scope, its parents and mixed scope\n\t   * Bind them to 'to'\n\t   * Hook 'to' so it will auto unbind on 'destroy' or 'componentWillUnmount'\n\t   * @param target\n\t   * @param storeIdList\n\t   * @param bind\n\t   * @returns {Object} Initial outputs of the stores in 'storesList'\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"map\",\n\t\t\tvalue: function map(target, storeIdList) {\n\t\t\t\tvar _this8 = this;\n\t\n\t\t\t\tvar bind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\t\t\tvar revMap = arguments[3];\n\t\n\t\t\t\tvar Store = this.constructor.Store;\n\t\t\t\tstoreIdList = _is2.default.array(storeIdList) ? storeIdList : [storeIdList];\n\t\t\t\tvar refList = storeIdList.map(this.parseRef);\n\t\t\t\tthis.mount(storeIdList);\n\t\t\t\tif (bind && target instanceof Store) {\n\t\t\t\t\tStore.map(target, storeIdList, this, this, false);\n\t\t\t\t} else if (bind) {\n\t\t\t\t\tthis.bind(target, storeIdList, undefined, false);\n\t\n\t\t\t\t\tvar mixedCWUnmount = void 0,\n\t\t\t\t\t    unMountKey = target.isReactComponent ? \"componentWillUnmount\" : \"destroy\";\n\t\n\t\t\t\t\tif (target.hasOwnProperty(unMountKey)) {\n\t\t\t\t\t\tmixedCWUnmount = target[unMountKey];\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttarget[unMountKey] = function () {\n\t\t\t\t\t\tdelete target[unMountKey];\n\t\t\t\t\t\tif (mixedCWUnmount) target[unMountKey] = mixedCWUnmount;\n\t\n\t\t\t\t\t\t_this8.unBind(target, storeIdList);\n\t\t\t\t\t\treturn target[unMountKey] && target[unMountKey].apply(target, arguments);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn revMap && this.getUpdates(revMap) || refList.reduce(function (data, ref) {\n\t\t\t\t\t(0, _utils.walknSet)(data, ref.alias || ref.path, _this8.retrieve(ref.path));\n\t\t\t\t\treturn data;\n\t\t\t\t}, {});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Get current data value from json path\n\t   * @param path\n\t   * @returns {string|*}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"retrieve\",\n\t\t\tvalue: function retrieve() {\n\t\t\t\tvar path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\t\n\t\t\t\tpath = _is2.default.string(path) ? path.split('.') : path;\n\t\n\t\t\t\treturn path && this.stores[path[0]] && this.stores[path[0]].retrieve && this.stores[path[0]].retrieve(path.slice(1));\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Restore all nodes in a jsonPath\n\t   * @param path\n\t   * @returns {string|*}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"restoreRefPath\",\n\t\t\tvalue: function restoreRefPath() {\n\t\t\t\tvar path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\t\n\t\t\t\tpath = _is2.default.string(path) ? path.split('.') : path;\n\t\n\t\t\t\tvar obj = void 0,\n\t\t\t\t    i = 0,\n\t\t\t\t    cScope = this;\n\t\n\t\t\t\twhile (i < path.length) {\n\t\t\t\t\tobj = cScope.stores[path[i]];\n\t\t\t\t\tif (Scope.isScopeClass(obj) || Scope.isStoreClass(obj)) {\n\t\t\t\t\t\tcScope.mount(path[0]);\n\t\t\t\t\t\tobj = cScope.stores[path[i]];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (Scope.isScope(obj)) {\n\t\t\t\t\t\tcScope = obj;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (Scope.isStore(obj)) {\n\t\t\t\t\t\tobj.restore();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Get target store from json path\n\t   * @param path\n\t   * @returns {string|*}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"retrieveStore\",\n\t\t\tvalue: function retrieveStore() {\n\t\t\t\tvar path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\t\n\t\t\t\tpath = _is2.default.string(path) ? path.split('.') : path;\n\t\t\t\treturn path && path.length && (path.length != 1 && this.stores[path[0]].retrieveStore ? this.stores[path[0]].retrieveStore(path.slice(1)) : path.length == 1 && this.stores[path[0]]);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Get or update stores revisions in 'storesRevMap'\n\t   * @param storesRevMap\n\t   * @param local\n\t   * @returns {{}}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getStoresRevs\",\n\t\t\tvalue: function getStoresRevs() {\n\t\t\t\tvar storesRevMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\t\t\tvar local = arguments[1];\n\t\n\t\t\t\tvar ctx = this._._scope;\n\t\t\t\tif (!storesRevMap) {\n\t\t\t\t\tstoresRevMap = {};\n\t\t\t\t}\n\t\t\t\tObject.keys(ctx).forEach(function (id) {\n\t\t\t\t\tif (id == \"$parent\") return;\n\t\t\t\t\tif (!_is2.default.fn(ctx[id])) {\n\t\t\t\t\t\tstoresRevMap[id] = ctx[id]._rev;\n\t\t\t\t\t} else if (!storesRevMap.hasOwnProperty(id)) storesRevMap[id] = false;\n\t\t\t\t});\n\t\t\t\tif (!local) {\n\t\t\t\t\tthis._._mixed.reduce(function (updated, ctx) {\n\t\t\t\t\t\treturn ctx.getStoresRevs(storesRevMap), storesRevMap;\n\t\t\t\t\t}, storesRevMap);\n\t\t\t\t\tthis.parent && this.parent.getStoresRevs(storesRevMap);\n\t\t\t\t}\n\t\t\t\treturn storesRevMap;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Recursively get all stores revs\n\t   * @param childs\n\t   * @returns {Array}\n\t   * @private\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"_getRevMap\",\n\t\t\tvalue: function _getRevMap() {\n\t\t\t\tvar storesRevMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t\t\t\tvar ctx = this._._scope;\n\t\t\t\tObject.keys(ctx).forEach(function (id) {\n\t\t\t\t\tif (id == \"$parent\" || storesRevMap[id]) return;\n\t\t\t\t\tstoresRevMap[id] = { rev: ctx[id]._rev, refs: [] };\n\t\t\t\t});\n\t\t\t\tthis._._mixed.reduceRight(function (storesRevMap, ctx) {\n\t\t\t\t\treturn ctx._getRevMap(storesRevMap);\n\t\t\t\t}, storesRevMap);\n\t\t\t\tthis.parent && this.parent._getRevMap(storesRevMap);\n\t\t\t\treturn storesRevMap;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Get updated output basing storesRevMap's revisions.\n\t   * If a store in 'storesRevMap' was updated; add it to 'output' & update storesRevMap\n\t   * @param storesRevMap\n\t   * @param output\n\t   * @param updated\n\t   * @returns {*|{}}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getRefsUpdates\",\n\t\t\tvalue: function getRefsUpdates(refs, revMap, output) {\n\t\t\t\tvar _this9 = this;\n\t\n\t\t\t\trevMap = revMap || refs.map(function (id) {\n\t\t\t\t\treturn _is2.default.string(id) ? id : id.name;\n\t\t\t\t}).map(function (id) {\n\t\t\t\t\treturn _this9.parseRef(id);\n\t\t\t\t}).reduce(function (revs, ref) {\n\t\t\t\t\trevs[ref.storeId] = revs[ref.storeId] || {\n\t\t\t\t\t\trev: 0,\n\t\t\t\t\t\trefs: []\n\t\t\t\t\t};\n\t\t\t\t\trevs[ref.storeId].refs.push(ref);\n\t\t\t\t\treturn revs;\n\t\t\t\t}, {});\n\t\n\t\t\t\treturn this.getUpdates(revMap, output);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Get or update output basing storesRevMap's revisions.\n\t   * If a store in 'storesRevMap' was updated; add it to 'output' & update storesRevMap\n\t   * @param storesRevMap\n\t   * @param output\n\t   * @param updated\n\t   * @returns {*|{}}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getUpdates\",\n\t\t\tvalue: function getUpdates(storesRevMap, output, updated) {\n\t\t\t\tvar _this10 = this;\n\t\n\t\t\t\toutput = output || {};\n\t\t\t\tstoresRevMap = storesRevMap || this._getRevMap();\n\t\t\t\tObject.keys(storesRevMap).forEach(function (id) {\n\t\t\t\t\tvar store = _this10.stores[id];\n\t\t\t\t\tstoresRevMap[id] = storesRevMap[id] || { rev: 0, refs: [] };\n\t\n\t\t\t\t\tif (store && _is2.default.fn(store)) {\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\toutput[id] = undefined;\n\t\t\t\t\t} else if (store && store._rev > storesRevMap[id].rev) {\n\t\t\t\t\t\tstoresRevMap[id].rev = store._rev;\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tstoresRevMap[id].refs.forEach(function (ref) {\n\t\n\t\t\t\t\t\t\toutput[ref.alias] = _this10.retrieve(ref.path);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn updated && output;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Recursively get all child scopes\n\t   * @param childs\n\t   * @returns {Array}\n\t   * @private\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"_getAllChilds\",\n\t\t\tvalue: function _getAllChilds() {\n\t\t\t\tvar childs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\n\t\t\t\tchilds.push.apply(childs, _toConsumableArray(this._.childScopes));\n\t\t\t\tthis._.childScopes.forEach(function (ctx) {\n\t\t\t\t\tctx._getAllChilds(childs);\n\t\t\t\t});\n\t\t\t\treturn childs;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Serialize all active stores state & data in every childs & mixed scopes\n\t   *\n\t   * Scopes without key or id are ignored\n\t   * @param output\n\t   * @returns {{}}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"serialize\",\n\t\t\tvalue: function serialize() {\n\t\t\t\tvar cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\t\t\tvar output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\t\t\tvar ctx = this._._scope,\n\t\t\t\t    _ref3 = this._,\n\t\t\t\t    baseId = _ref3.baseId,\n\t\t\t\t    key = _ref3.key,\n\t\t\t\t    keyPID = _ref3.keyPID,\n\t\t\t\t    incrementId = _ref3.incrementId,\n\t\t\t\t    alias = cfg.alias,\n\t\t\t\t    parentAlias = cfg.parentAlias,\n\t\t\t\t    sid = key ? (parentAlias || keyPID) + '>' + key : alias || parentAlias && parentAlias + '/' + baseId || this._id;\n\t\n\t\t\t\t//alias = alias || baseId;\n\t\t\t\treturn this.serialize_ex(cfg, output, sid, alias, [\"$parent\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"serialize_ex\",\n\t\t\tvalue: function serialize_ex() {\n\t\t\t\tvar cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\t\t\tvar output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\t\t\tvar sid = arguments[2];\n\t\t\t\tvar alias = arguments[3];\n\t\t\t\tvar exclude = arguments[4];\n\t\t\t\tvar _ = this._,\n\t\t\t\t    ctx = _._scope,\n\t\t\t\t    incrementId = _.incrementId,\n\t\t\t\t    _cfg$withChilds = cfg.withChilds,\n\t\t\t\t    withChilds = _cfg$withChilds === undefined ? true : _cfg$withChilds,\n\t\t\t\t    _cfg$withMixed = cfg.withMixed,\n\t\t\t\t    withMixed = _cfg$withMixed === undefined ? true : _cfg$withMixed,\n\t\t\t\t    norefs = cfg.norefs;\n\t\n\t\n\t\t\t\tif ((0, _utils.keyWalknGet)(output, sid)) {\n\t\t\t\t\tif (!incrementId) // done\n\t\t\t\t\t\treturn output;else if (incrementId) {\n\t\t\t\t\t\t// generate key id\n\t\t\t\t\t\tvar i = -1;\n\t\t\t\t\t\twhile ((0, _utils.keyWalknGet)(output, sid + '[' + ++i + ']')) {}\n\t\t\t\t\t\tsid = sid + '[' + i + ']';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t(0, _utils.keyWalknSet)(output, sid, {});\n\t\n\t\t\t\tObject.keys(ctx).forEach(function (id) {\n\t\t\t\t\tif (exclude.includes(id) || Scope.isStoreClass(ctx[id]) || Scope.isScopeClass(ctx[id])) return;\n\t\n\t\t\t\t\tctx[id].serialize(_extends({}, cfg, { parentAlias: sid }), output);\n\t\t\t\t});\n\t\n\t\t\t\twithChilds && _.childScopes.forEach(function (ctx) {\n\t\t\t\t\t!ctx._.isLocalId && ctx.serialize({\n\t\t\t\t\t\twithChild: true,\n\t\t\t\t\t\twithParents: false,\n\t\t\t\t\t\tparentAlias: sid,\n\t\t\t\t\t\twithMixed: withMixed,\n\t\t\t\t\t\tnorefs: norefs\n\t\t\t\t\t}, output);\n\t\t\t\t});\n\t\n\t\t\t\twithMixed && _._mixed.forEach(function (ctx) {\n\t\t\t\t\t!ctx._.isLocalId && ctx.serialize({\n\t\t\t\t\t\twithChild: false,\n\t\t\t\t\t\twithParents: false,\n\t\t\t\t\t\twithMixed: withMixed,\n\t\t\t\t\t\tnorefs: norefs\n\t\t\t\t\t}, output);\n\t\t\t\t});\n\t\n\t\t\t\tif (alias) {\n\t\t\t\t\toutput = Object.keys(output).reduce(function (h, k) {\n\t\t\t\t\t\treturn h[k === _id ? alias : k] = output[k], h;\n\t\t\t\t\t}, {});\n\t\t\t\t}\n\t\t\t\treturn output;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Restore state & data from the serialize fn\n\t   * @param snapshot\n\t   * @param force\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"restore\",\n\t\t\tvalue: function restore(snapshot) {\n\t\t\t\tvar _this11 = this;\n\t\n\t\t\t\tvar cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\t\t\tvar force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _is2.default.bool(cfg) && cfg;\n\t\n\t\t\t\tvar ctx = this._._scope,\n\t\t\t\t    snap = void 0;\n\t\n\t\t\t\tif (snapshot && cfg && cfg.alias && cfg.alias != this._id) {\n\t\t\t\t\tsnap = _extends({}, snapshot, _defineProperty({}, this._id, snapshot[cfg.alias]));\n\t\t\t\t\tdelete snap[cfg.alias];\n\t\t\t\t\tsnapshot = snap;\n\t\t\t\t}\n\t\t\t\tsnapshot = snapshot && (0, _utils.keyWalknGet)(snapshot, this._id) || this.takeSnapshotByKey(this._id);\n\t\n\t\t\t\tif (!snapshot) return;\n\t\n\t\t\t\tthis._.snapshot = _extends({}, snapshot);\n\t\n\t\t\t\tsnap = snapshot['/'];\n\t\t\t\tsnapshot['/'] = _extends({}, snap);\n\t\t\t\tsnap && Object.keys(snap).forEach(function (name) {\n\t\t\t\t\tif (name == \"$parent\") return;\n\t\n\t\t\t\t\tif (ctx[name]) {\n\t\n\t\t\t\t\t\tif (force && !_is2.default.fn(ctx[name])) ctx[name].destroy();\n\t\n\t\t\t\t\t\t_this11._mount(name); // quiet\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tthis._._mixed.forEach(function (ctx) {\n\t\t\t\t\t!ctx._.isLocalId && ctx.restore(undefined, force);\n\t\t\t\t});\n\t\n\t\t\t\tthis._.childScopes.forEach(function (ctx) {\n\t\t\t\t\t!ctx._.isLocalId && ctx.restore(undefined, force);\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"getSnapshotByKey\",\n\t\t\tvalue: function getSnapshotByKey(key, local) {\n\t\t\t\t// only have the local snap\n\t\t\t\tif (this._.snapshot && key.startsWith(this._id)) {\n\t\t\t\t\tvar obj = (0, _utils.keyWalknGet)(this._.snapshot, key.substr(this._id.length));\n\t\t\t\t\treturn obj;\n\t\t\t\t} else return !local && this.parent && this.parent.getSnapshotByKey(key) || this.stores.$parent && this.stores.$parent.getSnapshotByKey(key);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"getSnapshotByKeyExt\",\n\t\t\tvalue: function getSnapshotByKeyExt(snapshot, key, local) {\n\t\t\t\t// only have the local snap\n\t\t\t\tif (snapshot) {\n\t\t\t\t\tvar obj = (0, _utils.keyWalknGet)(snapshot, key);\n\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"takeSnapshotByKey\",\n\t\t\tvalue: function takeSnapshotByKey(key, local) {\n\t\t\t\tif (this._.snapshot && key.startsWith(this._id)) {\n\t\t\t\t\tvar obj = (0, _utils.keyWalknGet)(this._.snapshot, key.substr(this._id.length));\n\t\t\t\t\tif (obj) {\n\t\t\t\t\t\tthis.deleteSnapshotByKey(key, true);\n\t\t\t\t\t}\n\t\t\t\t\treturn obj;\n\t\t\t\t} else return !local && this.parent && this.parent.takeSnapshotByKey(key) || this.stores.$parent && this.stores.$parent.takeSnapshotByKey(key);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"deleteSnapshotByKey\",\n\t\t\tvalue: function deleteSnapshotByKey(key, local) {\n\t\t\t\tif (this._.snapshot && key.startsWith(this._id)) {\n\t\t\t\t\tvar obj = (0, _utils.keyWalknGet)(this._.snapshot, key.substr(this._id.length).replace(/^(.*[\\>|\\/])[^\\>|\\/]+$/ig, '$1'));\n\t\t\t\t\tif (obj) delete obj[key.replace(/^.*[\\>|\\/]([^\\>|\\/]+)$/ig, '$1')];\n\t\t\t\t}\n\t\t\t\treturn !local && this.parent && this.parent.deleteSnapshotByKey(key) || this.stores.$parent && this.stores.$parent.deleteSnapshotByKey(key);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"setState\",\n\t\t\tvalue: function setState(pState) {\n\t\t\t\tvar _this12 = this;\n\t\n\t\t\t\tObject.keys(pState).forEach(function (k) {\n\t\t\t\t\treturn _this12.state[k] = pState[k];\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * get a parsed reference\n\t   * @param _ref\n\t   * @returns {{storeId, path, alias: *, ref: *}}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"parseRef\",\n\t\t\tvalue: function parseRef(_ref) {\n\t\t\t\tif (typeof _ref !== 'string') {\n\t\t\t\t\t// @todo : rm this\n\t\t\t\t\tthis.register(_defineProperty({}, _ref.name, _ref.store));\n\t\t\t\t\t_ref = _ref.name;\n\t\t\t\t}\n\t\t\t\tvar ref = _ref.split(':');\n\t\t\t\tref[0] = ref[0].split('.');\n\t\t\t\treturn {\n\t\t\t\t\tstoreId: ref[0][0],\n\t\t\t\t\tpath: ref[0],\n\t\t\t\t\talias: ref[1] || ref[0][ref[0].length - 1],\n\t\t\t\t\tref: _ref\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Dispatch an action to the top parent & mixed scopes, in all stores\n\t   *\n\t   * @param action\n\t   * @param data\n\t   * @returns {Scope}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"dispatch\",\n\t\t\tvalue: function dispatch(action) {\n\t\t\t\tvar _this13 = this,\n\t\t\t\t    _parent2;\n\t\n\t\t\t\tfor (var _len = arguments.length, argz = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\t\targz[_key - 1] = arguments[_key];\n\t\t\t\t}\n\t\n\t\t\t\tif (this.dead) {\n\t\t\t\t\tconsole.warn(\"Dispatch was called on a dead scope, check you're async functions in this stack...\", new Error().stack);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar bActs = this._._boundedActions;\n\t\t\t\tObject.keys(this._._scope).forEach(function (id) {\n\t\t\t\t\tvar _$_scope$id;\n\t\n\t\t\t\t\tif (id == \"$parent\") return;\n\t\t\t\t\tif (!_is2.default.fn(_this13._._scope[id])) (_$_scope$id = _this13._._scope[id]).trigger.apply(_$_scope$id, [action].concat(argz));\n\t\t\t\t});\n\t\n\t\t\t\tif (bActs && bActs.test(action)) return this;\n\t\n\t\t\t\tthis._._mixed.forEach(function (ctx) {\n\t\t\t\t\treturn ctx.dispatch.apply(ctx, [action].concat(argz));\n\t\t\t\t});\n\t\t\t\tthis.parent && (_parent2 = this.parent).dispatch.apply(_parent2, [action].concat(argz));\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"trigger\",\n\t\t\tvalue: function trigger() {\n\t\t\t\tthis.dispatch.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * once('stable', cb)\n\t   * @param obj {React.Component|Store|function)\n\t   * @param key {string} optional key where to map the public state\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"then\",\n\t\t\tvalue: function then(cb) {\n\t\t\t\tvar _this14 = this;\n\t\n\t\t\t\tif (!this._stable) return this.once('stable', function (e) {\n\t\t\t\t\treturn _this14.then(cb);\n\t\t\t\t});\n\t\n\t\t\t\treturn cb(this.data);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"onceStableTree\",\n\t\t\tvalue: function onceStableTree(cb) {\n\t\t\t\tvar _this15 = this;\n\t\n\t\t\t\tif (this._.unStableChilds) return this.once('stableTree', function (e) {\n\t\t\t\t\treturn _this15.onceStableTree(cb);\n\t\t\t\t});\n\t\t\t\treturn cb(this.data);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Call retain on the scoped stores basing the given list\n\t   *\n\t   * @param stores\n\t   * @param reason\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"retainStores\",\n\t\t\tvalue: function retainStores() {\n\t\t\t\tvar _this16 = this;\n\t\n\t\t\t\tvar stores = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\t\t\tvar reason = arguments[1];\n\t\n\t\t\t\tstores.forEach(function (id) {\n\t\t\t\t\treturn _this16.stores[id] && _this16.stores[id].retain && _this16.stores[id].retain(reason);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Call retain on the scoped stores\n\t   *\n\t   * @param stores\n\t   * @param reason\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"disposeStores\",\n\t\t\tvalue: function disposeStores() {\n\t\t\t\tvar _this17 = this;\n\t\n\t\t\t\tvar stores = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\t\t\tvar reason = arguments[1];\n\t\n\t\t\t\tstores.forEach(function (id) {\n\t\t\t\t\treturn _this17.stores[id] && _this17.stores[id].dispose && _this17.stores[id].dispose(reason);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Keep the scope unstable until release is called\n\t   * @param reason\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"wait\",\n\t\t\tvalue: function wait(reason) {\n\t\t\t\t//console.log(\"wait\", reason);\n\t\t\t\tthis._stable && !this.__locks.all && this.emit(\"unstable\", this);\n\t\t\t\tthis._stable = false;\n\t\t\t\tthis.__locks.all++;\n\t\t\t\tif (reason) {\n\t\t\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\t\t\tthis.__locks[reason]++;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Stabilize the scope if no more locks remain (wait fn)\n\t   * @param reason\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"release\",\n\t\t\tvalue: function release(reason) {\n\t\t\t\tvar _this18 = this;\n\t\n\t\t\t\tif (reason) {\n\t\t\t\t\tif (this.__locks[reason] == 0) console.error(\"Release more than locking !\", reason);\n\t\t\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\t\t\tthis.__locks[reason]--;\n\t\t\t\t}\n\t\t\t\tif (!reason && this.__locks.all == 0) console.error(\"Release more than locking !\");\n\t\n\t\t\t\tthis.__locks.all--;\n\t\t\t\tif (!this.__locks.all) {\n\t\t\t\t\tif (this._.stabilizerTM) return;\n\t\t\t\t\tthis._.stabilizerTM && clearTimeout(this._.stabilizerTM);\n\t\n\t\t\t\t\tthis._.stabilizerTM = setTimeout(function (e) {\n\t\t\t\t\t\t_this18._.stabilizerTM = null;\n\t\t\t\t\t\tif (_this18.__locks.all) return;\n\t\n\t\t\t\t\t\t_this18._.propagTM && clearTimeout(_this18._.propagTM);\n\t\t\t\t\t\t_this18._rev++;\n\t\t\t\t\t\t_this18._stable = true;\n\t\t\t\t\t\t_this18.emit(\"stable\", _this18);\n\t\n\t\t\t\t\t\t!_this18.dead && _this18._propag(); // stability can induce destroy\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Propag stores updates basing theirs last updates\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"propag\",\n\t\t\tvalue: function propag() {\n\t\t\t\tvar _this19 = this;\n\t\n\t\t\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\t\t\tthis._.propagTM = setTimeout(function (e) {\n\t\t\t\t\t_this19._.propagTM = null;\n\t\t\t\t\t_this19._propag();\n\t\t\t\t}, 2);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"_propag\",\n\t\t\tvalue: function _propag() {\n\t\t\t\tvar _this20 = this;\n\t\n\t\t\t\tif (this._.followers.length) this._.followers.forEach(function (_ref4) {\n\t\t\t\t\tvar obj = _ref4[0],\n\t\t\t\t\t    key = _ref4[1],\n\t\t\t\t\t    as = _ref4[2],\n\t\t\t\t\t    lastRevs = _ref4[3],\n\t\t\t\t\t    remaps = _ref4[3];\n\t\n\t\t\t\t\tvar data = _this20.getUpdates(lastRevs);\n\t\t\t\t\tif (!data) return;\n\t\t\t\t\t//console.log(data, lastRevs)\n\t\t\t\t\tif (typeof obj != \"function\") {\n\t\t\t\t\t\t//console.log(\"setState \",obj, Object.keys(data))\n\t\t\t\t\t\tif (as) obj.setState(_defineProperty({}, as, data));else obj.setState(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobj(data, lastRevs && [].concat(_toConsumableArray(lastRevs)) || \"no revs\");\n\t\t\t\t\t}\n\t\t\t\t\t// lastRevs &&\n\t\t\t\t\t// key.forEach(id => (lastRevs[id] = this.stores[id] &&\n\t\t\t\t\t// this.stores[id]._rev || 0));\n\t\t\t\t});\n\t\t\t\tthis.emit(\"update\", this.getUpdates());\n\t\t\t}\n\t\n\t\t\t/**\n\t   * is stable\n\t   * @returns bool\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"isStable\",\n\t\t\tvalue: function isStable() {\n\t\t\t\treturn this._stable;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * is stable tree\n\t   * @returns bool\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"isStableTree\",\n\t\t\tvalue: function isStableTree() {\n\t\t\t\treturn !this._.unStableChilds;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Register children\n\t   * @param scope\n\t   * @private\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"_addChild\",\n\t\t\tvalue: function _addChild(scope) {\n\t\t\t\tvar _this21 = this;\n\t\n\t\t\t\tthis._.childScopes.push(scope);\n\t\t\t\tthis._.seenChilds++;\n\t\t\t\tvar lists = {\n\t\t\t\t\t'stable': function stable(s) {\n\t\t\t\t\t\t_this21._.unStableChilds--;\n\t\t\t\t\t\tif (!_this21._.unStableChilds) _this21.emit(\"stableTree\", _this21);\n\t\t\t\t\t},\n\t\t\t\t\t'unstable': function unstable(s) {\n\t\t\t\t\t\t_this21._.unStableChilds++;\n\t\t\t\t\t\tif (1 == _this21._.unStableChilds) _this21.emit(\"unstableTree\", _this21);\n\t\t\t\t\t},\n\t\t\t\t\t'stableTree': function stableTree(s) {\n\t\t\t\t\t\t_this21._.unStableChilds--;\n\t\t\t\t\t\tif (!_this21._.unStableChilds) _this21.emit(\"stableTree\", _this21);\n\t\t\t\t\t},\n\t\t\t\t\t'unstableTree': function unstableTree(s) {\n\t\t\t\t\t\t_this21._.unStableChilds++;\n\t\t\t\t\t\tif (1 == _this21._.unStableChilds) _this21.emit(\"unstableTree\", _this21);\n\t\t\t\t\t},\n\t\t\t\t\t'destroy': function destroy(ctx) {\n\t\t\t\t\t\tif (ctx._.unStableChilds) _this21._.unStableChilds--;\n\t\t\t\t\t\tif (!ctx.isStable()) _this21._.unStableChilds--;\n\t\n\t\t\t\t\t\tif (!_this21._.unStableChilds) _this21.emit(\"stableTree\", _this21);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t    wasStable = this._.unStableChilds;\n\t\n\t\t\t\t!scope.isStable() && this._.unStableChilds++;\n\t\t\t\tscope._.unStableChilds && this._.unStableChilds++;\n\t\t\t\tthis._.childScopesList.push(lists);\n\t\n\t\t\t\tif (!wasStable && this._.unStableChilds) this.emit(\"unstableTree\", this);\n\t\n\t\t\t\tscope.on(lists);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"_rmChild\",\n\t\t\tvalue: function _rmChild(ctx) {\n\t\t\t\tvar i = this._.childScopes.indexOf(ctx),\n\t\t\t\t    wasStable = this._.unStableChilds;\n\t\t\t\tif (i != -1) {\n\t\t\t\t\tthis._.childScopes.splice(i, 1);\n\t\t\t\t\t!ctx.isStable() && this._.unStableChilds--;\n\t\t\t\t\tctx._.unStableChilds && this._.unStableChilds--;\n\t\t\t\t\tctx.un(this._.childScopesList.splice(i, 1)[0]);\n\t\t\t\t\tif (wasStable && !this._.unStableChilds) this.emit(\"stableTree\");\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"retain\",\n\t\t\tvalue: function retain(reason) {\n\t\t\t\tthis.__retains.all++;\n\t\t\t\t//console.log(\"retain\", this._id, reason);\n\t\t\t\tif (reason) {\n\t\t\t\t\tthis.__retains[reason] = this.__retains[reason] || 0;\n\t\t\t\t\tthis.__retains[reason]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"dispose\",\n\t\t\tvalue: function dispose(reason) {\n\t\t\t\tvar _this22 = this;\n\t\n\t\t\t\t//console.log(\"dispose\", this._id, reason);\n\t\t\t\tif (reason) {\n\t\t\t\t\tif (!this.__retains[reason]) throw new Error(\"Dispose more than retaining : \" + reason);\n\t\t\t\t\tthis.__retains[reason]--;\n\t\t\t\t}\n\t\n\t\t\t\tif (!this.__retains.all) throw new Error(\"Dispose more than retaining !\");\n\t\n\t\t\t\tthis.__retains.all--;\n\t\n\t\t\t\tif (!this.__retains.all) {\n\t\t\t\t\t//console.log(\"dispose do destroy \", this._id, this._persistenceTm);\n\t\t\t\t\tif (this._.persistenceTm) {\n\t\t\t\t\t\tthis._.destroyTM && clearTimeout(this._.destroyTM);\n\t\t\t\t\t\tthis._.destroyTM = setTimeout(function (e) {\n\t\t\t\t\t\t\t_this22.then(function (s) {\n\t\t\t\t\t\t\t\t!_this22.__retains.all && !_this22.dead && _this22.destroy();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, this._.persistenceTm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.then(function (s) {\n\t\t\t\t\t\t\treturn !_this22.__retains.all && !_this22.dead && _this22.destroy();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * order destroy of local stores\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"destroy\",\n\t\t\tvalue: function destroy() {\n\t\t\t\tvar _this23 = this;\n\t\n\t\t\t\tvar ctx = this._._scope;\n\t\t\t\t//console.warn(\"destroy\", this._id);\n\t\t\t\tthis._getAllChilds().map(function (scope) {\n\t\t\t\t\treturn scope.destroy();\n\t\t\t\t});\n\t\t\t\tfor (var key in ctx) {\n\t\t\t\t\tif (!_is2.default.fn(ctx[key])) {\n\t\t\t\t\t\tif (key == \"$parent\") continue;\n\t\t\t\t\t\t!ctx[key]._autoDestroy && ctx[key].dispose(\"scoped\");\n\t\t\t\t\t}\n\t\t\t\t}this._.stabilizerTM && clearTimeout(this._.stabilizerTM);\n\t\t\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\t\t\tObject.keys(this._._listening).forEach(function (id) {\n\t\t\t\t\treturn id !== \"$parent\" && _this23._._scope[id].removeListener(_this23._._listening[id]);\n\t\t\t\t});\n\t\t\t\twhile (this._._mixedList.length) {\n\t\t\t\t\tthis._._mixed[0].removeListener(this._._mixedList.shift());\n\t\t\t\t\tthis._._mixed.shift().dispose(\"mixedTo\");\n\t\t\t\t}\n\t\t\t\t[].concat(_toConsumableArray(this._.followers)).map(function (follower) {\n\t\t\t\t\treturn _this23.unBind.apply(_this23, _toConsumableArray(follower));\n\t\t\t\t});\n\t\t\t\tif (this._._parentList) {\n\t\t\t\t\tthis.parent._rmChild(this);\n\t\t\t\t\tthis.parent.removeListener(this._._parentList);\n\t\t\t\t\tthis.parent.dispose(\"isMyParent\");\n\t\t\t\t\tthis._._parentList = null;\n\t\t\t\t}\n\t\t\t\tthis.dead = true;\n\t\t\t\tdelete allScopes[this._id];\n\t\t\t\tthis.emit(\"destroy\", this);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Scope;\n\t}(_Emitter2.default);\n\t\n\tScope.persistenceTm = 1;\n\tScope.Store = null;\n\t\n\tScope.scopeRef = function scopeRef(path) {\n\t\tthis.path = path;\n\t};\n\t\n\tScope.scopes = allScopes;\n\t\n\t\n\tScope.isScope = function (obj) {\n\t\treturn obj instanceof Scope;\n\t};\n\t\n\tScope.isScopeClass = function (obj) {\n\t\treturn Scope.isPrototypeOf(obj) || obj === Scope;\n\t};\n\texports.default = Scope;\n\tmodule.exports = exports[\"default\"];\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2019. Wise Wild Web\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  @author : Nathanael Braun\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  @contact : n8tz.js@gmail.com\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\tvar _is = __webpack_require__(1);\n\t\n\tvar _is2 = _interopRequireDefault(_is);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Emitter = function () {\n\t\tfunction Emitter() {\n\t\t\t_classCallCheck(this, Emitter);\n\t\n\t\t\tthis._events = {};\n\t\t}\n\t\n\t\t_createClass(Emitter, [{\n\t\t\tkey: 'on',\n\t\t\tvalue: function on(evt, cb) {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tif (!_is2.default.string(evt) && evt) return Object.keys(evt).forEach(function (k) {\n\t\t\t\t\treturn _this.on(k, evt[k]);\n\t\t\t\t});\n\t\n\t\t\t\tthis._events[evt] = this._events[evt] || [];\n\t\t\t\tthis._events[evt].push(cb);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'un',\n\t\t\tvalue: function un(evt, cb) {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\tif (!_is2.default.string(evt) && evt) return Object.keys(evt).forEach(function (k) {\n\t\t\t\t\treturn _this2.un(k, evt[k]);\n\t\t\t\t});\n\t\n\t\t\t\tif (!this._events[evt]) return;\n\t\t\t\tvar i = this._events[evt].indexOf(cb);\n\t\t\t\tthis._events[evt].splice(i, 1);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'emit',\n\t\t\tvalue: function emit(evt) {\n\t\t\t\tif (!this._events[evt]) return;\n\t\t\t\tvar lists = [].concat(_toConsumableArray(this._events[evt]));\n\t\n\t\t\t\tfor (var _len = arguments.length, argz = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\t\targz[_key - 1] = arguments[_key];\n\t\t\t\t}\n\t\n\t\t\t\tfor (var i = 0; i < lists.length; i++) {\n\t\t\t\t\tlists[i].apply(lists, argz);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'addListener',\n\t\t\tvalue: function addListener() {\n\t\t\t\tthis.on.apply(this, arguments);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'removeListener',\n\t\t\tvalue: function removeListener() {\n\t\t\t\tthis.un.apply(this, arguments);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'removeAllListeners',\n\t\t\tvalue: function removeAllListeners() {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'once',\n\t\t\tvalue: function once(evt, cb) {\n\t\t\t\tvar _this3 = this;\n\t\n\t\t\t\tvar _fn = void 0;\n\t\t\t\tthis.on(evt, _fn = function fn() {\n\t\t\t\t\t_this3.un(evt, _fn);\n\t\t\t\t\tcb.apply(undefined, arguments);\n\t\t\t\t});\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Emitter;\n\t}();\n\t\n\texports.default = Emitter;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.walknSet = walknSet;\n\texports.walknGet = walknGet;\n\texports.keyWalknSet = keyWalknSet;\n\texports.keyWalknGet = keyWalknGet;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\t/*\n\t * The MIT License (MIT)\n\t * Copyright (c) 2019. Wise Wild Web\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t *\n\t *  @author : Nathanael Braun\n\t *  @contact : n8tz.js@gmail.com\n\t */\n\t\n\tvar is = __webpack_require__(1);\n\t\n\tfunction walknSet(obj, path, value, stack) {\n\t\tif (is.string(path)) path = path.split('.');\n\t\tif (!path.length) return false;else if (path.length == 1) return obj[path[0]] = stack ? [].concat(_toConsumableArray(obj[path[0]] || []), [value]) : value;else return walknSet(obj[path[0]] = obj[path[0]] || {}, path.slice(1), value, stack);\n\t}\n\t\n\tfunction walknGet(obj, path, isKey) {\n\t\tif (is.string(path)) path = path.split('.');\n\t\treturn path.length ? obj[path[0]] && walknGet(obj[path[0]], path.slice(1)) : obj;\n\t}\n\t\n\t//@todo\n\tfunction keyWalknSet(obj, path, value, stack) {\n\t\tif (is.string(path)) path = path.split(/(\\>|\\/)/ig).filter(function (v) {\n\t\t\treturn v !== '>' && v;\n\t\t});\n\t\treturn walknSet(obj, path, value);\n\t}\n\t\n\tfunction keyWalknGet(obj, path, isKey) {\n\t\tif (is.string(path)) path = path.split(/(\\>|\\/)/ig).filter(function (v) {\n\t\t\treturn v !== '>' && v;\n\t\t});\n\t\treturn path.length ? obj[path[0]] && walknGet(obj[path[0]], path.slice(1)) : obj;\n\t}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tmodule.exports = __webpack_require__(13);\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar randomByte = __webpack_require__(15);\n\t\n\tfunction encode(lookup, number) {\n\t    var loopCounter = 0;\n\t    var done;\n\t\n\t    var str = '';\n\t\n\t    while (!done) {\n\t        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );\n\t        done = number < (Math.pow(16, loopCounter + 1 ) );\n\t        loopCounter++;\n\t    }\n\t    return str;\n\t}\n\t\n\tmodule.exports = encode;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/*\n\t * The MIT License (MIT)\n\t * Copyright (c) 2019. Wise Wild Web\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t *\n\t *  @author : Nathanael Braun\n\t *  @contact : n8tz.js@gmail.com\n\t */\n\t\n\tvar is = __webpack_require__(1),\n\t    Scope = __webpack_require__(3),\n\t    _require = __webpack_require__(5),\n\t    keyWalknSet = _require.keyWalknSet,\n\t    keyWalknGet = _require.keyWalknGet,\n\t    EventEmitter = __webpack_require__(4),\n\t    TaskSequencer = __webpack_require__(9),\n\t    shortid = __webpack_require__(6),\n\t    objProto = Object.getPrototypeOf({});\n\t\n\tvar Store = function (_EventEmitter) {\n\t\t_inherits(Store, _EventEmitter);\n\t\n\t\t/**\n\t  * Constructor, will build a rescope store\n\t  *\n\t  * (scope, {require,use,apply,state, data})\n\t  * (scope)\n\t  *\n\t  * @param scope {object} scope where to find the other stores (default : static\n\t  *     staticScope )\n\t  * @param keys {Array} (passed to Store::map) Ex : [\"session\", \"otherNamedStore:key\",\n\t  *     otherStore.as(\"otherKey\")]\n\t  */\n\t\t// overridable list of store that will allow push if updated\n\t\tfunction Store() {\n\t\t\tvar _this$_require, _this$_require2;\n\t\n\t\t\t_classCallCheck(this, Store);\n\t\n\t\t\tvar _this = _possibleConstructorReturn(this, (Store.__proto__ || Object.getPrototypeOf(Store)).call(this));\n\t\n\t\t\tvar argz = [].concat(Array.prototype.slice.call(arguments)),\n\t\t\t    _static = _this.constructor,\n\t\t\t    scope = argz[0] instanceof Scope ? argz.shift() : _static.scope ? Scope.getScope(_static.scope) : is.string(argz[0]) ? Scope.getScope(argz.shift()) : _static.staticScope,\n\t\t\t    cfg = argz[0] && !is.array(argz[0]) && !is.string(argz[0]) ? argz.shift() : {},\n\t\t\t    taskQueue = is.array(argz[0]) ? argz.shift() : null,\n\t\t\t    name = cfg.name || _static.name,\n\t\t\t    watchs = cfg.use || [],\n\t\t\t    apply = cfg.apply || null,\n\t\t\t    initialState = _static.state || _static.initialState || _static.defaultState;\n\t\n\t\t\t_this._uid = cfg._uid || shortid.generate();\n\t\n\t\t\t_this.__retains = { all: 0 };\n\t\t\t_this.__locks = { all: 0 };\n\t\t\t_this._onStabilize = [];\n\t\n\t\t\t// autoDestroyTm\n\t\t\t_this._autoDestroy = !!_this._persistenceTm;\n\t\t\t_this._persistenceTm = cfg.persistenceTm || _static.persistenceTm || (cfg.autoDestroy || _static.autoDestroy) && 5;\n\t\t\t_this._cfg = cfg;\n\t\n\t\t\tif (cfg && cfg.on) {\n\t\t\t\t_this.on(cfg.on);\n\t\t\t}\n\t\n\t\t\t_this.name = name;\n\t\n\t\t\tif (scope.stores) {\n\t\t\t\t_this.scopeObj = scope;\n\t\t\t\t_this.scope = scope.stores;\n\t\t\t} else {\n\t\t\t\t_this.scopeObj = new Scope(scope);\n\t\t\t\t_this.scope = scope.stores;\n\t\t\t}\n\t\n\t\t\t// standardized scope access\n\t\t\t_this.$scope = _this.scopeObj;\n\t\t\t_this.$stores = _this.scopeObj.stores;\n\t\t\t_this.$actions = _this.scopeObj.actions;\n\t\t\t_this.$dispatch = _this.scopeObj.dispatch.bind(_this.scopeObj);\n\t\n\t\t\t_this._rev = _this.constructor._rev || 0;\n\t\t\t_this._revs = {};\n\t\t\t_this.stores = {};\n\t\t\t_this._require = [];\n\t\t\t_this._sources = [name];\n\t\n\t\t\t// register source stores\n\t\t\tif (is.array(_static.use)) {\n\t\t\t\t_this._use = [].concat(_toConsumableArray(watchs), _toConsumableArray((_static.use || []).map(function (key) {\n\t\t\t\t\tvar ref = key.match(/^(\\!?)([^\\:]*)(?:\\:(.*))?$/);\n\t\t\t\t\tif (ref[1]) {\n\t\t\t\t\t\tvar ref2 = ref[2].split('.');\n\t\t\t\t\t\t_this._require.push(ref[3] || ref2[ref2.length - 1]); // require check value of the aliased\n\t\t\t\t\t\t// imported value\n\t\t\t\t\t\treturn key.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\treturn key;\n\t\t\t\t})));\n\t\t\t} else {\n\t\t\t\t_this._use = [].concat(_toConsumableArray(watchs), _toConsumableArray(_static.use ? Object.keys(_static.use).map(function (key) {\n\t\t\t\t\tvar ref = key.match(/^(\\!?)(.*)$/);\n\t\t\t\t\tref[1] && _this._require.push(_static.use[key]);\n\t\t\t\t\treturn ref[2] + (_static.use[key] === true ? '' : ':' + _static.use[key]);\n\t\t\t\t}) : []));\n\t\t\t}\n\t\n\t\t\tif (_static.require) (_this$_require = _this._require).push.apply(_this$_require, _toConsumableArray(_static.require));\n\t\t\tif (cfg.require) (_this$_require2 = _this._require).push.apply(_this$_require2, _toConsumableArray(cfg.require));\n\t\n\t\t\t_this._followers = [];\n\t\t\t_this._changesSW = initialState || {};\n\t\t\t_this.state = initialState && {};\n\t\n\t\t\tif (apply) _this.apply = apply;\n\t\n\t\t\t/**\n\t   * Initial state isn't fully initialized ( childs constructors can set it )\n\t   * Scope based instance have taskQueue to delay init synchronously, if not\n\t   * present we use setTimeout\n\t   */\n\t\t\tif (taskQueue) {\n\t\t\t\ttaskQueue.push(_this._afterConstructor.bind(_this));\n\t\t\t} else setTimeout(_this._afterConstructor.bind(_this));\n\t\t\treturn _this;\n\t\t}\n\t\n\t\t/**\n\t  * Get the incoming state ( for immediate state relative actions )\n\t  * @returns {{}|*}\n\t  */\n\t\t// default state\n\t\t/**\n\t  * if retain goes to 0 :\n\t  * false to not destroy,\n\t  * 0 to sync auto destroy\n\t  * Ms to autodestroy after tm ms if no retain has been called\n\t  * @type {boolean|Int}\n\t  */\n\t\n\t\t//static use                  = [];// overridable list of source stores\n\t\n\t\n\t\t_createClass(Store, [{\n\t\t\tkey: '_afterConstructor',\n\t\t\tvalue: function _afterConstructor() {\n\t\t\t\tvar cfg = this._cfg,\n\t\t\t\t    _static = this.constructor,\n\t\t\t\t    snapshot = this.restore(undefined, true),\n\t\t\t\t    initialState = this.state,\n\t\t\t\t    initialData = this.data,\n\t\t\t\t    applied = void 0;\n\t\t\t\t{\n\t\n\t\t\t\t\tif (initialData) this.data = initialData;else if (_static.data !== undefined) this.data = _extends({}, _static.data);else if (cfg.hasOwnProperty(\"data\")) this.data = cfg.data;\n\t\n\t\t\t\t\tif (cfg.hasOwnProperty(\"state\") && cfg.state !== undefined) initialState = _extends({}, initialState, cfg.state);\n\t\n\t\t\t\t\tif (this.data === undefined) {\n\t\t\t\t\t\tif (initialState || this._use.length) {\n\t\t\t\t\t\t\t// sync apply\n\t\t\t\t\t\t\tthis._changesSW = _extends({}, this._changesSW, initialState || {}, this.$scope.map(this, this._use));\n\t\t\t\t\t\t\tthis.state = {};\n\t\t\t\t\t\t\tif (this.shouldApply(this._changesSW) && this.data === undefined) {\n\t\t\t\t\t\t\t\tthis.data = this.apply(this.data, this._changesSW, this._changesSW);\n\t\t\t\t\t\t\t\tapplied = true;\n\t\t\t\t\t\t\t\tthis.state = this._changesSW;\n\t\t\t\t\t\t\t\tthis._changesSW = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tapplied = true;\n\t\t\t\t\t\tthis.state = _extends({}, this._changesSW, initialState || {}, this.$scope.map(this, this._use));\n\t\t\t\t\t\tthis._changesSW = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((this.data !== undefined || applied) && !this.__locks.all) {\n\t\t\t\t\tthis._stable = true;\n\t\t\t\t\tthis._rev++;\n\t\t\t\t} else {\n\t\t\t\t\tthis._stable = false;\n\t\t\t\t\tif (!_static.managed && !this.state && (!this._use || !this._use.length)) {\n\t\t\t\t\t\tconsole.warn(\"ReScope store '\", this.name, \"' have no initial data, state or use. It can't stabilize...\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t!this._stable && this.emit('unstable', this.state);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Overridable method to know if a data change should be propag to the listening\n\t   * stores & components\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'shouldPropag',\n\t\t\tvalue: function shouldPropag(nDatas) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Overridable method to choose if this store should be serialized,\n\t   * If not it will be applied normally when restoring\n\t   * @returns {boolean}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'shouldSerialize',\n\t\t\tvalue: function shouldSerialize() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'hasDataChange',\n\t\t\tvalue: function hasDataChange(nDatas) {\n\t\t\t\tvar _static = this.constructor,\n\t\t\t\t    r = void 0,\n\t\t\t\t    cDatas = this.data;\n\t\t\t\tr = !cDatas && nDatas || cDatas !== nDatas;\n\t\t\t\t!r && cDatas && Object.keys(cDatas).forEach(function (key) {\n\t\t\t\t\tr = r || (nDatas ? cDatas[key] !== nDatas[key] : cDatas && cDatas[key]);\n\t\t\t\t});\n\t\t\t\t!r && nDatas && Object.keys(nDatas).forEach(function (key) {\n\t\t\t\t\tr = r || (nDatas ? cDatas[key] !== nDatas[key] : cDatas && cDatas[key]);\n\t\t\t\t});\n\t\t\t\treturn r;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Overridable method to know if a state change should be applied\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'shouldApply',\n\t\t\tvalue: function shouldApply() {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\tvar state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state;\n\t\n\t\t\t\tvar _static = this.constructor;\n\t\n\t\t\t\treturn !!this.isComplete(state) && (is.array(_static.follow) ? _static.follow.reduce(function (r, i) {\n\t\t\t\t\treturn r || state && state[i];\n\t\t\t\t}, false) : _static.follow ? Object.keys(_static.follow).reduce(function (r, i) {\n\t\t\t\t\treturn r || state && is.fn(_static.follow[i]) && _static.follow[i].call(_this2, state[i]) || _static.follow[i] && state[i] !== _this2.state[i];\n\t\t\t\t}, false) : true);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Overridable applier / remapper\n\t   * If state or lastPublicState are simple hash maps apply will return {...data,\n\t   * ...state} if not it will return the last private state\n\t   * @param data\n\t   * @param state\n\t   * @returns {*}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'apply',\n\t\t\tvalue: function apply(data, state, changes) {\n\t\t\t\tstate = state || this.state;\n\t\n\t\t\t\tif (!data || data.__proto__ !== objProto || state.__proto__ !== objProto) return state;else return _extends({}, data, state);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Debounce this store propagation ( & reducing )\n\t   * @param cb\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'stabilize',\n\t\t\tvalue: function stabilize(cb) {\n\t\t\t\tcb && this.once('stable', cb);\n\t\t\t\tthis._stable && this.emit('unstable', this.state, this.data);\n\t\n\t\t\t\tthis._stable = false;\n\t\n\t\t\t\tif (this._stabilizer) return;\n\t\n\t\t\t\tthis._stabilizer = TaskSequencer.pushTask(this, 'pushState');\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Walk n get\n\t   * @param path\n\t   * @param i\n\t   * @param obj\n\t   * @returns {*|{}}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'retrieve',\n\t\t\tvalue: function retrieve(path) {\n\t\t\t\tvar i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\t\t\tvar obj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.data;\n\t\n\t\t\t\tpath = is.string(path) ? path.split('.') : path;\n\t\t\t\treturn !obj || !path || !path.length ? obj : path.length == i + 1 ? obj[path[i]] : this.retrieve(path, i + 1, obj[path[i]]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'dispatch',\n\t\t\tvalue: function dispatch(action) {\n\t\t\t\tvar _scopeObj;\n\t\n\t\t\t\tfor (var _len = arguments.length, argz = Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n\t\t\t\t\targz[_key2 - 1] = arguments[_key2];\n\t\t\t\t}\n\t\n\t\t\t\t(_scopeObj = this.scopeObj).dispatch.apply(_scopeObj, [action].concat(argz));\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'trigger',\n\t\t\tvalue: function trigger(action) {\n\t\t\t\tvar actions = this.constructor.actions;\n\t\n\t\t\t\tif (actions && actions[action]) {\n\t\t\t\t\tvar _actions$action;\n\t\n\t\t\t\t\tfor (var _len2 = arguments.length, argz = Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {\n\t\t\t\t\t\targz[_key3 - 1] = arguments[_key3];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar ns = (_actions$action = actions[action]).call.apply(_actions$action, [this].concat(argz));\n\t\t\t\t\tns && this.setState(ns);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Set & Push the result data to followers if stable\n\t   * @param cb\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'push',\n\t\t\tvalue: function push(data, force, cb) {\n\t\t\t\tcb = force === true ? cb : force;\n\t\t\t\tforce = force === true;\n\t\t\t\tif (!force && !this.hasDataChange(data)) {\n\t\t\t\t\tcb && cb();\n\t\t\t\t\tif (!this.__locks.all) {\n\t\t\t\t\t\tvar stable = this._stable;\n\t\t\t\t\t\tthis._stable = true;\n\t\t\t\t\t\t!stable && this.emit('stable', this.state, this.data);\n\t\t\t\t\t\tthis._stabilizer = null;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\tthis.data = data;\n\t\t\t\tthis.wait();\n\t\t\t\tthis.release(cb);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Call the apply fn using the current accumulated state update then, push the\n\t   * resulting data if stable\n\t   * @param force\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'pushState',\n\t\t\tvalue: function pushState(force) {\n\t\n\t\t\t\tif (!force && !this._changesSW && this.data) return;\n\t\n\t\t\t\tvar nextState = this._nextState || _extends({}, this.state, this._changesSW || {}),\n\t\t\t\t    nextData = this.apply(this.data, nextState, this._changesSW);\n\t\n\t\t\t\tthis._stabilizer = null;\n\t\t\t\tthis.state = nextState;\n\t\t\t\tthis._changesSW = null;\n\t\n\t\t\t\tif (!force && !this.hasDataChange(nextData)) {\n\t\t\t\t\tif (!this.__locks.all) {\n\t\t\t\t\t\tvar stable = this._stable;\n\t\t\t\t\t\tthis._stable = true;\n\t\t\t\t\t\t!stable && this.emit('stable', this.state, this.data);\n\t\t\t\t\t\tthis._stabilizer = null;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\tthis.data = nextData;\n\t\t\t\tthis.wait();\n\t\t\t\tthis.release();\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Add 'pState' to the current accumulated state updates\n\t   * & wait source stores stabilization before pushing these state updates\n\t   * @param pState\n\t   * @param cb\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'setState',\n\t\t\tvalue: function setState(pState, cb, sync) {\n\t\t\t\tvar i = 0,\n\t\t\t\t    change = void 0,\n\t\t\t\t    changes = this._changesSW = this._changesSW || {};\n\t\t\t\tfor (var k in pState) {\n\t\t\t\t\tif (!this.state || changes.hasOwnProperty(k) // todo\n\t\t\t\t\t&& pState[k] !== changes[k] || pState.hasOwnProperty(k) && pState[k] !== this.state[k]\n\t\t\t\t\t//||\n\t\t\t\t\t//(this.state[k] && pState[k] && (pState[k]._rev != this._revs[k]))// rev/hash update\n\t\t\t\t\t) {\n\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t//this._revs[k] = pState[k] && pState[k]._rev || true;\n\t\t\t\t\t\tchanges[k] = pState[k];\n\t\t\t\t\t}\n\t\t\t\t}this._nextState = _extends({}, this.state, changes);\n\t\t\t\tif (!this.shouldApply(this._nextState)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif (sync) {\n\t\t\t\t\tthis.pushState();\n\t\t\t\t\tcb && cb();\n\t\t\t\t} else {\n\t\t\t\t\tif (change) {\n\t\t\t\t\t\tthis.stabilize(cb);\n\t\t\t\t\t} else cb && cb();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Update the current state & push it\n\t   * @param pState\n\t   * @param cb\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'setStateSync',\n\t\t\tvalue: function setStateSync(pState) {\n\t\t\t\tvar i = 0,\n\t\t\t\t    change = void 0,\n\t\t\t\t    changes = this._changesSW = this._changesSW || {};\n\t\t\t\tfor (var k in pState) {\n\t\t\t\t\tif (!this.state || pState.hasOwnProperty(k) && pState[k] !== this.state[k]\n\t\t\t\t\t//||\n\t\t\t\t\t//(this.state[k] && pState[k] && (pState[k]._rev != this._revs[k]))// rev/hash update\n\t\t\t\t\t) {\n\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tthis._revs[k] = pState[k] && pState[k]._rev || true;\n\t\t\t\t\t\tchanges[k] = pState[k];\n\t\t\t\t\t}\n\t\t\t\t}this.shouldApply(_extends({}, this.state || {}, changes)) && this.pushState();\n\t\t\t\treturn this.data;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * get a store-key pair for Store::map\n\t   * @param {string} name\n\t   * @returns {{store: Store, name: *}}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'as',\n\t\t\tvalue: function as(name) {\n\t\t\t\treturn { store: this, name: name };\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'on',\n\t\t\tvalue: function on(lists) {\n\t\t\t\tvar _this3 = this;\n\t\n\t\t\t\tif (!is.string(lists) && lists) Object.keys(lists).forEach(function (k) {\n\t\t\t\t\treturn _get(Store.prototype.__proto__ || Object.getPrototypeOf(Store.prototype), 'on', _this3).call(_this3, k, lists[k]);\n\t\t\t\t});else _get(Store.prototype.__proto__ || Object.getPrototypeOf(Store.prototype), 'on', this).apply(this, arguments);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'removeListener',\n\t\t\tvalue: function removeListener(lists) {\n\t\t\t\tvar _this4 = this;\n\t\n\t\t\t\tif (!is.string(lists) && lists) Object.keys(lists).forEach(function (k) {\n\t\t\t\t\treturn _get(Store.prototype.__proto__ || Object.getPrototypeOf(Store.prototype), 'removeListener', _this4).call(_this4, k, lists[k]);\n\t\t\t\t});else _get(Store.prototype.__proto__ || Object.getPrototypeOf(Store.prototype), 'removeListener', this).apply(this, arguments);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * is complete (all requiered keys are here)\n\t   * @returns bool\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'isComplete',\n\t\t\tvalue: function isComplete() {\n\t\t\t\tvar state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state;\n\t\n\t\t\t\treturn !this._require || !this._require.length || state && this._require.reduce(function (r, key) {\n\t\t\t\t\treturn r && state[key];\n\t\t\t\t}, true);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * is stable\n\t   * @returns bool\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'isStable',\n\t\t\tvalue: function isStable() {\n\t\t\t\treturn this._stable;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Serialize state & data with sources refs\n\t   * @returns bool\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'serialize',\n\t\t\tvalue: function serialize() {\n\t\t\t\tvar _this5 = this;\n\t\n\t\t\t\tvar cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\t\t\tvar output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t\n\t\t\t\tvar sId = cfg.parentAlias || this.scopeObj._id,\n\t\t\t\t    refsCount = 0,\n\t\t\t\t    refs = !cfg.norefs && is.array(this._use) && this._use.reduce(function (map, key) {\n\t\t\t\t\tvar ref = _this5.$scope.parseRef(key),\n\t\t\t\t\t    store = _this5.$stores[ref.storeId];\n\t\t\t\t\tif (store && Store.isStore(store) && !store.scopeObj._.isLocalId) refsCount++, map[ref.alias] = ref.path;\n\t\n\t\t\t\t\treturn map;\n\t\t\t\t}, {}),\n\t\t\t\t    state = this.state || {},\n\t\t\t\t    persistent = this.shouldSerialize();\n\t\n\t\t\t\tif (!persistent) {\n\t\t\t\t\tkeyWalknSet(output, sId + '/' + this.name, {\n\t\t\t\t\t\tdataRefs: cfg.dataRefs,\n\t\t\t\t\t\trefs: refs\n\t\t\t\t\t});\n\t\t\t\t\treturn output;\n\t\t\t\t}\n\t\n\t\t\t\tvar stateKeys = Object.keys(state) || [],\n\t\t\t\t    stateRefs = stateKeys.map(function (k) {\n\t\t\t\t\treturn state[k];\n\t\t\t\t}),\n\t\t\t\t    inRefsCount = 0,\n\t\t\t\t    dataRefs = cfg.dataRefs || {},\n\t\t\t\t    inRefs = !cfg.norefs && this.data && Object.keys(this.data).reduce(function (map, key) {\n\t\t\t\t\tvar ref = stateRefs.indexOf(_this5.data[key]);\n\t\t\t\t\tif (ref != -1) inRefsCount++, map[key] = stateKeys[ref];\n\t\t\t\t\treturn map;\n\t\t\t\t}, {}),\n\t\t\t\t    snap = {\n\t\t\t\t\tdataRefs: cfg.dataRefs,\n\t\t\t\t\tstate: state && (cfg.norefs ? _extends({}, state) : Object.keys(state).reduce(function (h, k) {\n\t\t\t\t\t\treturn !refs[k] && (h[k] = state[k]), h;\n\t\t\t\t\t}, {})),\n\t\t\t\t\tdata: (this.data && this.data.__proto__ === objProto ? Object.keys(this.data).reduce(function (h, k) {\n\t\t\t\t\t\tif (!inRefs[k] && !dataRefs[k]) {\n\t\t\t\t\t\t\th[k] = _this5.data[k];\n\t\t\t\t\t\t\tinRefsCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn h;\n\t\t\t\t\t}, {}) : (is.bool(this.data) || is.number(this.data) || is.string(this.data)) && this.data) || undefined\n\t\n\t\t\t\t};\n\t\n\t\t\t\trefs && refsCount && (snap.refs = refs);\n\t\t\t\tinRefs && inRefsCount && (snap.inRefs = inRefs);\n\t\n\t\t\t\tkeyWalknSet(output, sId + '/' + this.name, snap);\n\t\t\t\treturn output;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * restore state & data\n\t   * @returns bool\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'restore',\n\t\t\tvalue: function (_restore) {\n\t\t\t\tfunction restore(_x, _x2) {\n\t\t\t\t\treturn _restore.apply(this, arguments);\n\t\t\t\t}\n\t\n\t\t\t\trestore.toString = function () {\n\t\t\t\t\treturn _restore.toString();\n\t\t\t\t};\n\t\n\t\t\t\treturn restore;\n\t\t\t}(function (snapshot, immediate) {\n\t\t\t\tvar _this6 = this;\n\t\n\t\t\t\tsnapshot = snapshot && keyWalknGet(snapshot, this.scopeObj._id + '/' + this.name) || this.$scope.takeSnapshotByKey(this.scopeObj._id + '/' + this.name);\n\t\n\t\t\t\tif (!snapshot) return;\n\t\n\t\t\t\tif (snapshot) {\n\t\n\t\t\t\t\tif (!this.isStable() && !immediate) this.then(function () {\n\t\t\t\t\t\treturn restore(snapshot);\n\t\t\t\t\t});\n\t\n\t\t\t\t\tthis.state = _extends({}, snapshot.state);\n\t\t\t\t\tsnapshot.refs && Object.keys(snapshot.refs).forEach(function (key) {\n\t\t\t\t\t\t//todo\n\t\t\t\t\t\t_this6.state[key] = _this6.$scope.retrieve(snapshot.refs[key]);\n\t\t\t\t\t});\n\t\n\t\t\t\t\tif (snapshot.inRefs === true) {\n\t\t\t\t\t\tthis.data = _extends({}, this.state);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.data = snapshot.data;\n\t\t\t\t\t\tsnapshot.inRefs && Object.keys(snapshot.inRefs).forEach(function (key) {\n\t\t\t\t\t\t\t//todo\n\t\t\t\t\t\t\t_this6.data[key] = _this6.state[snapshot.inRefs[key]];\n\t\t\t\t\t\t\t//else\n\t\t\t\t\t\t\t//    console.warn('not found : ', key, snap && snap.refs[ key ])\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (snapshot.dataRefs) {\n\t\t\t\t\t\tthis.data = this.data || {};\n\t\t\t\t\t\tObject.keys(snapshot.dataRefs).forEach(function (key) {\n\t\t\t\t\t\t\t//todo\n\t\t\t\t\t\t\t_this6.$scope.restoreRefPath(snapshot.dataRefs[key]);\n\t\t\t\t\t\t\t_this6.data[key] = _this6.$scope.retrieve(snapshot.dataRefs[key]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\n\t\t\t/**\n\t   * Bind this store changes to the given component-key\n\t   * @param obj {React.Component|Store|function)\n\t   * @param key {string} optional key where to map the public state\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'bind',\n\t\t\tvalue: function bind(obj, key) {\n\t\t\t\tvar setInitial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\t\t\tvar path = arguments[3];\n\t\n\t\t\t\tthis._followers.push([obj, key, path]);\n\t\t\t\tif (setInitial && this.data && this._stable) {\n\t\t\t\t\tvar data = path ? this.retrieve(path) : this.data;\n\t\t\t\t\tif (typeof obj != \"function\") {\n\t\t\t\t\t\tif (key) obj.setState(_defineProperty({}, key, data));else obj.setState(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobj(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Un bind this store off the given component-key\n\t   * @param obj\n\t   * @param key\n\t   * @returns {Array.<*>}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'unBind',\n\t\t\tvalue: function unBind(obj, key, path) {\n\t\t\t\tvar followers = this._followers,\n\t\t\t\t    i = followers && followers.length;\n\t\t\t\twhile (followers && i--) {\n\t\t\t\t\tif (followers[i][0] === obj && followers[i][1] === key && followers[i][2] === path) return followers.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * once('stable', cb)\n\t   * @param obj {React.Component|Store|function)\n\t   * @param key {string} optional key where to map the public state\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'then',\n\t\t\tvalue: function then(cb) {\n\t\t\t\tvar _this7 = this;\n\t\n\t\t\t\tif (this._stable) return cb(this.data);\n\t\t\t\tthis.once('stable', function (e) {\n\t\t\t\t\treturn cb(_this7.data);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Add a lock so the store will not propag it data untill release() is call\n\t   * @param previous {Store|number|Array} @optional wf to wait, releases to wait or\n\t   *     array of stuff to wait\n\t   * @returns {this}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'wait',\n\t\t\tvalue: function wait(previous) {\n\t\t\t\tif (typeof previous == \"number\") return this.__locks.all += previous;\n\t\t\t\tif (is.array(previous)) return previous.map(this.wait.bind(this));\n\t\n\t\t\t\tthis._stable && this.emit('unstable', this.state, this.data);\n\t\t\t\tthis._stable = false;\n\t\t\t\tthis.__locks.all++;\n\t\n\t\t\t\tvar reason = is.string(previous) ? previous : null;\n\t\t\t\tif (reason) {\n\t\t\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\t\t\tthis.__locks[reason]++;\n\t\t\t\t}\n\t\t\t\tif (previous && is.fn(previous.then)) {\n\t\t\t\t\tprevious.then(this.release.bind(this, null));\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Decrease locks for this store, if it reach 0 ,\n\t   * it will be propagated to the followers,\n\t   * then, all stuff passed to \"then\" call back will be exec / released\n\t   * @param desync\n\t   * @returns {*}\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'release',\n\t\t\tvalue: function release(reason, cb) {\n\t\t\t\tvar _static = this.constructor,\n\t\t\t\t    me = this;\n\t\t\t\tvar i = 0,\n\t\t\t\t    wasStable = this._stable;\n\t\n\t\t\t\tif (is.fn(reason)) {\n\t\t\t\t\tcb = reason;\n\t\t\t\t\treason = null;\n\t\t\t\t}\n\t\n\t\t\t\tif (reason) {\n\t\t\t\t\tif (this.__locks[reason] == 0) console.error(\"Release more than locking !\", reason);\n\t\t\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\t\t\tthis.__locks[reason]--;\n\t\t\t\t}\n\t\n\t\t\t\tif (!reason && this.__locks.all == 0) console.error(\"Release more than locking !\");\n\t\n\t\t\t\tif (! --this.__locks.all && this.isComplete()) {\n\t\t\t\t\tvar propag = this.shouldPropag(this.data);\n\t\t\t\t\tthis._stable = true;\n\t\t\t\t\tpropag && this._rev++; //\n\t\t\t\t\tif (propag && this._followers.length) this._followers.forEach(function propag(follower) {\n\t\t\t\t\t\tvar data = follower[2] ? me.retrieve(follower[2]) : me.data;\n\t\t\t\t\t\t//if ( !data ) return;\n\t\n\t\t\t\t\t\tif (typeof follower[0] == \"function\") {\n\t\t\t\t\t\t\tfollower[0](data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//cb && i++;\n\t\t\t\t\t\t\tfollower[0].setState(follower[1] ? _defineProperty({}, follower[1], data) : data\n\t\t\t\t\t\t\t//,\n\t\t\t\t\t\t\t//cb && (\n\t\t\t\t\t\t\t//    () => (!(--i) && cb())\n\t\t\t\t\t\t\t//)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t//else\n\t\t\t\t\t!wasStable && this.emit('stable', this.data);\n\t\t\t\t\tpropag && this.emit('update', this.data);\n\t\t\t\t\tcb && cb();\n\t\t\t\t} else cb && this.then(cb);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'propag',\n\t\t\tvalue: function propag(data) {\n\t\t\t\tthis.emit('update', data);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'retain',\n\t\t\tvalue: function retain(reason) {\n\t\t\t\tthis.__retains.all++;\n\t\t\t\tif (reason) {\n\t\t\t\t\tthis.__retains[reason] = this.__retains[reason] || 0;\n\t\t\t\t\tthis.__retains[reason]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'dispose',\n\t\t\tvalue: function dispose(reason) {\n\t\t\t\tvar _this8 = this;\n\t\n\t\t\t\t//console.warn(\"dispose\", reason, this.__retains);\n\t\t\t\tif (reason) {\n\t\t\t\t\tif (!this.__retains[reason]) throw new Error(\"RS : Dispose more than retaining on store '\" + this.name + \"' : \" + reason);\n\t\n\t\t\t\t\tthis.__retains[reason]--;\n\t\t\t\t}\n\t\t\t\tif (this.__retains.all == 0) throw new Error(\"RS : Dispose more than retaining on store \" + this.name);\n\t\n\t\t\t\tthis.__retains.all--;\n\t\n\t\t\t\tif (!this.__retains.all) {\n\t\t\t\t\tif (this._persistenceTm) {\n\t\t\t\t\t\tthis._destroyTM && clearTimeout(this._destroyTM);\n\t\t\t\t\t\tthis._destroyTM = setTimeout(function (e) {\n\t\t\t\t\t\t\t_this8._destroyTM = null;\n\t\t\t\t\t\t\t//this.then(s => {\n\t\t\t\t\t\t\t!_this8.__retains.all && !_this8.dead && _this8.destroy();\n\t\t\t\t\t\t\t//});\n\t\t\t\t\t\t}, this._persistenceTm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//this.then(s =>\n\t\t\t\t\t\t!this.__retains.all && !this.dead && this.destroy();\n\t\t\t\t\t\t//);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'destroy',\n\t\t\tvalue: function destroy() {\n\t\t\t\t//  console.log(\"destroy\", this._uid);\n\t\n\t\t\t\tthis.emit('destroy', this);\n\t\t\t\tif (this._stabilizer) clearTimeout(this._stabilizer);\n\t\n\t\t\t\tif (this._followers.length) this._followers.forEach(function (follower) {\n\t\t\t\t\tif (typeof follower[0] !== \"function\") {\n\t\t\t\t\t\tif (follower[0].stores) delete follower[0].stores[follower[1]];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis._followers.length = 0;\n\t\t\t\tthis.constructor._rev = this.rev;\n\t\t\t\tthis.dead = true;\n\t\t\t\tthis._revs = this.data = this.state = this.scope = null;\n\t\t\t\tthis.removeAllListeners();\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'nextState',\n\t\t\tget: function get() {\n\t\t\t\treturn this._changesSW && _extends({}, this.state, this._changesSW) || this.state;\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Store;\n\t}(EventEmitter);\n\t\n\t/**\n\t * get a static aliased reference of a store\n\t * @param {string} name\n\t * @returns {{store: Store, name: *}}\n\t */\n\t\n\t\n\tStore.staticScope = new Scope({}, { id: \"static\" });\n\tStore.state = undefined;\n\tStore.persistenceTm = false;\n\tStore.as = function (name) {\n\t\treturn { store: this, name: name };\n\t};\n\t\n\t/**\n\t * @todo\n\t * Map all named stores in {keys} to the {object}'s state\n\t * Hook componentWillUnmount (for react comp) or destroy to unBind them automatically\n\t * @static\n\t * @param object {Object} target state aware object (React.Component|Store|...)\n\t * @param keys {Array} Ex : [\"session\", \"otherStaticNamedStore:key\",\n\t *     store.as('anotherKey')]\n\t */\n\tStore.map = function (cStore, keys, scope, origin) {\n\t\tvar setInitial = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\t\n\t\tvar targetRevs = cStore._revs || {};\n\t\tvar targetScope = cStore.stores || (cStore.stores = {});\n\t\tvar initialOutputs = {};\n\t\tkeys = is.array(keys) ? [].concat(_toConsumableArray(keys)) : [keys];\n\t\n\t\tscope = scope || Store.staticScope;\n\t\n\t\tkeys = keys.filter(\n\t\t// @todo : use query refs\n\t\t// (store)(\\.store)*(\\[(\\*|(props)\\w+)+)\\])?(\\:alias)\n\t\tfunction (key) {\n\t\t\tvar _cStore$_sources;\n\t\n\t\t\tif (!key) {\n\t\t\t\tconsole.error(\"Not a mappable store item '\" + key + \"' in \" + origin + ' !!');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar name = void 0,\n\t\t\t    alias = void 0,\n\t\t\t    path = void 0,\n\t\t\t    store = void 0,\n\t\t\t    _key = void 0;\n\t\t\tif (key.store && key.name) {\n\t\t\t\talias = name = key.name;\n\t\t\t\tstore = key.store;\n\t\t\t} else if (is.fn(key)) {\n\t\t\t\tname = alias = key.name || key.defaultName;\n\t\t\t\tstore = key;\n\t\t\t} else {\n\t\t\t\t_key = key.match(/([^\\.\\:]+)((?:\\.[^\\.\\:]+)*)(?:\\:([^\\.\\:]+))?/);\n\t\t\t\tname = _key[1];\n\t\t\t\tpath = _key[2] && _key[2].substr(1);\n\t\t\t\tstore = scope.stores[_key[1]];\n\t\t\t\talias = _key[3] || path && path.match(/([^\\.]*)$/)[0] || _key[1];\n\t\t\t}\n\t\t\tif (!store) {\n\t\t\t\tvar i = [];\n\t\t\t\tfor (var o in scope.stores) {\n\t\t\t\t\ti.push(o);\n\t\t\t\t}console.error(\"Not a mappable store item '\" + name + \"/\" + alias + \"' in \" + (cStore.name || cStore) + ' !!', store, _key, scope.stores, i);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (Scope.isScopeClass(store)) scope._mount(name);\n\t\t\tif (Scope.isScope(store)) {\n\t\t\t\tstore = scope._mount(key);\n\t\t\t} else if (targetRevs[name]) return false; // ignore dbl uses for now\n\t\n\t\n\t\t\tif (is.fn(store)) {\n\t\t\t\tscope._mount(name);\n\t\t\t\tscope.stores[name].bind(cStore, alias, setInitial, path);\n\t\t\t} else {\n\t\t\t\tstore.bind(cStore, alias, setInitial, path);\n\t\t\t}\n\t\n\t\t\t// give initial store weight basing sources\n\t\t\tscope.stores[name]._sources && (_cStore$_sources = cStore._sources).push.apply(_cStore$_sources, _toConsumableArray(scope.stores[name]._sources));\n\t\n\t\t\ttargetRevs[alias] = targetRevs[alias] || true;\n\t\t\t!targetScope[name] && (targetScope[name] = scope.stores[name]);\n\t\t\tif (scope.stores[name].hasOwnProperty('data')) initialOutputs[name] = scope.data[name];\n\t\t\treturn true;\n\t\t});\n\t\n\t\t// ... @todo\n\t\tcStore.once('destroy', function () {\n\t\t\tkeys.map(function (key) {\n\t\t\t\tvar name = void 0,\n\t\t\t\t    alias = void 0,\n\t\t\t\t    path = void 0,\n\t\t\t\t    store = void 0;\n\t\t\t\tif (key.store && key.name) {\n\t\t\t\t\talias = name = key.name;\n\t\t\t\t\tstore = key.store;\n\t\t\t\t} else if (is.fn(key)) {\n\t\t\t\t\tname = alias = key.name || key.defaultName;\n\t\t\t\t\tstore = scope.stores[name];\n\t\t\t\t} else {\n\t\t\t\t\tkey = key.match(/([^\\.\\:]+)((?:\\.[^\\.\\:]+)*)(?:\\:([^\\.\\:]+))?/);\n\t\t\t\t\tname = key[1];\n\t\t\t\t\tpath = key[2] && key[2].substr(1);\n\t\t\t\t\tstore = scope.stores[key[1]];\n\t\t\t\t\talias = key[3] || path && path.match(/([^\\.]*)$/)[0] || key[1];\n\t\t\t\t}\n\t\n\t\t\t\tstore && !is.fn(store) && store.unBind(cStore, alias, path);\n\t\t\t});\n\t\t});\n\t\n\t\treturn initialOutputs;\n\t};\n\t\n\tStore.isStore = Scope.isStore = function (obj) {\n\t\treturn obj instanceof Store;\n\t};\n\tStore.isStoreClass = Scope.isStoreClass = function (obj) {\n\t\treturn Store.isPrototypeOf(obj) || obj === Store;\n\t};\n\t\n\texports.default = Store;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _is = __webpack_require__(1);\n\t\n\tvar _is2 = _interopRequireDefault(_is);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Minimal push sequencer, apply stores specific task in the right order\n\t */\n\tvar taskQueue = [],\n\t    curWeight = 0,\n\t    maxWeight = 0,\n\t    minWeight = 0,\n\t    taskCount = 0,\n\t    deSync = false,\n\t    deSyncMaxTasks = 10,\n\t    task = void 0,\n\t    isRunning = void 0,\n\t    errorCatcher = {\n\t    lastError: null,\n\t    dispatch: function dispatch(error) {\n\t        errorCatcher.disable();\n\t        if (task && task[0].handleError) {\n\t            task[0].handleError(error, task);\n\t        } else if (task) console.error(\"ReScope : An apply task has failed !!\", task[1], \" on \", task[0].name || task[0].constructor.name);\n\t\n\t        isRunning = false;\n\t        task = null;\n\t        runNow();\n\t    },\n\t    enable: typeof window !== 'undefined' ? function () {\n\t        window.addEventListener('error', errorCatcher.dispatch);\n\t    } : function () {\n\t        process.on('uncaughtException', errorCatcher.dispatch);\n\t    },\n\t    disable: typeof window !== 'undefined' ? function () {\n\t        window.removeEventListener('error', errorCatcher.dispatch);\n\t    } : function () {\n\t        process.removeListener('uncaughtException', errorCatcher.dispatch);\n\t    }\n\t}; /*\n\t    * The MIT License (MIT)\n\t    * Copyright (c) 2019. Wise Wild Web\n\t    *\n\t    * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\t    *\n\t    * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\t    *\n\t    * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t    *\n\t    *  @author : Nathanael Braun\n\t    *  @contact : n8tz.js@gmail.com\n\t    */\n\t\n\tfunction runNow() {\n\t    if (!isRunning) {\n\t        run();\n\t    }\n\t}\n\t\n\tfunction run() {\n\t    var from = Date.now();\n\t    isRunning = true;\n\t    errorCatcher.enable();\n\t    while (taskCount) {\n\t\n\t        // try for the current weight\n\t        while (!(taskQueue[curWeight] && taskQueue[curWeight].length)) {\n\t            curWeight++;\n\t        }taskCount--;\n\t        task = taskQueue[curWeight].shift();\n\t        //console.log(\"Task : \", task[1], \" on \", task[0].name);\n\t        task[0][task[1]].apply(task[0], task[2]);\n\t    }\n\t    task = undefined;\n\t    errorCatcher.disable();\n\t\n\t    isRunning = false;\n\t    if (taskCount) {\n\t        setTimeout(runNow);\n\t    }\n\t}\n\t\n\t//\n\t//index.setTaskDeSync = ( nb ) => {\n\t//    if ( nb === false )\n\t//        return deSync = false;\n\t//    else if ( nb === true ) {\n\t//        deSync         = true;\n\t//        deSyncMaxTasks = 10;\n\t//    }\n\t//    else (is.int(nb))\n\t//    {\n\t//        deSync         = true;\n\t//        deSyncMaxTasks = nb;\n\t//    }\n\t//};\n\t\n\texports.default = {\n\t    pushTask: function pushTask(obj, fn, argz) {\n\t        /**\n\t         * The more a store have sources, the more it should be processed first\n\t         * So leafs stores stay sync, and root stores receive merged state updates;\n\t         * global state stay coherent\n\t         *\n\t         * This mean whatever the number of stores & the complexity of the deps,\n\t         * updating a store state will update its synchrone child stores immediately\n\t         *\n\t         *\n\t         * @type {*|number}\n\t         */\n\t        var weight = obj._sources && obj._sources.length || 1,\n\t            stack = taskQueue[weight] = taskQueue[weight] || [];\n\t\n\t        maxWeight = Math.max(maxWeight, weight);\n\t        curWeight = Math.min(curWeight, weight);\n\t        taskCount++;\n\t\n\t        //console.log(\"Push Task : \", fn, \" on \", obj.name, weight);\n\t        stack.push([obj, fn, argz]);\n\t        setTimeout(runNow, 0);\n\t        return stack.length;\n\t    }\n\t};\n\tmodule.exports = exports[\"default\"];\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar encode = __webpack_require__(7);\n\tvar alphabet = __webpack_require__(2);\n\t\n\t// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n\t// This number should be updated every year or so to keep the generated id short.\n\t// To regenerate `new Date() - 0` and bump the version. Always bump the version!\n\tvar REDUCE_TIME = 1459707606518;\n\t\n\t// don't change unless we change the algos or REDUCE_TIME\n\t// must be an integer and less than 16\n\tvar version = 6;\n\t\n\t// Counter is used when shortid is called multiple times in one second.\n\tvar counter;\n\t\n\t// Remember the last time shortid was called in case counter is needed.\n\tvar previousSeconds;\n\t\n\t/**\n\t * Generate unique id\n\t * Returns string id\n\t */\n\tfunction build(clusterWorkerId) {\n\t\n\t    var str = '';\n\t\n\t    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\t\n\t    if (seconds === previousSeconds) {\n\t        counter++;\n\t    } else {\n\t        counter = 0;\n\t        previousSeconds = seconds;\n\t    }\n\t\n\t    str = str + encode(alphabet.lookup, version);\n\t    str = str + encode(alphabet.lookup, clusterWorkerId);\n\t    if (counter > 0) {\n\t        str = str + encode(alphabet.lookup, counter);\n\t    }\n\t    str = str + encode(alphabet.lookup, seconds);\n\t\n\t    return str;\n\t}\n\t\n\tmodule.exports = build;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar alphabet = __webpack_require__(2);\n\t\n\t/**\n\t * Decode the id to get the version and worker\n\t * Mainly for debugging and testing.\n\t * @param id - the shortid-generated id.\n\t */\n\tfunction decode(id) {\n\t    var characters = alphabet.shuffled();\n\t    return {\n\t        version: characters.indexOf(id.substr(0, 1)) & 0x0f,\n\t        worker: characters.indexOf(id.substr(1, 1)) & 0x0f\n\t    };\n\t}\n\t\n\tmodule.exports = decode;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar alphabet = __webpack_require__(2);\n\tvar encode = __webpack_require__(7);\n\tvar decode = __webpack_require__(12);\n\tvar build = __webpack_require__(11);\n\tvar isValid = __webpack_require__(14);\n\t\n\t// if you are using cluster or multiple servers use this to make each instance\n\t// has a unique value for worker\n\t// Note: I don't know if this is automatically set when using third\n\t// party cluster solutions such as pm2.\n\tvar clusterWorkerId = __webpack_require__(17) || 0;\n\t\n\t/**\n\t * Set the seed.\n\t * Highly recommended if you don't want people to try to figure out your id schema.\n\t * exposed as shortid.seed(int)\n\t * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n\t */\n\tfunction seed(seedValue) {\n\t    alphabet.seed(seedValue);\n\t    return module.exports;\n\t}\n\t\n\t/**\n\t * Set the cluster worker or machine id\n\t * exposed as shortid.worker(int)\n\t * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n\t * returns shortid module so it can be chained.\n\t */\n\tfunction worker(workerId) {\n\t    clusterWorkerId = workerId;\n\t    return module.exports;\n\t}\n\t\n\t/**\n\t *\n\t * sets new characters to use in the alphabet\n\t * returns the shuffled alphabet\n\t */\n\tfunction characters(newCharacters) {\n\t    if (newCharacters !== undefined) {\n\t        alphabet.characters(newCharacters);\n\t    }\n\t\n\t    return alphabet.shuffled();\n\t}\n\t\n\t/**\n\t * Generate unique id\n\t * Returns string id\n\t */\n\tfunction generate() {\n\t  return build(clusterWorkerId);\n\t}\n\t\n\t// Export all other functions as properties of the generate function\n\tmodule.exports = generate;\n\tmodule.exports.generate = generate;\n\tmodule.exports.seed = seed;\n\tmodule.exports.worker = worker;\n\tmodule.exports.characters = characters;\n\tmodule.exports.decode = decode;\n\tmodule.exports.isValid = isValid;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar alphabet = __webpack_require__(2);\n\t\n\tfunction isShortId(id) {\n\t    if (!id || typeof id !== 'string' || id.length < 6 ) {\n\t        return false;\n\t    }\n\t\n\t    var characters = alphabet.characters();\n\t    var len = id.length;\n\t    for(var i = 0; i < len;i++) {\n\t        if (characters.indexOf(id[i]) === -1) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\t\n\tmodule.exports = isShortId;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto\n\t\n\tfunction randomByte() {\n\t    if (!crypto || !crypto.getRandomValues) {\n\t        return Math.floor(Math.random() * 256) & 0x30;\n\t    }\n\t    var dest = new Uint8Array(1);\n\t    crypto.getRandomValues(dest);\n\t    return dest[0] & 0x30;\n\t}\n\t\n\tmodule.exports = randomByte;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t// Found this seed-based random generator somewhere\n\t// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\t\n\tvar seed = 1;\n\t\n\t/**\n\t * return a random number based on a seed\n\t * @param seed\n\t * @returns {number}\n\t */\n\tfunction getNextValue() {\n\t    seed = (seed * 9301 + 49297) % 233280;\n\t    return seed/(233280.0);\n\t}\n\t\n\tfunction setSeed(_seed_) {\n\t    seed = _seed_;\n\t}\n\t\n\tmodule.exports = {\n\t    nextValue: getNextValue,\n\t    seed: setSeed\n\t};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = 0;\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ../../dist/ReScope.browser.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0f0ee85f5c769cc22e98","/*\n * The MIT License (MIT)\n * Copyright (c) 2019. Wise Wild Web\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n *  @author : Nathanael Braun\n *  @contact : n8tz.js@gmail.com\n */\n\nlet $global = (typeof window !== 'undefined') ? window : global;\n\nimport Scope from \"./Scope\";\nimport Store from \"./Store\";\n\nconst RS = $global.___rescope || {};\n\nif ( $global.___rescope ) {\n\tconsole.warn(\"ReScope is defined multiple times !! \\nCheck you're packaging\")\n}\nelse {\n\t\n\t$global.___rescope = RS;\n\tScope.Store        = Store;\n\tRS.Scope           = Scope;\n\tRS.Store           = Store;\n\tRS.scopeRef        =\n\t\tfunction scopeRef( map, key ) {\n\t\t\tmap[key] = new Scope.scopeRef(map[key]);\n\t\t\treturn map;\n\t\t};\n\t\n}\nexport default RS;\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/* globals window, HTMLElement */\n\n'use strict';\n\n/**!\n * is\n * the definitive JavaScript type testing library\n *\n * @copyright 2013-2014 Enrico Marino / Jordan Harband\n * @license MIT\n */\n\nvar objProto = Object.prototype;\nvar owns = objProto.hasOwnProperty;\nvar toStr = objProto.toString;\nvar symbolValueOf;\nif (typeof Symbol === 'function') {\n  symbolValueOf = Symbol.prototype.valueOf;\n}\nvar isActualNaN = function (value) {\n  return value !== value;\n};\nvar NON_HOST_TYPES = {\n  'boolean': 1,\n  number: 1,\n  string: 1,\n  undefined: 1\n};\n\nvar base64Regex = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$/;\nvar hexRegex = /^[A-Fa-f0-9]+$/;\n\n/**\n * Expose `is`\n */\n\nvar is = {};\n\n/**\n * Test general.\n */\n\n/**\n * is.type\n * Test if `value` is a type of `type`.\n *\n * @param {Mixed} value value to test\n * @param {String} type type\n * @return {Boolean} true if `value` is a type of `type`, false otherwise\n * @api public\n */\n\nis.a = is.type = function (value, type) {\n  return typeof value === type;\n};\n\n/**\n * is.defined\n * Test if `value` is defined.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if 'value' is defined, false otherwise\n * @api public\n */\n\nis.defined = function (value) {\n  return typeof value !== 'undefined';\n};\n\n/**\n * is.empty\n * Test if `value` is empty.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is empty, false otherwise\n * @api public\n */\n\nis.empty = function (value) {\n  var type = toStr.call(value);\n  var key;\n\n  if (type === '[object Array]' || type === '[object Arguments]' || type === '[object String]') {\n    return value.length === 0;\n  }\n\n  if (type === '[object Object]') {\n    for (key in value) {\n      if (owns.call(value, key)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  return !value;\n};\n\n/**\n * is.equal\n * Test if `value` is equal to `other`.\n *\n * @param {Mixed} value value to test\n * @param {Mixed} other value to compare with\n * @return {Boolean} true if `value` is equal to `other`, false otherwise\n */\n\nis.equal = function equal(value, other) {\n  if (value === other) {\n    return true;\n  }\n\n  var type = toStr.call(value);\n  var key;\n\n  if (type !== toStr.call(other)) {\n    return false;\n  }\n\n  if (type === '[object Object]') {\n    for (key in value) {\n      if (!is.equal(value[key], other[key]) || !(key in other)) {\n        return false;\n      }\n    }\n    for (key in other) {\n      if (!is.equal(value[key], other[key]) || !(key in value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (type === '[object Array]') {\n    key = value.length;\n    if (key !== other.length) {\n      return false;\n    }\n    while (key--) {\n      if (!is.equal(value[key], other[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (type === '[object Function]') {\n    return value.prototype === other.prototype;\n  }\n\n  if (type === '[object Date]') {\n    return value.getTime() === other.getTime();\n  }\n\n  return false;\n};\n\n/**\n * is.hosted\n * Test if `value` is hosted by `host`.\n *\n * @param {Mixed} value to test\n * @param {Mixed} host host to test with\n * @return {Boolean} true if `value` is hosted by `host`, false otherwise\n * @api public\n */\n\nis.hosted = function (value, host) {\n  var type = typeof host[value];\n  return type === 'object' ? !!host[value] : !NON_HOST_TYPES[type];\n};\n\n/**\n * is.instance\n * Test if `value` is an instance of `constructor`.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an instance of `constructor`\n * @api public\n */\n\nis.instance = is['instanceof'] = function (value, constructor) {\n  return value instanceof constructor;\n};\n\n/**\n * is.nil / is.null\n * Test if `value` is null.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is null, false otherwise\n * @api public\n */\n\nis.nil = is['null'] = function (value) {\n  return value === null;\n};\n\n/**\n * is.undef / is.undefined\n * Test if `value` is undefined.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is undefined, false otherwise\n * @api public\n */\n\nis.undef = is.undefined = function (value) {\n  return typeof value === 'undefined';\n};\n\n/**\n * Test arguments.\n */\n\n/**\n * is.args\n * Test if `value` is an arguments object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an arguments object, false otherwise\n * @api public\n */\n\nis.args = is.arguments = function (value) {\n  var isStandardArguments = toStr.call(value) === '[object Arguments]';\n  var isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);\n  return isStandardArguments || isOldArguments;\n};\n\n/**\n * Test array.\n */\n\n/**\n * is.array\n * Test if 'value' is an array.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an array, false otherwise\n * @api public\n */\n\nis.array = Array.isArray || function (value) {\n  return toStr.call(value) === '[object Array]';\n};\n\n/**\n * is.arguments.empty\n * Test if `value` is an empty arguments object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an empty arguments object, false otherwise\n * @api public\n */\nis.args.empty = function (value) {\n  return is.args(value) && value.length === 0;\n};\n\n/**\n * is.array.empty\n * Test if `value` is an empty array.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an empty array, false otherwise\n * @api public\n */\nis.array.empty = function (value) {\n  return is.array(value) && value.length === 0;\n};\n\n/**\n * is.arraylike\n * Test if `value` is an arraylike object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an arguments object, false otherwise\n * @api public\n */\n\nis.arraylike = function (value) {\n  return !!value && !is.bool(value)\n    && owns.call(value, 'length')\n    && isFinite(value.length)\n    && is.number(value.length)\n    && value.length >= 0;\n};\n\n/**\n * Test boolean.\n */\n\n/**\n * is.bool\n * Test if `value` is a boolean.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a boolean, false otherwise\n * @api public\n */\n\nis.bool = is['boolean'] = function (value) {\n  return toStr.call(value) === '[object Boolean]';\n};\n\n/**\n * is.false\n * Test if `value` is false.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is false, false otherwise\n * @api public\n */\n\nis['false'] = function (value) {\n  return is.bool(value) && Boolean(Number(value)) === false;\n};\n\n/**\n * is.true\n * Test if `value` is true.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is true, false otherwise\n * @api public\n */\n\nis['true'] = function (value) {\n  return is.bool(value) && Boolean(Number(value)) === true;\n};\n\n/**\n * Test date.\n */\n\n/**\n * is.date\n * Test if `value` is a date.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a date, false otherwise\n * @api public\n */\n\nis.date = function (value) {\n  return toStr.call(value) === '[object Date]';\n};\n\n/**\n * is.date.valid\n * Test if `value` is a valid date.\n *\n * @param {Mixed} value value to test\n * @returns {Boolean} true if `value` is a valid date, false otherwise\n */\nis.date.valid = function (value) {\n  return is.date(value) && !isNaN(Number(value));\n};\n\n/**\n * Test element.\n */\n\n/**\n * is.element\n * Test if `value` is an html element.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an HTML Element, false otherwise\n * @api public\n */\n\nis.element = function (value) {\n  return value !== undefined\n    && typeof HTMLElement !== 'undefined'\n    && value instanceof HTMLElement\n    && value.nodeType === 1;\n};\n\n/**\n * Test error.\n */\n\n/**\n * is.error\n * Test if `value` is an error object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an error object, false otherwise\n * @api public\n */\n\nis.error = function (value) {\n  return toStr.call(value) === '[object Error]';\n};\n\n/**\n * Test function.\n */\n\n/**\n * is.fn / is.function (deprecated)\n * Test if `value` is a function.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a function, false otherwise\n * @api public\n */\n\nis.fn = is['function'] = function (value) {\n  var isAlert = typeof window !== 'undefined' && value === window.alert;\n  if (isAlert) {\n    return true;\n  }\n  var str = toStr.call(value);\n  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';\n};\n\n/**\n * Test number.\n */\n\n/**\n * is.number\n * Test if `value` is a number.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a number, false otherwise\n * @api public\n */\n\nis.number = function (value) {\n  return toStr.call(value) === '[object Number]';\n};\n\n/**\n * is.infinite\n * Test if `value` is positive or negative infinity.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is positive or negative Infinity, false otherwise\n * @api public\n */\nis.infinite = function (value) {\n  return value === Infinity || value === -Infinity;\n};\n\n/**\n * is.decimal\n * Test if `value` is a decimal number.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a decimal number, false otherwise\n * @api public\n */\n\nis.decimal = function (value) {\n  return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 !== 0;\n};\n\n/**\n * is.divisibleBy\n * Test if `value` is divisible by `n`.\n *\n * @param {Number} value value to test\n * @param {Number} n dividend\n * @return {Boolean} true if `value` is divisible by `n`, false otherwise\n * @api public\n */\n\nis.divisibleBy = function (value, n) {\n  var isDividendInfinite = is.infinite(value);\n  var isDivisorInfinite = is.infinite(n);\n  var isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && n !== 0;\n  return isDividendInfinite || isDivisorInfinite || (isNonZeroNumber && value % n === 0);\n};\n\n/**\n * is.integer\n * Test if `value` is an integer.\n *\n * @param value to test\n * @return {Boolean} true if `value` is an integer, false otherwise\n * @api public\n */\n\nis.integer = is['int'] = function (value) {\n  return is.number(value) && !isActualNaN(value) && value % 1 === 0;\n};\n\n/**\n * is.maximum\n * Test if `value` is greater than 'others' values.\n *\n * @param {Number} value value to test\n * @param {Array} others values to compare with\n * @return {Boolean} true if `value` is greater than `others` values\n * @api public\n */\n\nis.maximum = function (value, others) {\n  if (isActualNaN(value)) {\n    throw new TypeError('NaN is not a valid value');\n  } else if (!is.arraylike(others)) {\n    throw new TypeError('second argument must be array-like');\n  }\n  var len = others.length;\n\n  while (--len >= 0) {\n    if (value < others[len]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * is.minimum\n * Test if `value` is less than `others` values.\n *\n * @param {Number} value value to test\n * @param {Array} others values to compare with\n * @return {Boolean} true if `value` is less than `others` values\n * @api public\n */\n\nis.minimum = function (value, others) {\n  if (isActualNaN(value)) {\n    throw new TypeError('NaN is not a valid value');\n  } else if (!is.arraylike(others)) {\n    throw new TypeError('second argument must be array-like');\n  }\n  var len = others.length;\n\n  while (--len >= 0) {\n    if (value > others[len]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * is.nan\n * Test if `value` is not a number.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is not a number, false otherwise\n * @api public\n */\n\nis.nan = function (value) {\n  return !is.number(value) || value !== value;\n};\n\n/**\n * is.even\n * Test if `value` is an even number.\n *\n * @param {Number} value value to test\n * @return {Boolean} true if `value` is an even number, false otherwise\n * @api public\n */\n\nis.even = function (value) {\n  return is.infinite(value) || (is.number(value) && value === value && value % 2 === 0);\n};\n\n/**\n * is.odd\n * Test if `value` is an odd number.\n *\n * @param {Number} value value to test\n * @return {Boolean} true if `value` is an odd number, false otherwise\n * @api public\n */\n\nis.odd = function (value) {\n  return is.infinite(value) || (is.number(value) && value === value && value % 2 !== 0);\n};\n\n/**\n * is.ge\n * Test if `value` is greater than or equal to `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean}\n * @api public\n */\n\nis.ge = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError('NaN is not a valid value');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value >= other;\n};\n\n/**\n * is.gt\n * Test if `value` is greater than `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean}\n * @api public\n */\n\nis.gt = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError('NaN is not a valid value');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value > other;\n};\n\n/**\n * is.le\n * Test if `value` is less than or equal to `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean} if 'value' is less than or equal to 'other'\n * @api public\n */\n\nis.le = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError('NaN is not a valid value');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value <= other;\n};\n\n/**\n * is.lt\n * Test if `value` is less than `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean} if `value` is less than `other`\n * @api public\n */\n\nis.lt = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError('NaN is not a valid value');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value < other;\n};\n\n/**\n * is.within\n * Test if `value` is within `start` and `finish`.\n *\n * @param {Number} value value to test\n * @param {Number} start lower bound\n * @param {Number} finish upper bound\n * @return {Boolean} true if 'value' is is within 'start' and 'finish'\n * @api public\n */\nis.within = function (value, start, finish) {\n  if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {\n    throw new TypeError('NaN is not a valid value');\n  } else if (!is.number(value) || !is.number(start) || !is.number(finish)) {\n    throw new TypeError('all arguments must be numbers');\n  }\n  var isAnyInfinite = is.infinite(value) || is.infinite(start) || is.infinite(finish);\n  return isAnyInfinite || (value >= start && value <= finish);\n};\n\n/**\n * Test object.\n */\n\n/**\n * is.object\n * Test if `value` is an object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an object, false otherwise\n * @api public\n */\nis.object = function (value) {\n  return toStr.call(value) === '[object Object]';\n};\n\n/**\n * is.primitive\n * Test if `value` is a primitive.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a primitive, false otherwise\n * @api public\n */\nis.primitive = function isPrimitive(value) {\n  if (!value) {\n    return true;\n  }\n  if (typeof value === 'object' || is.object(value) || is.fn(value) || is.array(value)) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * is.hash\n * Test if `value` is a hash - a plain object literal.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a hash, false otherwise\n * @api public\n */\n\nis.hash = function (value) {\n  return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;\n};\n\n/**\n * Test regexp.\n */\n\n/**\n * is.regexp\n * Test if `value` is a regular expression.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a regexp, false otherwise\n * @api public\n */\n\nis.regexp = function (value) {\n  return toStr.call(value) === '[object RegExp]';\n};\n\n/**\n * Test string.\n */\n\n/**\n * is.string\n * Test if `value` is a string.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if 'value' is a string, false otherwise\n * @api public\n */\n\nis.string = function (value) {\n  return toStr.call(value) === '[object String]';\n};\n\n/**\n * Test base64 string.\n */\n\n/**\n * is.base64\n * Test if `value` is a valid base64 encoded string.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if 'value' is a base64 encoded string, false otherwise\n * @api public\n */\n\nis.base64 = function (value) {\n  return is.string(value) && (!value.length || base64Regex.test(value));\n};\n\n/**\n * Test base64 string.\n */\n\n/**\n * is.hex\n * Test if `value` is a valid hex encoded string.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if 'value' is a hex encoded string, false otherwise\n * @api public\n */\n\nis.hex = function (value) {\n  return is.string(value) && (!value.length || hexRegex.test(value));\n};\n\n/**\n * is.symbol\n * Test if `value` is an ES6 Symbol\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a Symbol, false otherise\n * @api public\n */\n\nis.symbol = function (value) {\n  return typeof Symbol === 'function' && toStr.call(value) === '[object Symbol]' && typeof symbolValueOf.call(value) === 'symbol';\n};\n\nmodule.exports = is;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is/index.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nvar randomFromSeed = require('./random/random-from-seed');\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nmodule.exports = {\n    characters: characters,\n    seed: setSeed,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/alphabet.js\n// module id = 2\n// module chunks = 0","/*\n * The MIT License (MIT)\n * Copyright (c) 2019. Wise Wild Web\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n *  @author : Nathanael Braun\n *  @contact : n8tz.js@gmail.com\n */\n\nimport is                                             from \"is\";\nimport shortid                                        from \"shortid\";\nimport EventEmitter                                   from \"./utils/Emitter\";\nimport {walknSet, walknGet, keyWalknSet, keyWalknGet} from './utils/utils';\n\nconst __proto__push = ( target, id, parent ) => {\n\t      let fn       = function () {\n\t      };\n\t      fn.prototype = parent ? new parent._[id]() : target[id] || {};\n\t      target[id]   = new fn();\n\t      target._[id] = fn;\n      },\n      allScopes     = {};\n\n\n/**\n * Base Scope object\n */\nclass Scope extends EventEmitter {\n\t\n\tstatic persistenceTm = 1;// if > 0, will wait 'persistenceTm' ms before destroy when dispose reach 0\n\tstatic Store         = null;\n\tstatic scopeRef      = function scopeRef( path ) {\n\t\tthis.path = path;\n\t};\n\tstatic scopes        = allScopes;// all active scopes\n\t/**\n\t * get a parsed reference list from stateMap\n\t * @param _ref\n\t * @returns {{storeId, path, alias: *, ref: *}}\n\t */\n\tstatic stateMapToRefList( sm, state = {}, _refs = [], actions = {}, path = \"\" ) {\n\t\tlet applier;\n\t\tObject.keys(sm).forEach(\n\t\t\tkey => {\n\t\t\t\tlet cpath = path ? path + '.' + key : key;\n\t\t\t\t\n\t\t\t\tsm[key] instanceof Scope.scopeRef\n\t\t\t\t? _refs.push(sm[key].path + ':' + cpath)\n\t\t\t\t: (sm[key] && sm[key] instanceof Function)\n\t\t\t\t  ? key == \"$apply\"\n\t\t\t\t    ? applier = sm[key]\n\t\t\t\t    : actions[key] = sm[key]\n\t\t\t\t  : (sm[key] && sm[key].prototype instanceof Scope.Store)\n\t\t\t\t    ? _refs.push(sm[key].as(cpath))\n\t\t\t\t    : state[cpath] = sm[key]\n\t\t\t\t//: this.stateMapToRefList(sm[key], _refs, path + '.' + key)\n\t\t\t}\n\t\t)\n\t\treturn applier;\n\t}\n\t\n\tstatic getScope( scopes ) {\n\t\tlet skey = is.array(scopes) ? scopes.sort(( a, b ) => {\n\t\t\tif ( a.firstname < b.firstname ) return -1;\n\t\t\tif ( a.firstname > b.firstname ) return 1;\n\t\t\treturn 0;\n\t\t}).join('+') : scopes;\n\t\treturn allScopes[skey] = allScopes[skey] || new Scope({}, { id: skey });\n\t};\n\t\n\t\n\t/**\n\t * Init a ReScope scope\n\t *\n\t * @param storesMap {Object} Object with the initial stores definition / instances\n\t * @param config {Object} Scope config\n\t * {\n\t *     parent {scope} @optional parent scope\n\t *\n\t *     id {string} @optional id ( if this id exist storesMap will be merge on the 'id'\n\t *     scope)\n\t *     key {string} @optional key of the scope ( if no id is set, the scope id will be (parent.id+'>'+key)\n\t *     incrementId {bool} @optional true to add a suffix id, if the provided key or id globally exist\n\t *\n\t *     state {Object} @optional initial state by store alias\n\t *     data {Object} @optional initial data by store alias\n\t *\n\t *     rootEmitter {bool} @optional true to not being destabilized by parent\n\t *     boundedActions {array | regexp} @optional list or regexp of actions not propagated to the parent\n\t *     autoDestroy {true | false | 'inherit'}\n\t *     persistenceTm {number) if > 0, will wait 'persistenceTm' ms before destroy when\n\t *     dispose reach 0 autoDestroy  {bool} will trigger retain & dispose after start\n\t *  }\n\t * @returns {Scope}\n\t */\n\tconstructor( storesMap, { parent, upperScope, key, id, snapshot, state, data, incrementId = !!key, persistenceTm, autoDestroy, rootEmitter, boundedActions } = {} ) {\n\t\tsuper();\n\t\tlet _ = {\n\t\t\tkeyPID: (upperScope && upperScope._id || parent && parent._id || shortid.generate()),\n\t\t\tkey,\n\t\t\tincrementId,\n\t\t\tbaseId: id\n\t\t};\n\t\t\n\t\t\n\t\t// generate / set this scope id\n\t\tid = id || key && (_.keyPID + '>' + key);\n\t\t\n\t\t_.isLocalId = !id;\n\t\t\n\t\tid = id || (\"_____\" + shortid.generate());\n\t\t\n\t\tif ( allScopes[id] && !incrementId ) {// overwrite existing scope\n\t\t\tthis._id = id;\n\t\t\tallScopes[id].register(storesMap);\n\t\t\treturn allScopes[id]\n\t\t}\n\t\telse if ( allScopes[id] && incrementId ) {// generate key id\n\t\t\tlet i = -1;\n\t\t\twhile ( allScopes[id + '[' + (++i) + ']'] ) ;\n\t\t\tid = id + '[' + i + ']';\n\t\t}\n\t\t\n\t\t// register this scope in the static Scope.scopes\n\t\tallScopes[id] = this;\n\t\t\n\t\tthis._id  = id;\n\t\tthis._rev = 0;\n\t\t\n\t\tthis._ = _;\n\t\t\n\t\tthis.actions = {};\n\t\tthis.stores  = {};\n\t\tthis.state   = {};\n\t\tthis.data    = {};\n\t\t\n\t\tthis.parent = parent;\n\t\t\n\t\tif ( autoDestroy == 'inherit' )\n\t\t\tautoDestroy = parent && parent._autoDestroy;\n\t\t\n\t\tthis._autoDestroy = autoDestroy;\n\t\t_.persistenceTm   = persistenceTm || this.constructor.persistenceTm;\n\t\t\n\t\tif ( parent && parent.dead )\n\t\t\tthrow new Error(\"Can't use a dead scope as parent !\");\n\t\t\n\t\t__proto__push(this, 'actions', parent);\n\t\t__proto__push(this, 'stores', parent);\n\t\t__proto__push(this, 'state', parent);\n\t\t__proto__push(this, 'data', parent);\n\t\t\n\t\tthis.sources      = [];\n\t\t_.childScopes     = [];\n\t\t_.childScopesList = [];\n\t\t_.unStableChilds  = 0;\n\t\t_.seenChilds      = 0;\n\t\t_._listening      = {};\n\t\t_._scope          = {};\n\t\t_._mixed          = [];\n\t\t_._mixedList      = [];\n\t\t_.followers       = [];\n\t\t\n\t\tthis.__retains = { all: 0 };\n\t\tthis.__locks   = { all: 1 };\n\t\t\n\t\t// todo\n\t\t_._boundedActions = is.array(boundedActions)\n\t\t                    ? { test: boundedActions.includes.bind(boundedActions) }\n\t\t                    : boundedActions;\n\t\t\n\t\t// register to the parent scope\n\t\tif ( parent ) {\n\t\t\tparent.retain(\"isMyParent\");\n\t\t\tif ( !rootEmitter ) {\n\t\t\t\t!parent._stable && this.wait(\"waitingParent\");\n\t\t\t\tparent.on(_._parentList = {\n\t\t\t\t\t'stable'  : s => this.release(\"waitingParent\"),\n\t\t\t\t\t'unstable': s => this.wait(\"waitingParent\"),\n\t\t\t\t\t'update'  : s => this._propag()\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparent.on(_._parentList = {\n\t\t\t\t\t'update': s => this._propag()\n\t\t\t\t});\n\t\t\t}\n\t\t\t// this.register(parent.__scope, state, data);\n\t\t}\n\t\t\n\t\t// register this scope stores\n\t\tthis.register(storesMap, state, data);\n\t\tthis.__locks.all--;\n\t\tthis._stable = !this.__locks.all;\n\t\t\n\t\tif ( parent ) {\n\t\t\tparent._addChild(this);\n\t\t}\n\t\t\n\t\t\n\t\t// restore snapshots\n\t\tthis.restore(snapshot);\n\t\t\n\t\t\n\t\tif ( autoDestroy )\n\t\t\tsetTimeout(\n\t\t\t\ttm => {\n\t\t\t\t\tthis.retain(\"autoDestroy\");\n\t\t\t\t\tthis.dispose(\"autoDestroy\");\n\t\t\t\t}\n\t\t\t)\n\t\t\n\t}\n\t\n\t/**\n\t *\n\t * Mount the stores in storesList, in this scope or in its parents or mixed scopes\n\t *\n\t * @param storeIdList {string|storeRef} Store name, Array of Store names, or Rescope\n\t *     store ref from Store::as or Store:as\n\t * @param state\n\t * @param data\n\t * @returns {Scope}\n\t */\n\tmount( storeIdList, snapshot, state, data ) {\n\t\tif ( is.array(storeIdList) ) {\n\t\t\tstoreIdList.forEach(storeId => this._mount(storeId, snapshot, state, data));\n\t\t}\n\t\telse {\n\t\t\tthis._mount(...arguments);\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t_mount( id, snapshot, state, data ) {\n\t\tlet ref, _ = this._;\n\t\t\n\t\tref = this.parseRef(id)\n\t\t\n\t\tif ( id == \"$parent\" ) return;\n\t\tif ( !_._scope[ref.storeId] ) {//ask mixed || parent\n\t\t\tif ( _._mixed.reduceRight(( mounted, ctx ) => (mounted || ctx._mount(id, snapshot, state, data)), false) ||\n\t\t\t\t!this.parent )\n\t\t\t\treturn;\n\t\t\treturn this.parent._mount(...arguments);\n\t\t}\n\t\telse {\n\t\t\tlet store = _._scope[ref.storeId], taskQueue = [];\n\t\t\tif ( Scope.isStoreClass(store) ) {\n\t\t\t\t_._scope[ref.storeId] = new store(this, {\n\t\t\t\t\t//snapshot,\n\t\t\t\t\tname: ref.storeId,\n\t\t\t\t\tstate,\n\t\t\t\t\tdata\n\t\t\t\t}, taskQueue);\n\t\t\t\twhile ( taskQueue.length ) taskQueue.shift()();\n\t\t\t}\n\t\t\telse if ( Scope.isScopeClass(store) ) {\n\t\t\t\tstore = _._scope[ref.storeId] = new store({ $parent: this }, {\n\t\t\t\t\tkey        : ref.storeId,\n\t\t\t\t\tincrementId: true,\n\t\t\t\t\tupperScope : this\n\t\t\t\t\t//autoDestroy: true\n\t\t\t\t\t//parent: this\n\t\t\t\t});\n\t\t\t\t//_._scope[ ref.storeId ].retain(\"scopedChildScope\");\n\t\t\t\t//_watchStore(ref.storeId);\n\t\t\t\tif ( ref.path.length > 1 )\n\t\t\t\t\t_._scope[ref.storeId].mount(ref.path.slice(1).join('.'), snapshot, state, data)\n\t\t\t\t//else return _._scope[ ref.storeId ];\n\t\t\t}\n\t\t\tif ( Scope.isStore(store) ) {\n\t\t\t\tif ( state !== undefined && data === undefined )\n\t\t\t\t\tstore.setState(state);\n\t\t\t\telse if ( state !== undefined )\n\t\t\t\t\tstore.state = state;\n\t\t\t\t\n\t\t\t\tif ( data !== undefined )\n\t\t\t\t\tstore.push(data);\n\t\t\t}\n\t\t\tthis._watchStore(ref.storeId);\n\t\t}\n\t\t\n\t\t\n\t\treturn _._scope[ref.storeId];\n\t}\n\t\n\t/**\n\t * Register stores in storesMap & link them in the protos\n\t * @param storesMap\n\t * @param state\n\t * @param data\n\t */\n\tregister( storesMap, state = {}, data = {} ) {\n\t\tthis.relink(storesMap, this, false, false);\n\t\tObject.keys(storesMap).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id == \"$parent\" ) return;\n\t\t\t\tif ( storesMap[id].singleton || (is.fn(storesMap[id]) && (state[id] || data[id])) ) {\n\t\t\t\t\tthis._mount(id, undefined, state[id], data[id])\n\t\t\t\t}\n\t\t\t\telse if ( state[id] || data[id] ) {\n\t\t\t\t\tif ( data[id] ) {\n\t\t\t\t\t\tif ( state[id] )\n\t\t\t\t\t\t\tthis.stores[id].state = state[id];\n\t\t\t\t\t\tthis.stores[id].push(data[id]);\n\t\t\t\t\t}\n\t\t\t\t\telse if ( state[id] ) {\n\t\t\t\t\t\tthis.stores[id].setState(state[id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._watchStore(id);\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t\t\n\t}\n\t\n\t/**\n\t * Map srcCtx store's on targetCtx headers proto's\n\t * @param srcCtx\n\t * @param targetCtx\n\t * @param state\n\t * @param data\n\t */\n\trelink( srcCtx, targetCtx = this, external, force ) {\n\t\tlet _ = this._;\n\t\tObject.keys(srcCtx)\n\t\t      .forEach(\n\t\t\t      id => {\n\t\t\t\t      let hotReloading;\n\t\t\t\t\n\t\t\t\t      // same store def : ignore\n\t\t\t\t      if ( !force && targetCtx._._scope[id] === srcCtx[id] ||\n\t\t\t\t\t      targetCtx._._scope[id] && (targetCtx._._scope[id].constructor === srcCtx[id]) )\n\t\t\t\t\t      return;\n\t\t\t\t\n\t\t\t\t      // hot switch\n\t\t\t\t      if ( !force && targetCtx._._scope[id] ) {\n\t\t\t\t\t\n\t\t\t\t\t      if ( !external && !is.fn(targetCtx._._scope[id]) ) {\n\t\t\t\t\t\t      console.info(\"Rescope Store : \", id, \" already exist in this scope ! ( Hot switching the store ) !!!\");\n\t\t\t\t\t\t      let tmp                = targetCtx._._scope[id];\n\t\t\t\t\t\t      targetCtx._._scope[id] = srcCtx[id];\n\t\t\t\t\t\t      hotReloading           = tmp.nextState;\n\t\t\t\t\t\t      tmp.destroy();\n\t\t\t\t\t      }\n\t\t\t\t\t\n\t\t\t\t\t      if ( !external && is.fn(targetCtx._._scope[id]) )\n\t\t\t\t\t\t      targetCtx._._scope[id] = srcCtx[id];\n\t\t\t\t\t\n\t\t\t\t      }\n\t\t\t\t      else if ( !force && !external )\n\t\t\t\t\t      _._scope[id] = srcCtx[id];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t      // map the store id\n\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t      targetCtx._.stores.prototype,\n\t\t\t\t\t      id,\n\t\t\t\t\t      {\n\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t      get         : () => _._scope[id]\n\t\t\t\t\t      }\n\t\t\t\t      );\n\t\t\t\t\n\t\t\t\t      // not mapping hierarchic scopes\n\t\t\t\t      if ( id === \"$parent\" ) return;\n\t\t\t\t\n\t\t\t\t      // map state & data\n\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t      targetCtx._.state.prototype,\n\t\t\t\t\t      id,\n\t\t\t\t\t      {\n\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t      get         : () => (_._scope[id] && _._scope[id].state),\n\t\t\t\t\t\t      set         : ( v ) => (this._mount(id, undefined, v))\n\t\t\t\t\t      }\n\t\t\t\t      );\n\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t      targetCtx._.data.prototype,\n\t\t\t\t\t      id,\n\t\t\t\t\t      {\n\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t      get         : () => (_._scope[id] && _._scope[id].data),\n\t\t\t\t\t\t      set         : ( v ) => (this._mount(id, undefined, undefined, v))\n\t\t\t\t\t      }\n\t\t\t\t      );\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t      // action mapping\n\t\t\t\t      let actions       = srcCtx[id] instanceof Scope.Store\n\t\t\t\t                          ? srcCtx[id].constructor.actions\n\t\t\t\t                          : srcCtx[id].actions,\n\t\t\t\t          activeActions = targetCtx._.actions.prototype;\n\t\t\t\t      if ( Scope.isScope(_._scope[id].prototype) )\n\t\t\t\t\t      this._mount(id);\n\t\t\t\t      if ( Scope.isScope(_._scope[id]) ) {\n\t\t\t\t\t      activeActions[id] = _._scope[id].actions;\n\t\t\t\t      }\n\t\t\t\t      if ( !Scope.isStore(_._scope[id]) && !Scope.isStoreClass(_._scope[id]) )\n\t\t\t\t\t      return;\n\t\t\t\t\n\t\t\t\t      actions &&\n\t\t\t\t      Object.keys(actions)\n\t\t\t\t            .forEach(\n\t\t\t\t\t            ( act ) => {\n\t\t\t\t\t\t            if ( activeActions.hasOwnProperty(act) )\n\t\t\t\t\t\t\t            activeActions[act].__targetStores++;\n\t\t\t\t\t\t            else {\n\t\t\t\t\t\t\t            activeActions[act]                = this.dispatch.bind(this, act);\n\t\t\t\t\t\t\t            activeActions[act].__targetStores = 1;\n\t\t\t\t\t\t            }\n\t\t\t\t\t            }\n\t\t\t\t            );\n\t\t\t\t\n\t\t\t\t      // remount the store if it was hot reloaded\n\t\t\t\t      if ( hotReloading )\n\t\t\t\t\t      this._mount(id, null, hotReloading);\n\t\t\t      }\n\t\t      )\n\t}\n\t\n\t/**\n\t * Make this scope watching the local store 'id'\n\t * @param id\n\t * @returns {boolean}\n\t * @private\n\t */\n\t_watchStore( id ) {\n\t\tlet _ = this._;\n\t\tif ( !_._listening[id] && !is.fn(_._scope[id]) ) {\n\t\t\t!_._scope[id]._autoDestroy && _._scope[id].retain(\"scoped\");\n\t\t\t!_._scope[id].isStable() && this.wait(id);\n\t\t\t_._scope[id].on(\n\t\t\t\t_._listening[id] = {\n\t\t\t\t\t'destroy' : s => {\n\t\t\t\t\t\tdelete _._listening[id];\n\t\t\t\t\t\t_._scope[id] = _._scope[id].constructor;\n\t\t\t\t\t},\n\t\t\t\t\t'update'  : s => this.propag(),\n\t\t\t\t\t'stable'  : s => this.release(id),\n\t\t\t\t\t'unstable': s => this.wait(id)\n\t\t\t\t});\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Mix targetCtx on this scope\n\t * Mixed scope parents are NOT mapped\n\t * @param targetCtx\n\t */\n\tmixin( targetCtx ) {\n\t\tlet parent = this.parent,\n\t\t    lists,\n\t\t    _      = this._;\n\t\t\n\t\t_._mixed.push(targetCtx);\n\t\t\n\t\ttargetCtx.retain(\"mixedTo\");\n\t\t\n\t\tif ( !targetCtx._stable )\n\t\t\tthis.wait(targetCtx._id);\n\t\t\n\t\t_._mixedList.push(lists = {\n\t\t\t'stable'  : s => this.release(targetCtx._id),\n\t\t\t'unstable': s => this.wait(targetCtx._id),\n\t\t\t'update'  : s => this._propag()\n\t\t});\n\t\t\n\t\ttargetCtx.on(lists);\n\t\t\n\t\t// reset protos\n\t\t// push new proto with parent\n\t\t__proto__push(this, 'actions', parent);\n\t\t__proto__push(this, 'stores', parent);\n\t\t__proto__push(this, 'state', parent);\n\t\t__proto__push(this, 'data', parent);\n\t\t\n\t\t// bind local accessors in the new proto\n\t\tthis.relink(_._scope, this, false, true);\n\t\t\n\t\t_._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t// push protos\n\t\t\t\t__proto__push(this, 'actions');\n\t\t\t\t__proto__push(this, 'stores');\n\t\t\t\t__proto__push(this, 'state');\n\t\t\t\t__proto__push(this, 'data');\n\t\t\t\tthis.stores.__origin = \"mixed \" + ctx._id;\n\t\t\t\t// write mixed accessors\n\t\t\t\tctx.relink(ctx._._scope, this, true, true)\n\t\t\t}\n\t\t)\n\t}\n\t\n\t/**\n\t * Bind stores from this scope, his parents or mixed scopes to obj\n\t *\n\t * @param target {React.Component|Store|function}\n\t * @param key {string} stores keys to bind updates\n\t * @param as\n\t * @param setInitial {boolean} false to not propag initial value (default : true)\n\t */\n\tbind( target, key, as, setInitial = true, revMap = {} ) {\n\t\tlet lastRevs, data, refKeys;\n\t\tif ( key && !is.array(key) )\n\t\t\tkey = [key];\n\t\t\n\t\tif ( as === false || as === true ) {\n\t\t\tsetInitial = as;\n\t\t\tas         = null;\n\t\t}\n\t\t\n\t\trefKeys = key\n\t\t\t.map(id => (is.string(id) ? id : id.name))\n\t\t\t.map(id => (this.parseRef(id)));\n\t\t\n\t\t\n\t\tthis._.followers.push(\n\t\t\t[\n\t\t\t\ttarget,\n\t\t\t\tkey,\n\t\t\t\tas || undefined,\n\t\t\t\tlastRevs = refKeys.reduce(( revs, ref ) => {\n\t\t\t\t\trevs[ref.storeId] = revs[ref.storeId] || {\n\t\t\t\t\t\trev : 0,\n\t\t\t\t\t\trefs: []\n\t\t\t\t\t};\n\t\t\t\t\trevs[ref.storeId].refs.push(ref);\n\t\t\t\t\treturn revs;\n\t\t\t\t}, revMap)\n\t\t\t]);\n\t\t\n\t\tthis.mount(key);\n\t\tthis.retainStores(Object.keys(lastRevs), 'listeners');\n\t\t\n\t\tif ( setInitial && this._stable ) {\n\t\t\tdata = this.getUpdates(lastRevs);\n\t\t\tif ( !data ) return this;\n\t\t\tif ( typeof target != \"function\" ) {\n\t\t\t\tif ( as ) target.setState({ [as]: data });\n\t\t\t\telse target.setState(data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttarget(data);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Un bind this scope off the given component-keys\n\t * @param target\n\t * @param key\n\t * @returns {Array.<*>}\n\t */\n\tunBind( target, key, as ) {\n\t\tlet followers = this._.followers,\n\t\t    i         = followers && followers.length;\n\t\twhile ( followers && i-- )\n\t\t\tif ( followers[i][0] === target &&\n\t\t\t\t('' + followers[i][1]) == ('' + key) &&\n\t\t\t\tfollowers[i][2] == as ) {\n\t\t\t\tthis.disposeStores(Object.keys(followers[i][3]), 'listeners');\n\t\t\t\treturn followers.splice(i, 1);\n\t\t\t}\n\t}\n\t\n\t/**\n\t * Mount the stores in storeIdList from this scope, its parents and mixed scope\n\t * Bind them to 'to'\n\t * Hook 'to' so it will auto unbind on 'destroy' or 'componentWillUnmount'\n\t * @param target\n\t * @param storeIdList\n\t * @param bind\n\t * @returns {Object} Initial outputs of the stores in 'storesList'\n\t */\n\tmap( target, storeIdList, bind = true, revMap ) {\n\t\tlet Store   = this.constructor.Store;\n\t\tstoreIdList = is.array(storeIdList) ? storeIdList : [storeIdList];\n\t\tlet refList = storeIdList.map(this.parseRef);\n\t\tthis.mount(storeIdList);\n\t\tif ( bind && target instanceof Store ) {\n\t\t\tStore.map(target, storeIdList, this, this, false)\n\t\t}\n\t\telse if ( bind ) {\n\t\t\tthis.bind(target, storeIdList, undefined, false);\n\t\t\t\n\t\t\tlet mixedCWUnmount,\n\t\t\t    unMountKey = target.isReactComponent ? \"componentWillUnmount\" : \"destroy\";\n\t\t\t\n\t\t\tif ( target.hasOwnProperty(unMountKey) ) {\n\t\t\t\tmixedCWUnmount = target[unMountKey];\n\t\t\t}\n\t\t\t\n\t\t\ttarget[unMountKey] = ( ...argz ) => {\n\t\t\t\tdelete target[unMountKey];\n\t\t\t\tif ( mixedCWUnmount )\n\t\t\t\t\ttarget[unMountKey] = mixedCWUnmount;\n\t\t\t\t\n\t\t\t\tthis.unBind(target, storeIdList);\n\t\t\t\treturn target[unMountKey] && target[unMountKey](...argz);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn revMap && this.getUpdates(revMap)\n\t\t\t|| refList.reduce(( data, ref ) => {\n\t\t\t\twalknSet(data, ref.alias || ref.path, this.retrieve(ref.path))\n\t\t\t\treturn data;\n\t\t\t}, {});\n\t}\n\t\n\t/**\n\t * Get current data value from json path\n\t * @param path\n\t * @returns {string|*}\n\t */\n\tretrieve( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\t\n\t\t\n\t\treturn path &&\n\t\t\tthis.stores[path[0]] &&\n\t\t\tthis.stores[path[0]].retrieve &&\n\t\t\tthis.stores[path[0]].retrieve(path.slice(1));\n\t}\n\t\n\t/**\n\t * Restore all nodes in a jsonPath\n\t * @param path\n\t * @returns {string|*}\n\t */\n\trestoreRefPath( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\t\n\t\tlet obj, i = 0, cScope = this;\n\t\t\n\t\twhile ( i < path.length ) {\n\t\t\tobj = cScope.stores[path[i]];\n\t\t\tif ( Scope.isScopeClass(obj)\n\t\t\t\t||\n\t\t\t\tScope.isStoreClass(obj) ) {\n\t\t\t\tcScope.mount(path[0]);\n\t\t\t\tobj = cScope.stores[path[i]];\n\t\t\t}\n\t\t\t\n\t\t\tif ( Scope.isScope(obj) ) {\n\t\t\t\tcScope = obj;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if ( Scope.isStore(obj) ) {\n\t\t\t\tobj.restore();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Get target store from json path\n\t * @param path\n\t * @returns {string|*}\n\t */\n\tretrieveStore( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\treturn path\n\t\t\t&& path.length\n\t\t\t&& (\n\t\t\t\tpath.length != 1 && this.stores[path[0]].retrieveStore\n\t\t\t\t? this.stores[path[0]].retrieveStore(path.slice(1))\n\t\t\t\t: path.length == 1 && this.stores[path[0]]\n\t\t\t);\n\t}\n\t\n\t/**\n\t * Get or update stores revisions in 'storesRevMap'\n\t * @param storesRevMap\n\t * @param local\n\t * @returns {{}}\n\t */\n\tgetStoresRevs( storesRevMap = {}, local ) {\n\t\tlet ctx = this._._scope;\n\t\tif ( !storesRevMap ) {\n\t\t\tstoresRevMap = {};\n\t\t}\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id == \"$parent\" ) return;\n\t\t\t\tif ( !is.fn(ctx[id])\n\t\t\t\t) {\n\t\t\t\t\tstoresRevMap[id] = ctx[id]._rev;\n\t\t\t\t}\n\t\t\t\telse if ( !storesRevMap.hasOwnProperty(id) )\n\t\t\t\t\tstoresRevMap[id] = false\n\t\t\t}\n\t\t);\n\t\tif ( !local ) {\n\t\t\tthis._._mixed.reduce(( updated, ctx ) => (ctx.getStoresRevs(storesRevMap), storesRevMap), storesRevMap);\n\t\t\tthis.parent && this.parent.getStoresRevs(storesRevMap);\n\t\t}\n\t\treturn storesRevMap;\n\t}\n\t\n\t/**\n\t * Recursively get all stores revs\n\t * @param childs\n\t * @returns {Array}\n\t * @private\n\t */\n\t_getRevMap( storesRevMap = {} ) {\n\t\tlet ctx = this._._scope;\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id == \"$parent\" || storesRevMap[id] ) return;\n\t\t\t\tstoresRevMap[id] = { rev: ctx[id]._rev, refs: [] };\n\t\t\t\t\n\t\t\t});\n\t\tthis._._mixed.reduceRight(\n\t\t\t( storesRevMap, ctx ) => (ctx._getRevMap(storesRevMap)), storesRevMap);\n\t\tthis.parent && this.parent._getRevMap(storesRevMap);\n\t\treturn storesRevMap;\n\t}\n\t\n\t/**\n\t * Get updated output basing storesRevMap's revisions.\n\t * If a store in 'storesRevMap' was updated; add it to 'output' & update storesRevMap\n\t * @param storesRevMap\n\t * @param output\n\t * @param updated\n\t * @returns {*|{}}\n\t */\n\tgetRefsUpdates( refs, revMap, output ) {\n\t\trevMap = revMap || refs\n\t\t\t.map(id => (is.string(id) ? id : id.name))\n\t\t\t.map(id => (this.parseRef(id)))\n\t\t\t.reduce(( revs, ref ) => {\n\t\t\t\trevs[ref.storeId] = revs[ref.storeId] || {\n\t\t\t\t\trev : 0,\n\t\t\t\t\trefs: []\n\t\t\t\t};\n\t\t\t\trevs[ref.storeId].refs.push(ref);\n\t\t\t\treturn revs;\n\t\t\t}, {});\n\t\t\n\t\treturn this.getUpdates(revMap, output)\n\t}\n\t\n\t/**\n\t * Get or update output basing storesRevMap's revisions.\n\t * If a store in 'storesRevMap' was updated; add it to 'output' & update storesRevMap\n\t * @param storesRevMap\n\t * @param output\n\t * @param updated\n\t * @returns {*|{}}\n\t */\n\tgetUpdates( storesRevMap, output, updated ) {\n\t\toutput       = output || {};\n\t\tstoresRevMap = storesRevMap || this._getRevMap();\n\t\tObject.keys(storesRevMap).forEach(\n\t\t\tid => {\n\t\t\t\tlet store        = this.stores[id];\n\t\t\t\tstoresRevMap[id] = storesRevMap[id] || { rev: 0, refs: [] };\n\t\t\t\t\n\t\t\t\tif ( store && is.fn(store) ) {\n\t\t\t\t\tupdated    = true;\n\t\t\t\t\toutput[id] = undefined;\n\t\t\t\t}\n\t\t\t\telse if ( store && store._rev > storesRevMap[id].rev ) {\n\t\t\t\t\tstoresRevMap[id].rev = store._rev;\n\t\t\t\t\tupdated              = true;\n\t\t\t\t\tstoresRevMap[id].refs.forEach(\n\t\t\t\t\t\tref => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\toutput[ref.alias] = this.retrieve(ref.path)\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t\treturn updated && output;\n\t}\n\t\n\t/**\n\t * Recursively get all child scopes\n\t * @param childs\n\t * @returns {Array}\n\t * @private\n\t */\n\t_getAllChilds( childs = [] ) {\n\t\tchilds.push(...this._.childScopes);\n\t\tthis._.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\tctx._getAllChilds(childs);\n\t\t\t}\n\t\t);\n\t\treturn childs;\n\t}\n\t\n\t/**\n\t * Serialize all active stores state & data in every childs & mixed scopes\n\t *\n\t * Scopes without key or id are ignored\n\t * @param output\n\t * @returns {{}}\n\t */\n\tserialize( cfg = {}, output = {} ) {\n\t\tlet ctx                                  = this._._scope,\n\t\t    { baseId, key, keyPID, incrementId } = this._,\n\t\t    {\n\t\t\t    alias,\n\t\t\t    parentAlias,\n\t\t    }                                    = cfg,\n\t\t    sid                                  = key\n\t\t                                           ? (parentAlias || keyPID) + '>' + key\n\t\t                                           : alias || parentAlias && (parentAlias + '/' + baseId) || this._id;\n\t\t\n\t\t\n\t\t//alias = alias || baseId;\n\t\treturn this.serialize_ex(cfg, output, sid, alias, [\"$parent\"])\n\t}\n\t\n\tserialize_ex( cfg = {}, output = {}, sid, alias, exclude ) {\n\t\tlet _               = this._,\n\t\t    ctx             = _._scope,\n\t\t    { incrementId } = _,\n\t\t    {\n\t\t\t    withChilds = true,\n\t\t\t    withMixed  = true,\n\t\t\t    norefs,\n\t\t    }               = cfg;\n\t\t\n\t\tif ( keyWalknGet(output, sid) ) {\n\t\t\tif ( !incrementId )// done\n\t\t\t\treturn output;\n\t\t\telse if ( incrementId ) {// generate key id\n\t\t\t\tlet i = -1;\n\t\t\t\twhile ( keyWalknGet(output, sid + '[' + (++i) + ']') ) ;\n\t\t\t\tsid = sid + '[' + i + ']';\n\t\t\t}\n\t\t}\n\t\t\n\t\tkeyWalknSet(output, sid, {});\n\t\t\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( exclude.includes(id) || Scope.isStoreClass(ctx[id]) || Scope.isScopeClass(ctx[id]) )\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tctx[id].serialize({ ...cfg, parentAlias: sid }, output);\n\t\t\t}\n\t\t)\n\t\t\n\t\twithChilds && _.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.serialize({\n\t\t\t\t\t                                  withChild  : true,\n\t\t\t\t\t                                  withParents: false,\n\t\t\t\t\t                                  parentAlias: sid,\n\t\t\t\t\t                                  withMixed,\n\t\t\t\t\t                                  norefs,\n\t\t\t\t                                  }, output);\n\t\t\t}\n\t\t);\n\t\t\n\t\twithMixed && _._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.serialize({\n\t\t\t\t\t                                  withChild  : false,\n\t\t\t\t\t                                  withParents: false,\n\t\t\t\t\t                                  withMixed,\n\t\t\t\t\t                                  norefs\n\t\t\t\t                                  }, output);\n\t\t\t}\n\t\t);\n\t\t\n\t\tif ( alias ) {\n\t\t\toutput = Object.keys(output)\n\t\t\t               .reduce(\n\t\t\t\t               ( h, k ) => (\n\t\t\t\t\t               h[k === _id\n\t\t\t\t\t                 ? alias\n\t\t\t\t\t                 : k] = output[k],\n\t\t\t\t\t\t               h\n\t\t\t\t               ),\n\t\t\t\t               {}\n\t\t\t               )\n\t\t}\n\t\treturn output;\n\t}\n\t\n\t/**\n\t * Restore state & data from the serialize fn\n\t * @param snapshot\n\t * @param force\n\t */\n\trestore( snapshot, cfg = {}, force = is.bool(cfg) && cfg ) {\n\t\tlet ctx = this._._scope, snap;\n\t\t\n\t\tif ( snapshot && cfg && cfg.alias && cfg.alias != this._id ) {\n\t\t\tsnap = {\n\t\t\t\t...snapshot,\n\t\t\t\t[this._id]: snapshot[cfg.alias]\n\t\t\t}\n\t\t\tdelete snap[cfg.alias];\n\t\t\tsnapshot = snap;\n\t\t}\n\t\tsnapshot = snapshot\n\t\t\t&& keyWalknGet(snapshot, this._id)\n\t\t\t|| this.takeSnapshotByKey(this._id);\n\t\t\n\t\t\n\t\tif ( !snapshot )\n\t\t\treturn;\n\t\t\n\t\tthis._.snapshot = { ...snapshot };\n\t\t\n\t\tsnap          = snapshot['/'];\n\t\tsnapshot['/'] = { ...snap };\n\t\tsnap && Object.keys(snap).forEach(\n\t\t\tname => {\n\t\t\t\tif ( name == \"$parent\" ) return;\n\t\t\t\t\n\t\t\t\tif ( ctx[name] ) {\n\t\t\t\t\t\n\t\t\t\t\tif ( force && !is.fn(ctx[name]) )\n\t\t\t\t\t\tctx[name].destroy();\n\t\t\t\t\t\n\t\t\t\t\tthis._mount(name);// quiet\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t)\n\t\t\n\t\tthis._._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.restore(undefined, force);\n\t\t\t}\n\t\t);\n\t\t\n\t\tthis._.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.restore(undefined, force);\n\t\t\t}\n\t\t);\n\t}\n\t\n\tgetSnapshotByKey( key, local ) {\n\t\t// only have the local snap\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length))\n\t\t\treturn obj;\n\t\t}\n\t\telse return !local\n\t\t\t&& this.parent\n\t\t\t&& this.parent.getSnapshotByKey(key)\n\t\t\t||\n\t\t\tthis.stores.$parent\n\t\t\t&& this.stores.$parent.getSnapshotByKey(key);\n\t\t\n\t}\n\t\n\tgetSnapshotByKeyExt( snapshot, key, local ) {\n\t\t// only have the local snap\n\t\tif ( snapshot ) {\n\t\t\tlet obj = keyWalknGet(snapshot, key)\n\t\t\treturn obj;\n\t\t}\n\t\t\n\t}\n\t\n\ttakeSnapshotByKey( key, local ) {\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length))\n\t\t\tif ( obj ) {\n\t\t\t\tthis.deleteSnapshotByKey(key, true);\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\telse return !local\n\t\t\t&& this.parent\n\t\t\t&& this.parent.takeSnapshotByKey(key)\n\t\t\t||\n\t\t\tthis.stores.$parent\n\t\t\t&& this.stores.$parent.takeSnapshotByKey(key);\n\t}\n\t\n\tdeleteSnapshotByKey( key, local ) {\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length).replace(/^(.*[\\>|\\/])[^\\>|\\/]+$/ig, '$1'))\n\t\t\tif ( obj )\n\t\t\t\tdelete obj[key.replace(/^.*[\\>|\\/]([^\\>|\\/]+)$/ig, '$1')]\n\t\t}\n\t\treturn !local\n\t\t\t&& this.parent\n\t\t\t&& this.parent.deleteSnapshotByKey(key)\n\t\t\t||\n\t\t\tthis.stores.$parent\n\t\t\t&& this.stores.$parent.deleteSnapshotByKey(key);\n\t}\n\t\n\tsetState( pState ) {\n\t\tObject.keys(pState)\n\t\t      .forEach(k => (this.state[k] = pState[k]))\n\t}\n\t\n\t/**\n\t * get a parsed reference\n\t * @param _ref\n\t * @returns {{storeId, path, alias: *, ref: *}}\n\t */\n\tparseRef( _ref ) {\n\t\tif ( typeof _ref !== 'string' ) {// @todo : rm this\n\t\t\tthis.register({ [_ref.name]: _ref.store });\n\t\t\t_ref = _ref.name;\n\t\t}\n\t\tlet ref = _ref.split(':');\n\t\tref[0]  = ref[0].split('.');\n\t\treturn {\n\t\t\tstoreId: ref[0][0],\n\t\t\tpath   : ref[0],\n\t\t\talias  : ref[1] || ref[0][ref[0].length - 1],\n\t\t\tref    : _ref\n\t\t};\n\t}\n\t\n\t/**\n\t * Dispatch an action to the top parent & mixed scopes, in all stores\n\t *\n\t * @param action\n\t * @param data\n\t * @returns {Scope}\n\t */\n\tdispatch( action, ...argz ) {\n\t\tif ( this.dead ) {\n\t\t\tconsole.warn(\"Dispatch was called on a dead scope, check you're async functions in this stack...\", (new Error()).stack);\n\t\t\treturn;\n\t\t}\n\t\tlet bActs = this._._boundedActions;\n\t\tObject.keys(this._._scope)\n\t\t      .forEach(\n\t\t\t      id => {\n\t\t\t\t      if ( id == \"$parent\" ) return;\n\t\t\t\t      if ( !is.fn(this._._scope[id]) )\n\t\t\t\t\t      this._._scope[id].trigger(action, ...argz);\n\t\t\t      }\n\t\t      );\n\t\t\n\t\tif ( bActs && bActs.test(action) )\n\t\t\treturn this;\n\t\t\n\t\tthis._._mixed.forEach(( ctx ) => (ctx.dispatch(action, ...argz)));\n\t\tthis.parent && this.parent.dispatch(action, ...argz);\n\t\treturn this;\n\t}\n\t\n\ttrigger() {\n\t\tthis.dispatch(...arguments);\n\t}\n\t\n\t/**\n\t * once('stable', cb)\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tthen( cb ) {\n\t\tif ( !this._stable )\n\t\t\treturn this.once('stable', e => this.then(cb));\n\t\t\n\t\treturn cb(this.data);\n\t}\n\t\n\tonceStableTree( cb ) {\n\t\tif ( this._.unStableChilds )\n\t\t\treturn this.once('stableTree', e => this.onceStableTree(cb));\n\t\treturn cb(this.data);\n\t}\n\t\n\t/**\n\t * Call retain on the scoped stores basing the given list\n\t *\n\t * @param stores\n\t * @param reason\n\t */\n\tretainStores( stores = [], reason ) {\n\t\tstores.forEach(\n\t\t\tid => (this.stores[id] && this.stores[id].retain && this.stores[id].retain(reason))\n\t\t)\n\t}\n\t\n\t/**\n\t * Call retain on the scoped stores\n\t *\n\t * @param stores\n\t * @param reason\n\t */\n\tdisposeStores( stores = [], reason ) {\n\t\tstores.forEach(\n\t\t\tid => (this.stores[id] && this.stores[id].dispose && this.stores[id].dispose(reason))\n\t\t)\n\t}\n\t\n\t/**\n\t * Keep the scope unstable until release is called\n\t * @param reason\n\t */\n\twait( reason ) {\n\t\t//console.log(\"wait\", reason);\n\t\tthis._stable && !this.__locks.all && this.emit(\"unstable\", this);\n\t\tthis._stable = false;\n\t\tthis.__locks.all++;\n\t\tif ( reason ) {\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]++;\n\t\t}\n\t}\n\t\n\t/**\n\t * Stabilize the scope if no more locks remain (wait fn)\n\t * @param reason\n\t */\n\trelease( reason ) {\n\t\t\n\t\tif ( reason ) {\n\t\t\tif ( this.__locks[reason] == 0 )\n\t\t\t\tconsole.error(\"Release more than locking !\", reason);\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]--;\n\t\t}\n\t\tif ( !reason && this.__locks.all == 0 )\n\t\t\tconsole.error(\"Release more than locking !\");\n\t\t\n\t\tthis.__locks.all--;\n\t\tif ( !this.__locks.all ) {\n\t\t\tif ( this._.stabilizerTM )\n\t\t\t\treturn;\n\t\t\tthis._.stabilizerTM && clearTimeout(this._.stabilizerTM);\n\t\t\t\n\t\t\tthis._.stabilizerTM = setTimeout(\n\t\t\t\te => {\n\t\t\t\t\tthis._.stabilizerTM = null;\n\t\t\t\t\tif ( this.__locks.all )\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\t\t\t\tthis._rev++;\n\t\t\t\t\tthis._stable = true;\n\t\t\t\t\tthis.emit(\"stable\", this);\n\t\t\t\t\t\n\t\t\t\t\t!this.dead && this._propag();// stability can induce destroy\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Propag stores updates basing theirs last updates\n\t */\n\tpropag() {\n\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\tthis._.propagTM = setTimeout(\n\t\t\te => {\n\t\t\t\tthis._.propagTM = null;\n\t\t\t\tthis._propag()\n\t\t\t}, 2\n\t\t);\n\t}\n\t\n\t_propag() {\n\t\tif ( this._.followers.length )\n\t\t\tthis._.followers.forEach(( { 0: obj, 1: key, 2: as, 3: lastRevs, 3: remaps } ) => {\n\t\t\t\tlet data = this.getUpdates(lastRevs);\n\t\t\t\tif ( !data ) return;\n\t\t\t\t//console.log(data, lastRevs)\n\t\t\t\tif ( typeof obj != \"function\" ) {\n\t\t\t\t\t//console.log(\"setState \",obj, Object.keys(data))\n\t\t\t\t\tif ( as ) obj.setState({ [as]: data });\n\t\t\t\t\telse obj.setState(data);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tobj(data, lastRevs && [...lastRevs] || \"no revs\");\n\t\t\t\t}\n\t\t\t\t// lastRevs &&\n\t\t\t\t// key.forEach(id => (lastRevs[id] = this.stores[id] &&\n\t\t\t\t// this.stores[id]._rev || 0));\n\t\t\t});\n\t\tthis.emit(\"update\", this.getUpdates());\n\t}\n\t\n\t/**\n\t * is stable\n\t * @returns bool\n\t */\n\tisStable() {\n\t\treturn this._stable;\n\t}\n\t\n\t/**\n\t * is stable tree\n\t * @returns bool\n\t */\n\tisStableTree() {\n\t\treturn !this._.unStableChilds;\n\t}\n\t\n\t/**\n\t * Register children\n\t * @param scope\n\t * @private\n\t */\n\t_addChild( scope ) {\n\t\tthis._.childScopes.push(scope);\n\t\tthis._.seenChilds++;\n\t\tlet lists     = {\n\t\t\t    'stable'      : s => {\n\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    },\n\t\t\t    'unstable'    : s => {\n\t\t\t\t    this._.unStableChilds++;\n\t\t\t\t    if ( 1 == this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"unstableTree\", this)\n\t\t\t    },\n\t\t\t    'stableTree'  : s => {\n\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    },\n\t\t\t    'unstableTree': s => {\n\t\t\t\t    this._.unStableChilds++;\n\t\t\t\t    if ( 1 == this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"unstableTree\", this)\n\t\t\t    },\n\t\t\t    'destroy'     : ctx => {\n\t\t\t\t    if ( ctx._.unStableChilds )\n\t\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !ctx.isStable() )\n\t\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    }\n\t\t    },\n\t\t    wasStable = this._.unStableChilds;\n\t\t\n\t\t!scope.isStable() && this._.unStableChilds++;\n\t\tscope._.unStableChilds && this._.unStableChilds++;\n\t\tthis._.childScopesList.push(lists);\n\t\t\n\t\tif ( !wasStable && this._.unStableChilds )\n\t\t\tthis.emit(\"unstableTree\", this);\n\t\t\n\t\tscope.on(lists);\n\t}\n\t\n\t_rmChild( ctx ) {\n\t\tlet i         = this._.childScopes.indexOf(ctx),\n\t\t    wasStable = this._.unStableChilds;\n\t\tif ( i != -1 ) {\n\t\t\tthis._.childScopes.splice(i, 1);\n\t\t\t!ctx.isStable() && this._.unStableChilds--;\n\t\t\tctx._.unStableChilds && this._.unStableChilds--;\n\t\t\tctx.un(this._.childScopesList.splice(i, 1)[0]);\n\t\t\tif ( wasStable && !this._.unStableChilds )\n\t\t\t\tthis.emit(\"stableTree\")\n\t\t}\n\t}\n\t\n\tretain( reason ) {\n\t\tthis.__retains.all++;\n\t\t//console.log(\"retain\", this._id, reason);\n\t\tif ( reason ) {\n\t\t\tthis.__retains[reason] = this.__retains[reason] || 0;\n\t\t\tthis.__retains[reason]++;\n\t\t}\n\t}\n\t\n\tdispose( reason ) {\n\t\t//console.log(\"dispose\", this._id, reason);\n\t\tif ( reason ) {\n\t\t\tif ( !this.__retains[reason] )\n\t\t\t\tthrow new Error(\"Dispose more than retaining : \" + reason);\n\t\t\tthis.__retains[reason]--;\n\t\t}\n\t\t\n\t\tif ( !this.__retains.all )\n\t\t\tthrow new Error(\"Dispose more than retaining !\");\n\t\t\n\t\tthis.__retains.all--;\n\t\t\n\t\tif ( !this.__retains.all ) {\n\t\t\t//console.log(\"dispose do destroy \", this._id, this._persistenceTm);\n\t\t\tif ( this._.persistenceTm ) {\n\t\t\t\tthis._.destroyTM && clearTimeout(this._.destroyTM);\n\t\t\t\tthis._.destroyTM = setTimeout(\n\t\t\t\t\te => {\n\t\t\t\t\t\tthis.then(s => {\n\t\t\t\t\t\t\t!this.__retains.all && !this.dead && this.destroy()\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tthis._.persistenceTm\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.then(s =>\n\t\t\t\t\t          (!this.__retains.all && !this.dead && this.destroy())\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * order destroy of local stores\n\t */\n\tdestroy() {\n\t\tlet ctx = this._._scope;\n\t\t//console.warn(\"destroy\", this._id);\n\t\tthis._getAllChilds().map(scope => scope.destroy())\n\t\tfor ( let key in ctx )\n\t\t\tif ( !is.fn(ctx[key]) ) {\n\t\t\t\tif ( key == \"$parent\" ) continue;\n\t\t\t\t!ctx[key]._autoDestroy && ctx[key].dispose(\"scoped\");\n\t\t\t}\n\t\tthis._.stabilizerTM && clearTimeout(this._.stabilizerTM);\n\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\tObject.keys(\n\t\t\tthis._._listening\n\t\t).forEach(\n\t\t\tid => ((id !== \"$parent\") && this._._scope[id].removeListener(this._._listening[id]))\n\t\t);\n\t\twhile ( this._._mixedList.length ) {\n\t\t\tthis._._mixed[0].removeListener(this._._mixedList.shift());\n\t\t\tthis._._mixed.shift().dispose(\"mixedTo\");\n\t\t}\n\t\t[...this._.followers].map(follower => this.unBind(...follower));\n\t\tif ( this._._parentList ) {\n\t\t\tthis.parent._rmChild(this);\n\t\t\tthis.parent.removeListener(this._._parentList);\n\t\t\tthis.parent.dispose(\"isMyParent\");\n\t\t\tthis._._parentList = null;\n\t\t}\n\t\tthis.dead = true;\n\t\tdelete allScopes[this._id];\n\t\tthis.emit(\"destroy\", this);\n\t\t\n\t\t\n\t}\n}\n\n\nScope.isScope = function ( obj ) {\n\treturn obj instanceof Scope\n};\n\nScope.isScopeClass = function ( obj ) {\n\treturn Scope.isPrototypeOf(obj) || obj === Scope\n};\nexport default Scope;\n\n\n// WEBPACK FOOTER //\n// ./src/Scope.js","/*\n * The MIT License (MIT)\n * Copyright (c) 2019. Wise Wild Web\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n *  @author : Nathanael Braun\n *  @contact : n8tz.js@gmail.com\n */\n\nimport is from 'is';\n\nexport default class Emitter {\n\t_events = {};\n\t\n\ton( evt, cb ) {\n\t\tif ( !is.string(evt) && evt )\n\t\t\treturn Object.keys(evt).forEach(k => this.on(k, evt[k]));\n\t\t\n\t\tthis._events[evt] = this._events[evt] || [];\n\t\tthis._events[evt].push(cb);\n\t}\n\t\n\tun( evt, cb ) {\n\t\tif ( !is.string(evt) && evt )\n\t\t\treturn Object.keys(evt).forEach(k => this.un(k, evt[k]));\n\t\t\n\t\tif ( !this._events[evt] ) return;\n\t\tlet i = this._events[evt].indexOf(cb);\n\t\tthis._events[evt].splice(i, 1);\n\t}\n\t\n\temit( evt, ...argz ) {\n\t\tif ( !this._events[evt] ) return;\n\t\tlet lists = [...this._events[evt]];\n\t\t\n\t\tfor ( let i = 0; i < lists.length; i++ )\n\t\t\tlists[i](...argz)\n\t}\n\t\n\taddListener() {\n\t\tthis.on(...arguments);\n\t}\n\t\n\tremoveListener() {\n\t\tthis.un(...arguments);\n\t}\n\t\n\tremoveAllListeners() {\n\t\tthis._events = {};\n\t}\n\t\n\tonce( evt, cb ) {\n\t\tlet fn;\n\t\tthis.on(evt, fn = ( ...argz ) => {\n\t\t\tthis.un(evt, fn);\n\t\t\tcb(...argz)\n\t\t});\n\t}\n\t\n\t\n}\n\n\n// WEBPACK FOOTER //\n// ./src/utils/Emitter.js","/*\n * The MIT License (MIT)\n * Copyright (c) 2019. Wise Wild Web\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n *  @author : Nathanael Braun\n *  @contact : n8tz.js@gmail.com\n */\n\nconst is = require('is');\n\nexport function walknSet( obj, path, value, stack ) {\n\tif ( is.string(path) )\n\t\tpath = path.split('.');\n\tif ( !path.length )\n\t\treturn false;\n\telse if ( path.length == 1 )\n\t\treturn obj[path[0]] = stack\n\t\t                      ? [...(obj[path[0]] || []), value]\n\t\t                      : value;\n\telse\n\t\treturn walknSet(\n\t\t\tobj[path[0]] =\n\t\t\t\tobj[path[0]] || {},\n\t\t\tpath.slice(1),\n\t\t\tvalue, stack\n\t\t);\n}\n\nexport function walknGet( obj, path, isKey ) {\n\tif ( is.string(path) )\n\t\tpath = path.split('.');\n\treturn path.length\n\t       ? obj[path[0]] && walknGet(obj[path[0]], path.slice(1))\n\t       : obj;\n}\n\n//@todo\nexport function keyWalknSet( obj, path, value, stack ) {\n\tif ( is.string(path) )\n\t\tpath = path.split(/(\\>|\\/)/ig).filter(v => (v !== '>' && v));\n\treturn walknSet(obj, path, value);\n}\n\nexport function keyWalknGet( obj, path, isKey ) {\n\tif ( is.string(path) )\n\t\tpath = path.split(/(\\>|\\/)/ig).filter(v => (v !== '>' && v));\n\treturn path.length\n\t       ? obj[path[0]] && walknGet(obj[path[0]], path.slice(1))\n\t       : obj;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/utils/utils.js","'use strict';\nmodule.exports = require('./lib/index');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/index.js\n// module id = 6\n// module chunks = 0","'use strict';\n\nvar randomByte = require('./random/random-byte');\n\nfunction encode(lookup, number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nmodule.exports = encode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/encode.js\n// module id = 7\n// module chunks = 0","/*\n * The MIT License (MIT)\n * Copyright (c) 2019. Wise Wild Web\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n *  @author : Nathanael Braun\n *  @contact : n8tz.js@gmail.com\n */\n\nconst is                           = require('is'),\n      Scope                        = require('./Scope'),\n      { keyWalknSet, keyWalknGet } = require('./utils/utils'),\n      EventEmitter                 = require('./utils/Emitter'),\n      TaskSequencer                = require('./utils/TaskSequencer'),\n      shortid                      = require('shortid'),\n      objProto                     = Object.getPrototypeOf({});\n\nclass Store extends EventEmitter {\n\t//static use                  = [];// overridable list of source stores\n\tstatic follow;// overridable list of store that will allow push if updated\n\tstatic require;\n\tstatic staticScope   = new Scope({}, { id: \"static\" });\n\tstatic state         = undefined;// default state\n\t/**\n\t * if retain goes to 0 :\n\t * false to not destroy,\n\t * 0 to sync auto destroy\n\t * Ms to autodestroy after tm ms if no retain has been called\n\t * @type {boolean|Int}\n\t */\n\tstatic persistenceTm = false;\n\t\n\t/**\n\t * Constructor, will build a rescope store\n\t *\n\t * (scope, {require,use,apply,state, data})\n\t * (scope)\n\t *\n\t * @param scope {object} scope where to find the other stores (default : static\n\t *     staticScope )\n\t * @param keys {Array} (passed to Store::map) Ex : [\"session\", \"otherNamedStore:key\",\n\t *     otherStore.as(\"otherKey\")]\n\t */\n\tconstructor() {\n\t\tsuper();\n\t\tlet argz         = [...arguments],\n\t\t    _static      = this.constructor,\n\t\t    scope        = argz[0] instanceof Scope\n\t\t                   ? argz.shift()\n\t\t                   : _static.scope ? Scope.getScope(_static.scope)\n\t\t                                   : is.string(argz[0])\n\t\t                                     ? Scope.getScope(argz.shift())\n\t\t                                     : _static.staticScope,\n\t\t    cfg          = argz[0] && !is.array(argz[0]) && !is.string(argz[0])\n\t\t                   ? argz.shift()\n\t\t                   : {},\n\t\t    taskQueue    = is.array(argz[0]) ? argz.shift() : null,\n\t\t    name         = cfg.name || _static.name,\n\t\t    watchs       = cfg.use || [],\n\t\t    apply        = cfg.apply || null,\n\t\t    initialState = _static.state || _static.initialState || _static.defaultState;\n\t\t\n\t\tthis._uid = cfg._uid || shortid.generate();\n\t\t\n\t\tthis.__retains    = { all: 0 };\n\t\tthis.__locks      = { all: 0 };\n\t\tthis._onStabilize = [];\n\t\t\n\t\t// autoDestroyTm\n\t\tthis._autoDestroy   = !!this._persistenceTm;\n\t\tthis._persistenceTm = cfg.persistenceTm || _static.persistenceTm || (cfg.autoDestroy || _static.autoDestroy) && 5;\n\t\tthis._cfg           = cfg;\n\t\t\n\t\tif ( cfg && cfg.on ) {\n\t\t\tthis.on(cfg.on);\n\t\t}\n\t\t\n\t\tthis.name = name;\n\t\t\n\t\tif ( scope.stores ) {\n\t\t\tthis.scopeObj = scope;\n\t\t\tthis.scope    = scope.stores;\n\t\t}\n\t\telse {\n\t\t\tthis.scopeObj = new Scope(scope);\n\t\t\tthis.scope    = scope.stores;\n\t\t}\n\t\t\n\t\t// standardized scope access\n\t\tthis.$scope    = this.scopeObj;\n\t\tthis.$stores   = this.scopeObj.stores;\n\t\tthis.$actions  = this.scopeObj.actions;\n\t\tthis.$dispatch = this.scopeObj.dispatch.bind(this.scopeObj);\n\t\t\n\t\tthis._rev     = this.constructor._rev || 0;\n\t\tthis._revs    = {};\n\t\tthis.stores   = {};\n\t\tthis._require = [];\n\t\tthis._sources = [name];\n\t\t\n\t\t// register source stores\n\t\tif ( is.array(_static.use) ) {\n\t\t\tthis._use = [...watchs, ...(_static.use || []).map(\n\t\t\t\tkey => {\n\t\t\t\t\tlet ref = key.match(/^(\\!?)([^\\:]*)(?:\\:(.*))?$/);\n\t\t\t\t\tif ( ref[1] ) {\n\t\t\t\t\t\tlet ref2 = ref[2].split('.');\n\t\t\t\t\t\tthis._require.push(ref[3] || ref2[ref2.length - 1]);// require check value of the aliased\n\t\t\t\t\t                                                        // imported value\n\t\t\t\t\t\treturn key.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t)];\n\t\t}\n\t\telse {\n\t\t\tthis._use = [...watchs, ...(\n\t\t\t\t_static.use ? Object.keys(_static.use)\n\t\t\t\t                    .map(\n\t\t\t\t\t                    key => {\n\t\t\t\t\t\t                    let ref = key.match(/^(\\!?)(.*)$/);\n\t\t\t\t\t\t                    ref[1] && this._require.push(_static.use[key]);\n\t\t\t\t\t\t                    return ref[2] + ((_static.use[key] === true)\n\t\t\t\t\t\t                                     ? ''\n\t\t\t\t\t\t                                     : ':' + _static.use[key]);\n\t\t\t\t\t                    }\n\t\t\t\t                    ) : []\n\t\t\t)];\n\t\t}\n\t\t\n\t\tif ( _static.require )\n\t\t\tthis._require.push(..._static.require);\n\t\tif ( cfg.require )\n\t\t\tthis._require.push(...cfg.require);\n\t\t\n\t\tthis._followers = [];\n\t\tthis._changesSW = initialState || {};\n\t\tthis.state      = initialState && {};\n\t\t\n\t\tif ( apply )\n\t\t\tthis.apply = apply;\n\t\t\n\t\t/**\n\t\t * Initial state isn't fully initialized ( childs constructors can set it )\n\t\t * Scope based instance have taskQueue to delay init synchronously, if not\n\t\t * present we use setTimeout\n\t\t */\n\t\tif ( taskQueue ) {\n\t\t\ttaskQueue.push(this._afterConstructor.bind(this))\n\t\t}\n\t\telse\n\t\t\tsetTimeout(this._afterConstructor.bind(this))\n\t}\n\t\n\t/**\n\t * Get the incoming state ( for immediate state relative actions )\n\t * @returns {{}|*}\n\t */\n\tget nextState() {\n\t\treturn this._changesSW && { ...this.state, ...this._changesSW } || this.state;\n\t}\n\t\n\t_afterConstructor() {\n\t\tlet cfg          = this._cfg,\n\t\t    _static      = this.constructor,\n\t\t    snapshot     = this.restore(undefined, true),\n\t\t    initialState = this.state,\n\t\t    initialData  = this.data,\n\t\t    applied;\n\t\t{\n\t\t\t\n\t\t\tif ( initialData )\n\t\t\t\tthis.data = initialData;\n\t\t\telse if ( _static.data !== undefined )\n\t\t\t\tthis.data = { ..._static.data };\n\t\t\telse if ( cfg.hasOwnProperty(\"data\") )\n\t\t\t\tthis.data = cfg.data;\n\t\t\t\n\t\t\tif ( cfg.hasOwnProperty(\"state\") && cfg.state !== undefined )\n\t\t\t\tinitialState = { ...initialState, ...cfg.state };\n\t\t\t\n\t\t\tif ( this.data === undefined ) {\n\t\t\t\tif ( initialState || this._use.length ) {// sync apply\n\t\t\t\t\tthis._changesSW = {\n\t\t\t\t\t\t...this._changesSW,\n\t\t\t\t\t\t...(initialState || {}),\n\t\t\t\t\t\t...this.$scope.map(this, this._use)\n\t\t\t\t\t};\n\t\t\t\t\tthis.state      = {};\n\t\t\t\t\tif ( this.shouldApply(this._changesSW) && this.data === undefined ) {\n\t\t\t\t\t\tthis.data       = this.apply(this.data, this._changesSW, this._changesSW);\n\t\t\t\t\t\tapplied         = true;\n\t\t\t\t\t\tthis.state      = this._changesSW;\n\t\t\t\t\t\tthis._changesSW = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tapplied         = true;\n\t\t\t\tthis.state      = {// assume this state is sync with initial data\n\t\t\t\t\t...this._changesSW,\n\t\t\t\t\t...(initialState || {}),\n\t\t\t\t\t...this.$scope.map(this, this._use)\n\t\t\t\t}\n\t\t\t\tthis._changesSW = {};\n\t\t\t}\n\t\t}\n\t\tif ( (this.data !== undefined || applied) && !this.__locks.all ) {\n\t\t\tthis._stable = true;\n\t\t\tthis._rev++;\n\t\t}\n\t\telse {\n\t\t\tthis._stable = false;\n\t\t\tif ( !_static.managed && !this.state && (!this._use || !this._use.length) ) {\n\t\t\t\tconsole.warn(\"ReScope store '\", this.name, \"' have no initial data, state or use. It can't stabilize...\");\n\t\t\t}\n\t\t}\n\t\t!this._stable && this.emit('unstable', this.state);\n\t\t\n\t}\n\t\n\t/**\n\t * Overridable method to know if a data change should be propag to the listening\n\t * stores & components\n\t */\n\tshouldPropag( nDatas ) {\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Overridable method to choose if this store should be serialized,\n\t * If not it will be applied normally when restoring\n\t * @returns {boolean}\n\t */\n\tshouldSerialize() {\n\t\treturn true;\n\t}\n\t\n\thasDataChange( nDatas ) {\n\t\tlet _static = this.constructor, r,\n\t\t    cDatas  = this.data;\n\t\tr           = !cDatas && nDatas || cDatas !== nDatas;\n\t\t!r && cDatas && Object.keys(cDatas).forEach(\n\t\t\t( key ) => {\n\t\t\t\tr = r || (nDatas\n\t\t\t\t          ? cDatas[key] !== nDatas[key]\n\t\t\t\t          : cDatas && cDatas[key])\n\t\t\t}\n\t\t);\n\t\t!r && nDatas && Object.keys(nDatas).forEach(\n\t\t\t( key ) => {\n\t\t\t\tr = r || (nDatas\n\t\t\t\t          ? cDatas[key] !== nDatas[key]\n\t\t\t\t          : cDatas && cDatas[key])\n\t\t\t}\n\t\t);\n\t\treturn r;\n\t}\n\t\n\t/**\n\t * Overridable method to know if a state change should be applied\n\t */\n\tshouldApply( state = this.state ) {\n\t\tlet _static = this.constructor;\n\t\t\n\t\treturn (\n\t\t\t!!this.isComplete(state)\n\t\t) && (is.array(_static.follow)\n\t\t      ? _static.follow\n\t\t               .reduce(( r, i ) => (r || state && state[i]), false)\n\t\t      : _static.follow\n\t\t        ? Object.keys(_static.follow)\n\t\t                .reduce(( r, i ) => (\n\t\t\t                r\n\t\t\t                || state && is.fn(_static.follow[i]) && _static.follow[i].call(this, state[i])\n\t\t\t                || _static.follow[i] && state[i] !== this.state[i]\n\t\t                ), false) : true\n\t\t);\n\t}\n\t\n\t/**\n\t * Overridable applier / remapper\n\t * If state or lastPublicState are simple hash maps apply will return {...data,\n\t * ...state} if not it will return the last private state\n\t * @param data\n\t * @param state\n\t * @returns {*}\n\t */\n\tapply( data, state, changes ) {\n\t\tstate = state || this.state;\n\t\t\n\t\tif ( !data || data.__proto__ !== objProto || state.__proto__ !== objProto )\n\t\t\treturn state;\n\t\telse\n\t\t\treturn { ...data, ...state }\n\t}\n\t\n\t/**\n\t * Debounce this store propagation ( & reducing )\n\t * @param cb\n\t */\n\tstabilize( cb ) {\n\t\tcb && this.once('stable', cb);\n\t\tthis._stable && this.emit('unstable', this.state, this.data);\n\t\t\n\t\tthis._stable = false;\n\t\t\n\t\tif ( this._stabilizer )\n\t\t\treturn;\n\t\t\n\t\tthis._stabilizer = TaskSequencer.pushTask(this, 'pushState');\n\t}\n\t\n\t/**\n\t * Walk n get\n\t * @param path\n\t * @param i\n\t * @param obj\n\t * @returns {*|{}}\n\t */\n\tretrieve( path, i = 0, obj = this.data ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\treturn !obj || !path || !path.length\n\t\t       ? obj\n\t\t       : path.length == i + 1\n\t\t         ? obj[path[i]]\n\t\t         : this.retrieve(path, i + 1, obj[path[i]]);\n\t}\n\t\n\tdispatch( action, ...argz ) {\n\t\tthis.scopeObj.dispatch(action, ...argz);\n\t}\n\t\n\ttrigger( action, ...argz ) {\n\t\tlet { actions } = this.constructor;\n\t\tif ( actions && actions[action] ) {\n\t\t\tlet ns = actions[action].call(this, ...argz);\n\t\t\tns && this.setState(ns);\n\t\t}\n\t}\n\t\n\t/**\n\t * Set & Push the result data to followers if stable\n\t * @param cb\n\t */\n\tpush( data, force, cb ) {\n\t\tcb    = force === true ? cb : force;\n\t\tforce = force === true;\n\t\tif ( !force &&\n\t\t\t(\n\t\t\t\t!this.hasDataChange(data)\n\t\t\t)\n\t\t) {\n\t\t\tcb && cb();\n\t\t\tif ( !this.__locks.all ) {\n\t\t\t\tlet stable   = this._stable;\n\t\t\t\tthis._stable = true;\n\t\t\t\t!stable && this.emit('stable', this.state, this.data);\n\t\t\t\tthis._stabilizer = null;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.data = data;\n\t\tthis.wait();\n\t\tthis.release(cb);\n\t\t\n\t}\n\t\n\t/**\n\t * Call the apply fn using the current accumulated state update then, push the\n\t * resulting data if stable\n\t * @param force\n\t */\n\tpushState( force ) {\n\t\t\n\t\tif ( !force && !this._changesSW && this.data )\n\t\t\treturn;\n\t\t\n\t\tlet nextState = this._nextState || { ...this.state, ...(this._changesSW || {}) },\n\t\t    nextData  = this.apply(this.data, nextState, this._changesSW);\n\t\t\n\t\tthis._stabilizer = null;\n\t\tthis.state       = nextState;\n\t\tthis._changesSW  = null;\n\t\t\n\t\tif ( !force &&\n\t\t\t(\n\t\t\t\t!this.hasDataChange(nextData)\n\t\t\t)\n\t\t) {\n\t\t\tif ( !this.__locks.all ) {\n\t\t\t\tlet stable   = this._stable;\n\t\t\t\tthis._stable = true;\n\t\t\t\t!stable && this.emit('stable', this.state, this.data);\n\t\t\t\tthis._stabilizer = null;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.data = nextData;\n\t\tthis.wait();\n\t\tthis.release();\n\t\t\n\t}\n\t\n\t/**\n\t * Add 'pState' to the current accumulated state updates\n\t * & wait source stores stabilization before pushing these state updates\n\t * @param pState\n\t * @param cb\n\t */\n\tsetState( pState, cb, sync ) {\n\t\tlet i       = 0, change,\n\t\t    changes = this._changesSW = this._changesSW || {};\n\t\tfor ( let k in pState )\n\t\t\tif ( !this.state\n\t\t\t\t|| changes.hasOwnProperty(k)// todo\n\t\t\t\t&& (\n\t\t\t\t\tpState[k] !== changes[k]\n\t\t\t\t) || pState.hasOwnProperty(k)\n\t\t\t\t&& (\n\t\t\t\t\tpState[k] !== this.state[k]\n\t\t\t\t\t//||\n\t\t\t\t\t//(this.state[k] && pState[k] && (pState[k]._rev != this._revs[k]))// rev/hash update\n\t\t\t\t) ) {\n\t\t\t\tchange        = true;\n\t\t\t\t//this._revs[k] = pState[k] && pState[k]._rev || true;\n\t\t\t\tchanges[k]    = pState[k];\n\t\t\t}\n\t\t\n\t\tthis._nextState = { ...this.state, ...changes };\n\t\tif ( !this.shouldApply(this._nextState) ) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ( sync ) {\n\t\t\tthis.pushState();\n\t\t\tcb && cb();\n\t\t}\n\t\telse {\n\t\t\tif ( change ) {\n\t\t\t\tthis.stabilize(cb);\n\t\t\t}\n\t\t\telse cb && cb();\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Update the current state & push it\n\t * @param pState\n\t * @param cb\n\t */\n\tsetStateSync( pState ) {\n\t\tlet i       = 0, change,\n\t\t    changes = this._changesSW = this._changesSW || {};\n\t\tfor ( let k in pState )\n\t\t\tif ( !this.state || pState.hasOwnProperty(k)\n\t\t\t\t&& (\n\t\t\t\t\tpState[k] !== this.state[k]\n\t\t\t\t\t//||\n\t\t\t\t\t//(this.state[k] && pState[k] && (pState[k]._rev != this._revs[k]))// rev/hash update\n\t\t\t\t) ) {\n\t\t\t\tchange        = true;\n\t\t\t\tthis._revs[k] = pState[k] && pState[k]._rev || true;\n\t\t\t\tchanges[k]    = pState[k];\n\t\t\t}\n\t\tthis.shouldApply({ ...(this.state || {}), ...changes }) && this.pushState();\n\t\treturn this.data;\n\t}\n\t\n\t/**\n\t * get a store-key pair for Store::map\n\t * @param {string} name\n\t * @returns {{store: Store, name: *}}\n\t */\n\tas( name ) {\n\t\treturn { store: this, name };\n\t}\n\t\n\ton( lists ) {\n\t\tif ( !is.string(lists) && lists )\n\t\t\tObject.keys(lists).forEach(k => super.on(k, lists[k]));\n\t\telse super.on(...arguments);\n\t}\n\t\n\tremoveListener( lists ) {\n\t\tif ( !is.string(lists) && lists )\n\t\t\tObject.keys(lists).forEach(k => super.removeListener(k, lists[k]));\n\t\telse super.removeListener(...arguments);\n\t}\n\t\n\t/**\n\t * is complete (all requiered keys are here)\n\t * @returns bool\n\t */\n\tisComplete( state = this.state ) {\n\t\treturn (\n\t\t\t!this._require\n\t\t\t|| !this._require.length\n\t\t\t|| state && this._require.reduce(\n\t\t\t\t( r, key ) => (r && state[key]),\n\t\t\t\ttrue\n\t\t\t)\n\t\t);\n\t}\n\t\n\t/**\n\t * is stable\n\t * @returns bool\n\t */\n\tisStable() {\n\t\treturn this._stable;\n\t}\n\t\n\t/**\n\t * Serialize state & data with sources refs\n\t * @returns bool\n\t */\n\tserialize( cfg = {}, output = {} ) {\n\t\t\n\t\tlet sId        = cfg.parentAlias || this.scopeObj._id,\n\t\t    refsCount  = 0,\n\t\t    refs       =\n\t\t\t    !cfg.norefs && is.array(this._use) && this._use.reduce(\n\t\t\t    ( map, key ) => {\n\t\t\t\t    let ref   = this.$scope.parseRef(key),\n\t\t\t\t        store = this.$stores[ref.storeId];\n\t\t\t\t    if ( store && Store.isStore(store) && !store.scopeObj._.isLocalId )\n\t\t\t\t\t    refsCount++, map[ref.alias] = ref.path;\n\t\t\t\t\n\t\t\t\t    return map;\n\t\t\t    }, {}\n\t\t\t    ),\n\t\t    state      = this.state || {},\n\t\t    persistent = this.shouldSerialize();\n\t\t\n\t\tif ( !persistent ) {\n\t\t\tkeyWalknSet(\n\t\t\t\toutput,\n\t\t\t\t(sId + '/' + this.name),\n\t\t\t\t{\n\t\t\t\t\tdataRefs: cfg.dataRefs,\n\t\t\t\t\trefs\n\t\t\t\t}\n\t\t\t);\n\t\t\treturn output;\n\t\t}\n\t\t\n\t\tlet\n\t\t\tstateKeys   = Object.keys(state) || [],\n\t\t\tstateRefs   = stateKeys.map(k => state[k]),\n\t\t\tinRefsCount = 0,\n\t\t\tdataRefs    = cfg.dataRefs || {},\n\t\t\tinRefs      =\n\t\t\t\t!cfg.norefs && this.data && (Object.keys(this.data).reduce(\n\t\t\t\t( map, key ) => {\n\t\t\t\t\tlet ref = stateRefs.indexOf(this.data[key])\n\t\t\t\t\tif ( ref != -1 )\n\t\t\t\t\t\tinRefsCount++, map[key] = stateKeys[ref];\n\t\t\t\t\treturn map;\n\t\t\t\t}, {}\n\t\t\t\t)),\n\t\t\tsnap        = {\n\t\t\t\tdataRefs: cfg.dataRefs,\n\t\t\t\tstate   : state &&\n\t\t\t\t\t(\n\t\t\t\t\t\tcfg.norefs\n\t\t\t\t\t\t? { ...state }\n\t\t\t\t\t\t: Object.keys(state).reduce(( h, k ) => (!refs[k] && (h[k] = state[k]), h), {})\n\t\t\t\t\t),\n\t\t\t\tdata    : (\n\t\t\t\t\t\tthis.data &&\n\t\t\t\t\t\tthis.data.__proto__ === objProto ?\n\t\t\t\t\t\tObject\n\t\t\t\t\t\t\t.keys(this.data)\n\t\t\t\t\t\t\t.reduce(\n\t\t\t\t\t\t\t\t( h, k ) => {\n\t\t\t\t\t\t\t\t\tif ( !inRefs[k] && !dataRefs[k] ) {\n\t\t\t\t\t\t\t\t\t\th[k] = this.data[k];\n\t\t\t\t\t\t\t\t\t\tinRefsCount++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn h\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t                                 :\n\t\t\t\t\t\t(is.bool(this.data)\n\t\t\t\t\t\t\t|| is.number(this.data)\n\t\t\t\t\t\t\t|| is.string(this.data)) && this.data\n\t\t\t\t\t)\n\t\t\t\t\t|| undefined\n\t\t\t\t\n\t\t\t};\n\t\t\n\t\trefs && refsCount && (snap.refs = refs);\n\t\tinRefs && inRefsCount && (\n\t\t\tsnap.inRefs = inRefs);\n\t\t\n\t\t\n\t\tkeyWalknSet(\n\t\t\toutput,\n\t\t\t(sId + '/' + this.name),\n\t\t\tsnap\n\t\t);\n\t\treturn output;\n\t}\n\t\n\t/**\n\t * restore state & data\n\t * @returns bool\n\t */\n\trestore( snapshot, immediate ) {\n\t\tsnapshot = snapshot\n\t\t\t&& keyWalknGet(snapshot, this.scopeObj._id + '/' + this.name)\n\t\t\t|| this.$scope.takeSnapshotByKey(this.scopeObj._id + '/' + this.name);\n\t\t\n\t\tif ( !snapshot )\n\t\t\treturn;\n\t\t\n\t\tif ( snapshot ) {\n\t\t\t\n\t\t\tif ( !this.isStable() && !immediate )\n\t\t\t\tthis.then(() => restore(snapshot));\n\t\t\t\n\t\t\tthis.state = { ...snapshot.state };\n\t\t\tsnapshot.refs && Object.keys(snapshot.refs).forEach(\n\t\t\t\t( key ) => {//todo\n\t\t\t\t\tthis.state[key] = this.$scope.retrieve(snapshot.refs[key]);\n\t\t\t\t}\n\t\t\t)\n\t\t\t\n\t\t\t\n\t\t\tif ( snapshot.inRefs === true ) {\n\t\t\t\tthis.data = { ...this.state };\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.data = snapshot.data;\n\t\t\t\tsnapshot.inRefs && Object.keys(snapshot.inRefs).forEach(\n\t\t\t\t\t( key ) => {//todo\n\t\t\t\t\t\tthis.data[key] = this.state[snapshot.inRefs[key]];\n\t\t\t\t\t\t//else\n\t\t\t\t\t\t//    console.warn('not found : ', key, snap && snap.refs[ key ])\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tif ( snapshot.dataRefs ) {\n\t\t\t\tthis.data = this.data || {};\n\t\t\t\tObject.keys(snapshot.dataRefs).forEach(\n\t\t\t\t\t( key ) => {//todo\n\t\t\t\t\t\tthis.$scope.restoreRefPath(snapshot.dataRefs[key]);\n\t\t\t\t\t\tthis.data[key] = this.$scope.retrieve(snapshot.dataRefs[key]);\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\t/**\n\t * Bind this store changes to the given component-key\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tbind( obj, key, setInitial = true, path ) {\n\t\tthis._followers.push([obj, key, path]);\n\t\tif ( setInitial && this.data && this._stable ) {\n\t\t\tlet data = path ? this.retrieve(path) : this.data;\n\t\t\tif ( typeof obj != \"function\" ) {\n\t\t\t\tif ( key ) obj.setState({ [key]: data });\n\t\t\t\telse obj.setState(data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj(data);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Un bind this store off the given component-key\n\t * @param obj\n\t * @param key\n\t * @returns {Array.<*>}\n\t */\n\tunBind( obj, key, path ) {\n\t\tlet followers = this._followers,\n\t\t    i         = followers && followers.length;\n\t\twhile ( followers && i-- )\n\t\t\tif ( followers[i][0] === obj && followers[i][1] === key && followers[i][2] === path )\n\t\t\t\treturn followers.splice(i, 1);\n\t}\n\t\n\t\n\t/**\n\t * once('stable', cb)\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tthen( cb ) {\n\t\tif ( this._stable )\n\t\t\treturn cb(this.data);\n\t\tthis.once('stable', e => cb(this.data));\n\t}\n\t\n\t/**\n\t * Add a lock so the store will not propag it data untill release() is call\n\t * @param previous {Store|number|Array} @optional wf to wait, releases to wait or\n\t *     array of stuff to wait\n\t * @returns {this}\n\t */\n\twait( previous ) {\n\t\tif ( typeof previous == \"number\" )\n\t\t\treturn this.__locks.all += previous;\n\t\tif ( is.array(previous) )\n\t\t\treturn previous.map(this.wait.bind(this));\n\t\t\n\t\tthis._stable && this.emit('unstable', this.state, this.data);\n\t\tthis._stable = false;\n\t\tthis.__locks.all++;\n\t\t\n\t\tlet reason = is.string(previous) ? previous : null;\n\t\tif ( reason ) {\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]++;\n\t\t}\n\t\tif ( previous && is.fn(previous.then) ) {\n\t\t\tprevious.then(this.release.bind(this, null));\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Decrease locks for this store, if it reach 0 ,\n\t * it will be propagated to the followers,\n\t * then, all stuff passed to \"then\" call back will be exec / released\n\t * @param desync\n\t * @returns {*}\n\t */\n\trelease( reason, cb ) {\n\t\tlet _static = this.constructor, me = this;\n\t\tlet i       = 0, wasStable = this._stable;\n\t\t\n\t\tif ( is.fn(reason) ) {\n\t\t\tcb     = reason;\n\t\t\treason = null;\n\t\t}\n\t\t\n\t\tif ( reason ) {\n\t\t\tif ( this.__locks[reason] == 0 )\n\t\t\t\tconsole.error(\"Release more than locking !\", reason);\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]--;\n\t\t}\n\t\t\n\t\tif ( !reason && this.__locks.all == 0 )\n\t\t\tconsole.error(\"Release more than locking !\");\n\t\t\n\t\tif ( !--this.__locks.all && this.isComplete() ) {\n\t\t\tlet propag   = this.shouldPropag(this.data);\n\t\t\tthis._stable = true;\n\t\t\tpropag && this._rev++;//\n\t\t\tif ( propag && this._followers.length )\n\t\t\t\tthis._followers.forEach(function propag( follower ) {\n\t\t\t\t\tlet data = follower[2] ? me.retrieve(follower[2]) : me.data;\n\t\t\t\t\t//if ( !data ) return;\n\t\t\t\t\t\n\t\t\t\t\tif ( typeof follower[0] == \"function\" ) {\n\t\t\t\t\t\tfollower[0](data);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//cb && i++;\n\t\t\t\t\t\tfollower[0].setState(\n\t\t\t\t\t\t\t(follower[1]) ? { [follower[1]]: data }\n\t\t\t\t\t\t\t              : data\n\t\t\t\t\t\t\t//,\n\t\t\t\t\t\t\t//cb && (\n\t\t\t\t\t\t\t//    () => (!(--i) && cb())\n\t\t\t\t\t\t\t//)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t//else\n\t\t\t!wasStable && this.emit('stable', this.data);\n\t\t\tpropag && this.emit('update', this.data);\n\t\t\tcb && cb()\n\t\t}\n\t\telse cb && this.then(cb);\n\t\treturn this;\n\t}\n\t\n\tpropag( data ) {\n\t\tthis.emit('update', data);\n\t}\n\t\n\tretain( reason ) {\n\t\tthis.__retains.all++;\n\t\tif ( reason ) {\n\t\t\tthis.__retains[reason] = this.__retains[reason] || 0;\n\t\t\tthis.__retains[reason]++;\n\t\t}\n\t}\n\t\n\tdispose( reason ) {\n\t\t//console.warn(\"dispose\", reason, this.__retains);\n\t\tif ( reason ) {\n\t\t\tif ( !this.__retains[reason] )\n\t\t\t\tthrow new Error(\"RS : Dispose more than retaining on store '\" + this.name + \"' : \" + reason);\n\t\t\t\n\t\t\tthis.__retains[reason]--;\n\t\t}\n\t\tif ( this.__retains.all == 0 )\n\t\t\tthrow new Error(\"RS : Dispose more than retaining on store \" + this.name);\n\t\t\n\t\tthis.__retains.all--;\n\t\t\n\t\tif ( !this.__retains.all ) {\n\t\t\tif ( this._persistenceTm ) {\n\t\t\t\tthis._destroyTM && clearTimeout(this._destroyTM);\n\t\t\t\tthis._destroyTM = setTimeout(\n\t\t\t\t\te => {\n\t\t\t\t\t\tthis._destroyTM = null;\n\t\t\t\t\t\t//this.then(s => {\n\t\t\t\t\t\t!this.__retains.all && !this.dead && this.destroy()\n\t\t\t\t\t\t//});\n\t\t\t\t\t},\n\t\t\t\t\tthis._persistenceTm\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//this.then(s =>\n\t\t\t\t(!this.__retains.all && !this.dead && this.destroy())\n\t\t\t\t//);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdestroy() {\n\t\t//  console.log(\"destroy\", this._uid);\n\t\t\n\t\tthis.emit('destroy', this);\n\t\tif ( this._stabilizer )\n\t\t\tclearTimeout(this._stabilizer);\n\t\t\n\t\tif ( this._followers.length )\n\t\t\tthis._followers.forEach(\n\t\t\t\t( follower ) => {\n\t\t\t\t\tif ( typeof follower[0] !== \"function\" ) {\n\t\t\t\t\t\tif ( follower[0].stores )\n\t\t\t\t\t\t\tdelete follower[0].stores[follower[1]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\tthis._followers.length = 0;\n\t\tthis.constructor._rev  = this.rev;\n\t\tthis.dead              = true;\n\t\tthis._revs             = this.data = this.state = this.scope = null;\n\t\tthis.removeAllListeners();\n\t}\n}\n\n/**\n * get a static aliased reference of a store\n * @param {string} name\n * @returns {{store: Store, name: *}}\n */\nStore.as = function ( name ) {\n\treturn { store: this, name };\n}\n\n/**\n * @todo\n * Map all named stores in {keys} to the {object}'s state\n * Hook componentWillUnmount (for react comp) or destroy to unBind them automatically\n * @static\n * @param object {Object} target state aware object (React.Component|Store|...)\n * @param keys {Array} Ex : [\"session\", \"otherStaticNamedStore:key\",\n *     store.as('anotherKey')]\n */\nStore.map = function ( cStore, keys, scope, origin, setInitial = false ) {\n\tlet targetRevs     = cStore._revs || {};\n\tlet targetScope    = cStore.stores || (cStore.stores = {});\n\tlet initialOutputs = {};\n\tkeys               = is.array(keys) ? [...keys] : [keys];\n\t\n\t\n\tscope = scope || Store.staticScope;\n\t\n\tkeys = keys.filter(\n\t\t// @todo : use query refs\n\t\t// (store)(\\.store)*(\\[(\\*|(props)\\w+)+)\\])?(\\:alias)\n\t\t( key ) => {\n\t\t\tif ( !key ) {\n\t\t\t\tconsole.error(\"Not a mappable store item '\" + key + \"' in \" + origin + ' !!');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet name,\n\t\t\t    alias,\n\t\t\t    path,\n\t\t\t    store, _key;\n\t\t\tif ( key.store && key.name ) {\n\t\t\t\talias = name = key.name;\n\t\t\t\tstore = key.store;\n\t\t\t}\n\t\t\telse if ( is.fn(key) ) {\n\t\t\t\tname  = alias = key.name || key.defaultName;\n\t\t\t\tstore = key;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_key  = key.match(/([^\\.\\:]+)((?:\\.[^\\.\\:]+)*)(?:\\:([^\\.\\:]+))?/);\n\t\t\t\tname  = _key[1];\n\t\t\t\tpath  = _key[2] && _key[2].substr(1);\n\t\t\t\tstore = scope.stores[_key[1]];\n\t\t\t\talias = _key[3] || path && path.match(/([^\\.]*)$/)[0] || _key[1];\n\t\t\t}\n\t\t\tif ( !store ) {\n\t\t\t\tlet i = [];\n\t\t\t\tfor ( let o in scope.stores )\n\t\t\t\t\ti.push(o)\n\t\t\t\tconsole.error(\"Not a mappable store item '\" + name + \"/\" + alias + \"' in \" + (cStore.name || cStore) + ' !!', store, _key, scope.stores, i);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( Scope.isScopeClass(store) ) scope._mount(name);\n\t\t\tif ( Scope.isScope(store) ) {\n\t\t\t\tstore = scope._mount(key);\n\t\t\t}\n\t\t\telse if ( targetRevs[name] ) return false;// ignore dbl uses for now\n\t\t\t\n\t\t\t\n\t\t\tif ( is.fn(store) ) {\n\t\t\t\tscope._mount(name)\n\t\t\t\tscope.stores[name].bind(cStore, alias, setInitial, path);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstore.bind(cStore, alias, setInitial, path);\n\t\t\t}\n\t\t\t\n\t\t\t// give initial store weight basing sources\n\t\t\tscope.stores[name]._sources && cStore._sources.push(...scope.stores[name]._sources);\n\t\t\t\n\t\t\ttargetRevs[alias] = targetRevs[alias] || true;\n\t\t\t!targetScope[name] && (targetScope[name] = scope.stores[name]);\n\t\t\tif ( scope.stores[name].hasOwnProperty('data') )\n\t\t\t\tinitialOutputs[name] = scope.data[name];\n\t\t\treturn true;\n\t\t}\n\t);\n\t\n\t// ... @todo\n\tcStore.once('destroy', ( ...argz ) => {\n\t\tkeys.map(\n\t\t\t( key ) => {\n\t\t\t\tlet name,\n\t\t\t\t    alias, path,\n\t\t\t\t    store;\n\t\t\t\tif ( key.store && key.name ) {\n\t\t\t\t\talias = name = key.name;\n\t\t\t\t\tstore = key.store;\n\t\t\t\t}\n\t\t\t\telse if ( is.fn(key) ) {\n\t\t\t\t\tname  = alias = key.name || key.defaultName;\n\t\t\t\t\tstore = scope.stores[name];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey   = key.match(/([^\\.\\:]+)((?:\\.[^\\.\\:]+)*)(?:\\:([^\\.\\:]+))?/);\n\t\t\t\t\tname  = key[1];\n\t\t\t\t\tpath  = key[2] && key[2].substr(1);\n\t\t\t\t\tstore = scope.stores[key[1]];\n\t\t\t\t\talias = key[3] || path && path.match(/([^\\.]*)$/)[0] || key[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstore && !is.fn(store) && store.unBind(cStore, alias, path)\n\t\t\t}\n\t\t);\n\t})\n\t\n\treturn initialOutputs;\n};\n\n\nStore.isStore      = Scope.isStore = function ( obj ) {\n\treturn obj instanceof Store\n}\nStore.isStoreClass = Scope.isStoreClass = function ( obj ) {\n\treturn Store.isPrototypeOf(obj) || obj === Store\n}\n\nexport default Store;\n\n\n// WEBPACK FOOTER //\n// ./src/Store.js","/*\n * The MIT License (MIT)\n * Copyright (c) 2019. Wise Wild Web\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n *  @author : Nathanael Braun\n *  @contact : n8tz.js@gmail.com\n */\n\nimport is from \"is\";\n\n/**\n * Minimal push sequencer, apply stores specific task in the right order\n */\nlet taskQueue      = [],\n    curWeight      = 0,\n    maxWeight      = 0,\n    minWeight      = 0,\n    taskCount      = 0,\n    deSync         = false,\n    deSyncMaxTasks = 10,\n    task,\n    isRunning,\n    errorCatcher   = {\n        lastError: null,\n        dispatch : function ( error ) {\n            errorCatcher.disable();\n            if ( task && task[ 0 ].handleError ) {\n                task[ 0 ].handleError(error, task);\n            }\n            else if ( task )\n                console.error(\"ReScope : An apply task has failed !!\", task[ 1 ], \" on \", task[ 0 ].name || task[ 0 ].constructor.name)\n        \n            isRunning = false;\n            task      = null;\n            runNow();\n        },\n        enable   : ( typeof window !== 'undefined' )\n                   ? () => {\n                window.addEventListener('error', errorCatcher.dispatch)\n            } : () => {\n                process.on('uncaughtException', errorCatcher.dispatch);\n            },\n        disable  : ( typeof window !== 'undefined' )\n                   ? () => {\n                window.removeEventListener('error', errorCatcher.dispatch)\n            } : () => {\n                process.removeListener('uncaughtException', errorCatcher.dispatch);\n            }\n    }\n;\n\nfunction runNow() {\n    if ( !isRunning ) {\n        run();\n    }\n}\n\nfunction run() {\n    let from  = Date.now();\n    isRunning = true;\n    errorCatcher.enable();\n    while ( taskCount ) {\n        \n        // try for the current weight\n        while ( !( taskQueue[ curWeight ] && taskQueue[ curWeight ].length ) )\n            curWeight++;\n        \n        taskCount--;\n        task = taskQueue[ curWeight ].shift();\n        //console.log(\"Task : \", task[1], \" on \", task[0].name);\n        task[ 0 ][ task[ 1 ] ].apply(task[ 0 ], task[ 2 ]);\n    }\n    task = undefined;\n    errorCatcher.disable();\n    \n    isRunning = false;\n    if ( taskCount ) {\n        setTimeout(runNow);\n    }\n}\n\n//\n//index.setTaskDeSync = ( nb ) => {\n//    if ( nb === false )\n//        return deSync = false;\n//    else if ( nb === true ) {\n//        deSync         = true;\n//        deSyncMaxTasks = 10;\n//    }\n//    else (is.int(nb))\n//    {\n//        deSync         = true;\n//        deSyncMaxTasks = nb;\n//    }\n//};\n\nexport default {\n    pushTask( obj, fn, argz ) {\n        /**\n         * The more a store have sources, the more it should be processed first\n         * So leafs stores stay sync, and root stores receive merged state updates;\n         * global state stay coherent\n         *\n         * This mean whatever the number of stores & the complexity of the deps,\n         * updating a store state will update its synchrone child stores immediately\n         *\n         *\n         * @type {*|number}\n         */\n        let weight = obj._sources && obj._sources.length || 1,\n            stack  = taskQueue[ weight ] =\n                taskQueue[ weight ] || [];\n        \n        maxWeight = Math.max(maxWeight, weight);\n        curWeight = Math.min(curWeight, weight);\n        taskCount++;\n        \n        //console.log(\"Push Task : \", fn, \" on \", obj.name, weight);\n        stack.push([ obj, fn, argz ]);\n        setTimeout(runNow, 0);\n        return stack.length;\n    }\n};\n\n\n// WEBPACK FOOTER //\n// ./src/utils/TaskSequencer.js","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nvar encode = require('./encode');\nvar alphabet = require('./alphabet');\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1459707606518;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 6;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction build(clusterWorkerId) {\n\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + encode(alphabet.lookup, version);\n    str = str + encode(alphabet.lookup, clusterWorkerId);\n    if (counter > 0) {\n        str = str + encode(alphabet.lookup, counter);\n    }\n    str = str + encode(alphabet.lookup, seconds);\n\n    return str;\n}\n\nmodule.exports = build;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/build.js\n// module id = 11\n// module chunks = 0","'use strict';\nvar alphabet = require('./alphabet');\n\n/**\n * Decode the id to get the version and worker\n * Mainly for debugging and testing.\n * @param id - the shortid-generated id.\n */\nfunction decode(id) {\n    var characters = alphabet.shuffled();\n    return {\n        version: characters.indexOf(id.substr(0, 1)) & 0x0f,\n        worker: characters.indexOf(id.substr(1, 1)) & 0x0f\n    };\n}\n\nmodule.exports = decode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/decode.js\n// module id = 12\n// module chunks = 0","'use strict';\n\nvar alphabet = require('./alphabet');\nvar encode = require('./encode');\nvar decode = require('./decode');\nvar build = require('./build');\nvar isValid = require('./is-valid');\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId = require('./util/cluster-worker-id') || 0;\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet.characters(newCharacters);\n    }\n\n    return alphabet.shuffled();\n}\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n  return build(clusterWorkerId);\n}\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.decode = decode;\nmodule.exports.isValid = isValid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/index.js\n// module id = 13\n// module chunks = 0","'use strict';\nvar alphabet = require('./alphabet');\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var characters = alphabet.characters();\n    var len = id.length;\n    for(var i = 0; i < len;i++) {\n        if (characters.indexOf(id[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nmodule.exports = isShortId;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/is-valid.js\n// module id = 14\n// module chunks = 0","'use strict';\n\nvar crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto\n\nfunction randomByte() {\n    if (!crypto || !crypto.getRandomValues) {\n        return Math.floor(Math.random() * 256) & 0x30;\n    }\n    var dest = new Uint8Array(1);\n    crypto.getRandomValues(dest);\n    return dest[0] & 0x30;\n}\n\nmodule.exports = randomByte;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/random/random-byte-browser.js\n// module id = 15\n// module chunks = 0","'use strict';\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nmodule.exports = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/random/random-from-seed.js\n// module id = 16\n// module chunks = 0","'use strict';\n\nmodule.exports = 0;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shortid/lib/util/cluster-worker-id-browser.js\n// module id = 17\n// module chunks = 0"],"sourceRoot":""}