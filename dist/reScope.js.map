{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"is\"","webpack:///external \"@babel/runtime/helpers/toConsumableArray\"","webpack:///./src/utils/utils.js","webpack:///external \"@babel/runtime/helpers/defineProperty\"","webpack:///external \"@babel/runtime/helpers/assertThisInitialized\"","webpack:///external \"@babel/runtime/helpers/getPrototypeOf\"","webpack:///external \"@babel/runtime/helpers/createClass\"","webpack:///external \"@babel/runtime/helpers/classCallCheck\"","webpack:///external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack:///external \"@babel/runtime/helpers/get\"","webpack:///external \"@babel/runtime/helpers/inherits\"","webpack:///external \"shortid\"","webpack:///./src/utils/Emitter.js","webpack:///./src/Scope.js","webpack:///./src/index.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/Store.js","webpack:///./src/utils/TaskSequencer.js","webpack:///./node_modules/process/browser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","is","walknSet","obj","path","stack","string","split","length","slice","walknGet","isKey","keyWalknSet","filter","v","keyWalknGet","Emitter","_events","evt","cb","keys","forEach","k","on","this","push","un","indexOf","splice","lists","argz","arguments","fn","__proto__push","target","id","parent","_","allScopes","Scope","storesMap","upperScope","keyMap","snapshot","state","data","incrementId","persistenceTm","autoDestroy","rootEmitter","boundedActions","keyPID","_id","shortid","generate","baseId","isLocalId","register","_rev","actions","stores","_autoDestroy","constructor","dead","Error","sources","childScopes","childScopesList","unStableChilds","seenChilds","_listening","_scope","_mixed","_mixedList","followers","__retains","all","__locks","_boundedActions","array","test","includes","retain","_parentList","_propag","_stable","wait","release","restore","_addChild","setTimeout","tm","dispose","sm","applier","_refs","cpath","scopeRef","Function","Store","as","scopes","skey","sort","a","b","firstname","join","storeIdList","storeId","_mount","ref","parseRef","reduceRight","mounted","ctx","store","taskQueue","isStoreClass","shift","isScopeClass","$parent","mount","isStore","undefined","setState","isScope","_watchStore","relink","isScopable","singleton","console","warn","srcCtx","targetCtx","external","force","activeActions","__proto__","__onHotReloaded","configurable","set","_mapActions","hotReloading","act","__targetStores","dispatch","isStable","propag","__origin","lastRevs","refKeys","setInitial","revMap","map","reduce","revs","rev","refs","retainStores","getUpdates","disposeStores","refList","mixedCWUnmount","unMountKey","isReactComponent","unBind","alias","retrieve","cScope","retrieveStore","storesRevMap","local","updated","getStoresRevs","_getRevMap","output","childs","_getAllChilds","cfg","parentAlias","sid","serialize_ex","exclude","withChilds","withMixed","norefs","serialize","withChild","withParents","h","snap","bool","takeSnapshotByKey","destroy","startsWith","substr","getSnapshotByKey","deleteSnapshotByKey","replace","pState","_ref","action","bActs","trigger","once","e","then","onceStableTree","reason","emit","error","stabilizerTM","clearTimeout","propagTM","scope","wasStable","destroyTM","removeListener","follower","_rmChild","EventEmitter","isPrototypeOf","$global","window","global","RS","___rescope","g","TaskSequencer","objProto","getPrototypeOf","_static","getScope","staticScope","watchs","use","apply","initialState","defaultState","_uid","_onStabilize","_persistenceTm","_cfg","scopeObj","$scope","$stores","$actions","$dispatch","_revs","_require","_sources","_use","match","ref2","_followers","_changesSW","_nextState","_afterConstructor","applied","initialData","shouldApply","managed","nDatas","cDatas","isComplete","follow","changes","_stabilizer","pushTask","nextState","hasDataChange","stable","forcedState","nextData","sync","change","pushState","stabilize","sId","refsCount","persistent","shouldSerialize","dataRefs","stateKeys","stateRefs","inRefsCount","inRefs","number","immediate","restoreRefPath","previous","me","shouldPropag","_destroyTM","removeAllListeners","cStore","origin","targetRevs","targetScope","initialOutputs","_key","defaultName","task","isRunning","curWeight","maxWeight","taskCount","errorCatcher","lastError","disable","handleError","runNow","enable","addEventListener","process","removeEventListener","Date","now","run","weight","Math","max","min","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","marker","runClearTimeout","Item","noop","nextTick","args","Array","title","browser","env","argv","version","versions","addListener","off","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"reScope.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n","module.exports = require(\"is\");","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nconst is = require('is');\n\nexport function walknSet( obj, path, value, stack ) {\n\tif ( is.string(path) )\n\t\tpath = path.split('.');\n\tif ( !path.length )\n\t\treturn false;\n\telse if ( path.length == 1 )\n\t\treturn obj[path[0]] = stack\n\t\t                      ? [...(obj[path[0]] || []), value]\n\t\t                      : value;\n\telse\n\t\treturn walknSet(\n\t\t\tobj[path[0]] =\n\t\t\t\tobj[path[0]] || {},\n\t\t\tpath.slice(1),\n\t\t\tvalue, stack\n\t\t);\n}\n\nexport function walknGet( obj, path, isKey ) {\n\tif ( is.string(path) )\n\t\tpath = path.split('.');\n\treturn path.length\n\t       ? obj[path[0]] && walknGet(obj[path[0]], path.slice(1))\n\t       : obj;\n}\n\n//@todo\nexport function keyWalknSet( obj, path, value, stack ) {\n\tif ( is.string(path) )\n\t\tpath = path.split(/(\\>|\\/)/ig).filter(v => (v !== '>' && v));\n\treturn walknSet(obj, path, value);\n}\n\nexport function keyWalknGet( obj, path, isKey ) {\n\tif ( is.string(path) )\n\t\tpath = path.split(/(\\>|\\/)/ig).filter(v => (v !== '>' && v));\n\treturn path.length\n\t       ? obj[path[0]] && walknGet(obj[path[0]], path.slice(1))\n\t       : obj;\n}","module.exports = require(\"@babel/runtime/helpers/defineProperty\");","module.exports = require(\"@babel/runtime/helpers/assertThisInitialized\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","module.exports = require(\"@babel/runtime/helpers/get\");","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"shortid\");","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nimport is from 'is';\n\nexport default class Emitter {\n\t_events = {};\n\t\n\ton( evt, cb ) {\n\t\tif ( !is.string(evt) && evt )\n\t\t\treturn Object.keys(evt).forEach(k => this.on(k, evt[k]));\n\t\t\n\t\tthis._events[evt] = this._events[evt] || [];\n\t\tthis._events[evt].push(cb);\n\t}\n\t\n\tun( evt, cb ) {\n\t\tif ( !is.string(evt) && evt )\n\t\t\treturn Object.keys(evt).forEach(k => this.un(k, evt[k]));\n\t\t\n\t\tif ( !this._events[evt] ) return;\n\t\tlet i = this._events[evt].indexOf(cb);\n\t\tthis._events[evt].splice(i, 1);\n\t}\n\t\n\temit( evt, ...argz ) {\n\t\tif ( !this._events[evt] ) return;\n\t\tlet lists = [...this._events[evt]];\n\t\t\n\t\tfor ( let i = 0; i < lists.length; i++ )\n\t\t\tlists[i](...argz)\n\t}\n\t\n\taddListener() {\n\t\tthis.on(...arguments);\n\t}\n\t\n\tremoveListener() {\n\t\tthis.un(...arguments);\n\t}\n\t\n\tremoveAllListeners() {\n\t\tthis._events = {};\n\t}\n\t\n\tonce( evt, cb ) {\n\t\tlet fn;\n\t\tthis.on(evt, fn = ( ...argz ) => {\n\t\t\tthis.un(evt, fn);\n\t\t\tcb(...argz)\n\t\t});\n\t}\n\t\n\t\n}","/*\n * Copyright (C) 2019 Nathanael Braun\n * All rights reserved\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nimport is                                   from \"is\";\nimport shortid                              from \"shortid\";\nimport EventEmitter                         from \"./utils/Emitter\";\nimport {keyWalknGet, keyWalknSet, walknSet} from './utils/utils';\n\nconst __proto__push = ( target, id, parent ) => {\n\t      let fn       = function () {\n\t      };\n\t      fn.prototype = parent ? new parent._[id]() : target[id] || {};\n\t      target[id]   = new fn();\n\t      target._[id] = fn;\n      },\n      allScopes     = {};\n\n\n/**\n * Base Scope object\n */\nclass Scope extends EventEmitter {\n\t\n\tstatic persistenceTm = 1;// if > 0, will wait 'persistenceTm' ms before destroy when dispose reach 0\n\tstatic Store         = null;\n\tstatic scopeRef      = function scopeRef( path ) {\n\t\tthis.path = path;\n\t};\n\tstatic scopes        = allScopes;// all active scopes\n\t/**\n\t * get a parsed reference list from stateMap\n\t * @param _ref\n\t * @returns {{storeId, path, alias: *, ref: *}}\n\t */\n\tstatic stateMapToRefList( sm, state = {}, _refs = [], actions = {}, path = \"\" ) {\n\t\tlet applier;\n\t\tObject.keys(sm).forEach(\n\t\t\tkey => {\n\t\t\t\tlet cpath = path ? path + '.' + key : key;\n\t\t\t\t\n\t\t\t\tsm[key] instanceof Scope.scopeRef ?\n\t\t\t\t_refs.push(sm[key].path + ':' + cpath) :\n\t\t\t\t(sm[key] && sm[key] instanceof Function) ?\n\t\t\t\tkey === \"$apply\" ?\n\t\t\t\tapplier = sm[key] :\n\t\t\t\tactions[key] = sm[key] :\n\t\t\t\t(sm[key] && sm[key].prototype instanceof Scope.Store) ?\n\t\t\t\t_refs.push(sm[key].as(cpath)) :\n\t\t\t\t\t//key === \"$actions\" ?\n\t\t\t\t\t//Object.assign(actions, sm[key]) :\n\t\t\t\tstate[cpath] = sm[key]\n\t\t\t\t//: this.stateMapToRefList(sm[key], _refs, path + '.' + key)\n\t\t\t}\n\t\t)\n\t\treturn applier;\n\t}\n\t\n\tstatic getScope( scopes ) {\n\t\tlet skey = is.array(scopes) ? scopes.sort(( a, b ) => {\n\t\t\tif ( a.firstname < b.firstname ) return -1;\n\t\t\tif ( a.firstname > b.firstname ) return 1;\n\t\t\treturn 0;\n\t\t}).join('+') : scopes;\n\t\treturn allScopes[skey] = allScopes[skey] || new Scope({}, { id: skey });\n\t};\n\t\n\t\n\t/**\n\t * Init an RS scope\n\t *\n\t * @param storesMap {Object} Object with the initial stores definition / instances\n\t * @param config {Object} Scope config\n\t * {\n\t *     parent {scope} @optional parent scope\n\t *     upperScope {scope} @optional parent (hirarchicly) scope\n\t *\n\t *     id {string} @optional id ( if this id exist storesMap will be merge on the 'id'\n\t *     scope)\n\t *     key {string} @optional key of the scope ( if no id is set, the scope id will be (parent.id+'>'+key)\n\t *     incrementId {bool} @optional true to add a suffix id, if the provided key or id globally exist\n\t *\n\t *     keyMap {Object} @optional\n\t *\n\t *     state {Object} @optional initial state by store alias\n\t *     data {Object} @optional initial data by store alias\n\t *\n\t *     rootEmitter {bool} @optional true to not being destabilized by parent\n\t *     boundedActions {array | regexp} @optional list or regexp of actions not propagated to the parent\n\t *     autoDestroy {true | false | 'inherit'}\n\t *     persistenceTm {number) if > 0, will wait 'persistenceTm' ms before destroy when\n\t *     dispose reach 0 autoDestroy  {bool} will trigger retain & dispose after start\n\t *  }\n\t * @returns {Scope}\n\t */\n\tconstructor( storesMap, {\n\t\tparent,\n\t\tupperScope,\n\t\tkey,\n\t\tkeyMap = parent && parent.keyMap || {},\n\t\tid,\n\t\tsnapshot,\n\t\tstate,\n\t\tdata,\n\t\tincrementId = !!key,\n\t\tpersistenceTm,\n\t\tautoDestroy,\n\t\trootEmitter,\n\t\tboundedActions\n\t} = {} ) {\n\t\tsuper();\n\t\tlet _ = {\n\t\t\tkeyPID: (upperScope && upperScope._id || parent && parent._id || shortid.generate()),\n\t\t\tkey,\n\t\t\tincrementId,\n\t\t\tbaseId: id\n\t\t};\n\t\t\n\t\t\n\t\t// generate / set this scope id\n\t\tid = id || key && (_.keyPID + '>' + key);\n\t\t\n\t\t_.isLocalId = !id;\n\t\t\n\t\tid = id || (\"_____\" + shortid.generate());\n\t\tif ( keyMap[id] && incrementId ) {// generate key id\n\t\t\tlet i = -1;\n\t\t\twhile ( keyMap[id + '[' + (++i) + ']'] ) ;\n\t\t\tid = id + '[' + i + ']';\n\t\t}\n\t\tkeyMap[id]  = true;\n\t\tthis.keyMap = keyMap;\n\t\t\n\t\tif ( allScopes[id] ) {// ruse existing scope\n\t\t\tthis._id = id;\n\t\t\tif ( _.baseId ) {// specified id should merge over existing\n\t\t\t\tallScopes[id].register(storesMap);\n\t\t\t}\n\t\t\t//console.log('recycle scope !!', id);\n\t\t\treturn allScopes[id]\n\t\t}\n\t\t\n\t\t// register this scope in the static Scope.scopes\n\t\tallScopes[id] = this;\n\t\t\n\t\tthis._id  = id;\n\t\tthis._rev = 0;\n\t\t\n\t\tthis._ = _;\n\t\t\n\t\tthis.actions = {};\n\t\tthis.stores  = {};\n\t\tthis.state   = {};\n\t\tthis.data    = {};\n\t\t\n\t\tthis.parent = parent;\n\t\t\n\t\tif ( autoDestroy == 'inherit' )\n\t\t\tautoDestroy = parent && parent._autoDestroy;\n\t\t\n\t\tthis._autoDestroy = autoDestroy;\n\t\t_.persistenceTm   = persistenceTm || this.constructor.persistenceTm;\n\t\t\n\t\tif ( parent && parent.dead )\n\t\t\tthrow new Error(\"Can't use a dead scope as parent !\");\n\t\t\n\t\t__proto__push(this, 'actions', parent);\n\t\t__proto__push(this, 'stores', parent);\n\t\t__proto__push(this, 'state', parent);\n\t\t__proto__push(this, 'data', parent);\n\t\t\n\t\tthis.sources      = [];\n\t\t_.childScopes     = [];\n\t\t_.childScopesList = [];\n\t\t_.unStableChilds  = 0;\n\t\t_.seenChilds      = 0;\n\t\t_._listening      = {};\n\t\t_._scope          = {};\n\t\t_._mixed          = [];\n\t\t_._mixedList      = [];\n\t\t_.followers       = [];\n\t\t\n\t\tthis.__retains = { all: 0 };\n\t\tthis.__locks   = { all: 1 };\n\t\t\n\t\t// todo\n\t\t_._boundedActions = is.array(boundedActions)\n\t\t                    ? { test: boundedActions.includes.bind(boundedActions) }\n\t\t                    : boundedActions;\n\t\t\n\t\t// register to the parent scope\n\t\tif ( parent ) {\n\t\t\tparent.retain(\"isMyParent\");\n\t\t\tif ( !rootEmitter ) {\n\t\t\t\t!parent._stable && this.wait(\"waitingParent\");\n\t\t\t\tparent.on(_._parentList = {\n\t\t\t\t\t'stable'  : s => this.release(\"waitingParent\"),\n\t\t\t\t\t'unstable': s => this.wait(\"waitingParent\"),\n\t\t\t\t\t'update'  : s => this._propag()\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparent.on(_._parentList = {\n\t\t\t\t\t'update': s => this._propag()\n\t\t\t\t});\n\t\t\t}\n\t\t\t// this.register(parent.__scope, state, data);\n\t\t}\n\t\t\n\t\t// restore snapshots\n\t\tsnapshot && this.restore(snapshot);\n\t\t// register this scope stores\n\t\tthis.register(storesMap, state, data);\n\t\tthis.__locks.all--;\n\t\tthis._stable = !this.__locks.all;\n\t\t\n\t\tif ( parent ) {\n\t\t\tparent._addChild(this);\n\t\t}\n\t\t\n\t\t\n\t\tif ( autoDestroy )\n\t\t\tsetTimeout(\n\t\t\t\ttm => {\n\t\t\t\t\tthis.retain(\"autoDestroy\");\n\t\t\t\t\tthis.dispose(\"autoDestroy\");\n\t\t\t\t}\n\t\t\t)\n\t\t\n\t}\n\t\n\t/**\n\t *\n\t * Mount the stores in storesList, in this scope or in its parents or mixed scopes\n\t *\n\t * @param storeIdList {string|storeRef} Store name, Array of Store names, or Rescope\n\t *     store ref from Store::as or Store:as\n\t * @param state\n\t * @param data\n\t * @returns {Scope}\n\t */\n\tmount( storeIdList, snapshot, state, data ) {\n\t\tif ( is.array(storeIdList) ) {\n\t\t\tstoreIdList.forEach(storeId => this._mount(storeId, snapshot, state, data));\n\t\t}\n\t\telse {\n\t\t\tthis._mount(...arguments);\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t_mount( id, snapshot, state, data ) {\n\t\tlet ref, _ = this._;\n\t\t\n\t\tref = this.parseRef(id)\n\t\t\n\t\tif ( id == \"$parent\" ) return;\n\t\tif ( !_._scope[ref.storeId] ) {//ask mixed || parent\n\t\t\tif ( _._mixed.reduceRight(( mounted, ctx ) => (mounted || ctx._mount(id, snapshot, state, data)), false) ||\n\t\t\t\t!this.parent )\n\t\t\t\treturn;\n\t\t\treturn this.parent._mount(...arguments);\n\t\t}\n\t\telse {\n\t\t\tlet store = _._scope[ref.storeId], taskQueue = [];\n\t\t\tif ( Scope.isStoreClass(store) ) {\n\t\t\t\t_._scope[ref.storeId] = new store(this, {\n\t\t\t\t\t//snapshot,\n\t\t\t\t\tname: ref.storeId,\n\t\t\t\t\tstate,\n\t\t\t\t\tdata\n\t\t\t\t}, taskQueue);\n\t\t\t\twhile ( taskQueue.length ) taskQueue.shift()();\n\t\t\t}\n\t\t\telse if ( Scope.isScopeClass(store) ) {\n\t\t\t\tstore = _._scope[ref.storeId] = new store({ $parent: this }, {\n\t\t\t\t\tkey        : ref.storeId,\n\t\t\t\t\tincrementId: true,\n\t\t\t\t\tupperScope : this\n\t\t\t\t});\n\t\t\t\tif ( ref.path.length > 1 )\n\t\t\t\t\t_._scope[ref.storeId].mount(ref.path.slice(1).join('.'), snapshot, state, data)\n\t\t\t}\n\t\t\tif ( Scope.isStore(store) ) {\n\t\t\t\tif ( state !== undefined && data === undefined )\n\t\t\t\t\tstore.setState(state);\n\t\t\t\telse if ( state !== undefined )\n\t\t\t\t\tstore.state = state;\n\t\t\t\t\n\t\t\t\tif ( data !== undefined )\n\t\t\t\t\tstore.push(data);\n\t\t\t}\n\t\t\tif ( Scope.isScope(store) ) {\n\t\t\t\tif ( state !== undefined )\n\t\t\t\t\tstore.setState(state);\n\t\t\t\tif ( ref.path.length > 1 )\n\t\t\t\t\tstore._mount(ref.path.slice(1).join('.'))\n\t\t\t}\n\t\t\tthis._watchStore(ref.storeId);\n\t\t}\n\t\t\n\t\t\n\t\treturn _._scope[ref.storeId];\n\t}\n\t\n\tresetKeys() {\n\t\tfor ( let key in this.keyMap )\n\t\t\tif ( this.keyMap.hasOwnProperty(key) )\n\t\t\t\tdelete this.keyMap[key];\n\t}\n\t\n\t/**\n\t * Register stores in storesMap & link them in the protos\n\t * @param storesMap\n\t * @param state\n\t * @param data\n\t */\n\tregister( storesMap, state = {}, data = {} ) {\n\t\tthis.relink(storesMap, this, false, false);\n\t\tObject.keys(storesMap).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id === \"$parent\" ) return;\n\t\t\t\t\n\t\t\t\tif ( !Scope.isScopable(storesMap[id]) )\n\t\t\t\t\treturn console.warn(\"RS: \", this._id, \", can't register not scopable object :\", id);\n\t\t\t\t\n\t\t\t\tif ( storesMap[id].singleton || (is.fn(storesMap[id]) && (state[id] || data[id])) ) {\n\t\t\t\t\tthis._mount(id, undefined, state[id], data[id])\n\t\t\t\t}\n\t\t\t\telse if ( state[id] || data[id] ) {\n\t\t\t\t\tif ( data[id] ) {\n\t\t\t\t\t\tif ( state[id] )\n\t\t\t\t\t\t\tthis.stores[id].state = state[id];\n\t\t\t\t\t\tthis.stores[id].push(data[id]);\n\t\t\t\t\t}\n\t\t\t\t\telse if ( state[id] ) {\n\t\t\t\t\t\tthis.stores[id].setState(state[id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._watchStore(id);\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t\t\n\t}\n\t\n\t/**\n\t * Map srcCtx store's on targetCtx headers proto's\n\t * @param srcCtx\n\t * @param targetCtx\n\t * @param state\n\t * @param data\n\t */\n\trelink( srcCtx, targetCtx = this, external, force ) {\n\t\tlet _ = this._, me = this;\n\t\tObject.keys(srcCtx)\n\t\t      .forEach(\n\t\t\t      id => {\n\t\t\t\t      let hotReloading, actions, activeActions;\n\t\t\t\t\n\t\t\t\t      // same store def : ignore\n\t\t\t\t      if ( !force && targetCtx._._scope[id] === srcCtx[id] ||\n\t\t\t\t\t      targetCtx._._scope[id] && (targetCtx._._scope[id].constructor === srcCtx[id]) )\n\t\t\t\t\t      return;\n\t\t\t\t\n\t\t\t\t      // hot switch\n\t\t\t\t      if ( !force && targetCtx._._scope[id] ) {\n\t\t\t\t\t\n\t\t\t\t\t      if ( !external && !is.fn(targetCtx._._scope[id]) ) {// mounted store\n\t\t\t\t\t\t      targetCtx._._scope[id].__proto__ = srcCtx[id].prototype;\n\t\t\t\t\t\t      targetCtx._._scope[id].__onHotReloaded\n\t\t\t\t\t\t      && targetCtx._._scope[id].__onHotReloaded(srcCtx[id]);\n\t\t\t\t\t      }\n\t\t\t\t\t      else if ( !external && is.fn(targetCtx._._scope[id]) )\n\t\t\t\t\t\t      targetCtx._._scope[id] = srcCtx[id];\n\t\t\t\t\t\n\t\t\t\t      }\n\t\t\t\t      else if ( !force && !external )\n\t\t\t\t\t      _._scope[id] = srcCtx[id];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t      // map the store id\n\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t      targetCtx._.stores.prototype,\n\t\t\t\t\t      id,\n\t\t\t\t\t      {\n\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t      get         : () => _._scope[id]\n\t\t\t\t\t      }\n\t\t\t\t      );\n\t\t\t\t\n\t\t\t\t      activeActions = targetCtx._.actions.prototype;\n\t\t\t\t      // not mapping hierarchic scopes\n\t\t\t\t      if ( id !== \"$parent\" ) {\n\t\t\t\t\t      // map state & data\n\t\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t\t      targetCtx._.state.prototype,\n\t\t\t\t\t\t      id,\n\t\t\t\t\t\t      {\n\t\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t\t      get         : () => (_._scope[id] && _._scope[id].state),\n\t\t\t\t\t\t\t      set         : ( v ) => (this._mount(id, undefined, v))\n\t\t\t\t\t\t      }\n\t\t\t\t\t      );\n\t\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t\t      targetCtx._.data.prototype,\n\t\t\t\t\t\t      id,\n\t\t\t\t\t\t      {\n\t\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t\t      get         : () => (_._scope[id] && _._scope[id].data),\n\t\t\t\t\t\t\t      set         : ( v ) => (this._mount(id, undefined, undefined, v))\n\t\t\t\t\t\t      }\n\t\t\t\t\t      );\n\t\t\t\t\t      // action mapping\n\t\t\t\t\t      actions = srcCtx[id] instanceof Scope.Store\n\t\t\t\t\t                ? srcCtx[id].constructor.actions\n\t\t\t\t\t                : srcCtx[id].actions;\n\t\t\t\t\t\n\t\t\t\t\t      if ( Scope.isScopeClass(_._scope[id]) )\n\t\t\t\t\t\t      this._mount(id);\n\t\t\t\t\t\n\t\t\t\t\t      if ( Scope.isScope(_._scope[id]) ) {// map hierarchic scopes\n\t\t\t\t\t\t      if ( activeActions[id] )\n\t\t\t\t\t\t\t      console.warn(\"RS : Sub scope actions is mapped over an existing function !\", id);\n\t\t\t\t\t\t\n\t\t\t\t\t\t      activeActions[id] = _._scope[id].actions;\n\t\t\t\t\t      }\n\t\t\t\t\t      else if ( !Scope.isStore(_._scope[id]) && !Scope.isStoreClass(_._scope[id]) )\n\t\t\t\t\t\t      return;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t      actions &&\n\t\t\t\t\t      this._mapActions(actions, activeActions, id)\n\t\t\t\t      }\n\t\t\t\t      else {\n\t\t\t\t\t      activeActions[id] = srcCtx[id].actions;\n\t\t\t\t      }\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t      // remount the store if it was hot reloaded\n\t\t\t\t      if ( hotReloading )\n\t\t\t\t\t      this._mount(id, null, hotReloading);\n\t\t\t      }\n\t\t      )\n\t}\n\t\n\t/**\n\t * Map & bounds actions from stores\n\t * todo : unmap actions\n\t * @param actions\n\t * @param target\n\t * @param storeId\n\t * @private\n\t */\n\t_mapActions( actions, target, storeId ) {\n\t\tfor ( let act in actions ) {\n\t\t\tif ( actions.hasOwnProperty(act) ) {\n\t\t\t\tif ( is.object(actions[act]) ) {// hirarchised actions\n\t\t\t\t\t\n\t\t\t\t\tif ( target[act] && !is.object(target[act]) )\n\t\t\t\t\t\tconsole.warn(\"RS : Actions namespace is mapped over an existing function !\", storeId, act);\n\t\t\t\t\t\n\t\t\t\t\ttarget[act] = target[act] || { __targetStores: 0 };\n\t\t\t\t\tthis._mapActions(actions[act], target[act]);\n\t\t\t\t\ttarget[act].__targetStores++;\n\t\t\t\t}\n\t\t\t\telse if ( target.hasOwnProperty(act) )\n\t\t\t\t\ttarget[act].__targetStores++;\n\t\t\t\telse {\n\t\t\t\t\tif ( is.object(target[act]) )\n\t\t\t\t\t\tconsole.warn(\"RS : Action is mapped over existing namespace  !\", storeId, act);\n\t\t\t\t\ttarget[act]                = this.dispatch.bind(this, act);\n\t\t\t\t\ttarget[act].__targetStores = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Make this scope watching the local store 'id'\n\t * @param id\n\t * @returns {boolean}\n\t * @private\n\t */\n\t_watchStore( id ) {\n\t\tlet _ = this._;\n\t\tif ( !_._listening[id] && !is.fn(_._scope[id]) ) {\n\t\t\t!_._scope[id]._autoDestroy && _._scope[id].retain(\"scoped\");\n\t\t\t!_._scope[id].isStable() && this.wait(id);\n\t\t\t_._scope[id].on(\n\t\t\t\t_._listening[id] = {\n\t\t\t\t\t'destroy' : s => {\n\t\t\t\t\t\tdelete _._listening[id];\n\t\t\t\t\t\t_._scope[id] = _._scope[id].constructor;\n\t\t\t\t\t},\n\t\t\t\t\t'update'  : s => this.propag(),\n\t\t\t\t\t'stable'  : s => this.release(id),\n\t\t\t\t\t'unstable': s => this.wait(id)\n\t\t\t\t});\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Mix targetCtx on this scope\n\t * Mixed scope parents are NOT mapped\n\t * @param targetCtx\n\t */\n\tmixin( targetCtx ) {\n\t\tlet parent = this.parent,\n\t\t    lists,\n\t\t    _      = this._;\n\t\t\n\t\t_._mixed.push(targetCtx);\n\t\t\n\t\ttargetCtx.retain(\"mixedTo\");\n\t\t\n\t\tif ( !targetCtx._stable )\n\t\t\tthis.wait(targetCtx._id);\n\t\t\n\t\t_._mixedList.push(lists = {\n\t\t\t'stable'  : s => this.release(targetCtx._id),\n\t\t\t'unstable': s => this.wait(targetCtx._id),\n\t\t\t'update'  : s => this._propag()\n\t\t});\n\t\t\n\t\ttargetCtx.on(lists);\n\t\t\n\t\t// reset protos\n\t\t// push new proto with parent\n\t\t__proto__push(this, 'actions', parent);\n\t\t__proto__push(this, 'stores', parent);\n\t\t__proto__push(this, 'state', parent);\n\t\t__proto__push(this, 'data', parent);\n\t\t\n\t\t// bind local accessors in the new proto\n\t\tthis.relink(_._scope, this, false, true);\n\t\t\n\t\t_._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t// push protos\n\t\t\t\t__proto__push(this, 'actions');\n\t\t\t\t__proto__push(this, 'stores');\n\t\t\t\t__proto__push(this, 'state');\n\t\t\t\t__proto__push(this, 'data');\n\t\t\t\tthis.stores.__origin = \"mixed \" + ctx._id;\n\t\t\t\t// write mixed accessors\n\t\t\t\tctx.relink(ctx._._scope, this, true, true)\n\t\t\t}\n\t\t)\n\t}\n\t\n\t/**\n\t * Bind stores from this scope, his parents or mixed scopes to obj\n\t *\n\t * @param target {React.Component|Store|function}\n\t * @param key {string} stores keys to bind updates\n\t * @param as\n\t * @param setInitial {boolean} false to not propag initial value (default : true)\n\t */\n\tbind( target, key, as, setInitial = true, revMap = {} ) {\n\t\tlet lastRevs, data, refKeys;\n\t\tif ( key && !is.array(key) )\n\t\t\tkey = [key];\n\t\t\n\t\tif ( as === false || as === true ) {\n\t\t\tsetInitial = as;\n\t\t\tas         = null;\n\t\t}\n\t\t\n\t\trefKeys = key\n\t\t\t.map(id => (is.string(id) ? id : id.name))\n\t\t\t.map(id => (this.parseRef(id)));\n\t\t\n\t\t\n\t\tthis._.followers.push(\n\t\t\t[\n\t\t\t\ttarget,\n\t\t\t\tkey,\n\t\t\t\tas || undefined,\n\t\t\t\tlastRevs = refKeys.reduce(( revs, ref ) => {\n\t\t\t\t\trevs[ref.storeId] = revs[ref.storeId] || {\n\t\t\t\t\t\trev : 0,\n\t\t\t\t\t\trefs: []\n\t\t\t\t\t};\n\t\t\t\t\trevs[ref.storeId].refs.push(ref);\n\t\t\t\t\treturn revs;\n\t\t\t\t}, revMap)\n\t\t\t]);\n\t\t\n\t\tthis.mount(key);\n\t\tthis.retainStores(Object.keys(lastRevs), 'listeners');\n\t\t\n\t\tif ( setInitial && this._stable ) {\n\t\t\tdata = this.getUpdates(lastRevs);\n\t\t\tif ( !data ) return this;\n\t\t\tif ( typeof target != \"function\" ) {\n\t\t\t\tif ( as ) target.setState({ [as]: data });\n\t\t\t\telse target.setState(data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttarget(data);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Un bind this scope off the given component-keys\n\t * @param target\n\t * @param key\n\t * @returns {Array.<*>}\n\t */\n\tunBind( target, key, as ) {\n\t\tlet followers = this._.followers,\n\t\t    i         = followers && followers.length;\n\t\twhile ( followers && i-- )\n\t\t\tif ( followers[i][0] === target &&\n\t\t\t\t('' + followers[i][1]) == ('' + key) &&\n\t\t\t\tfollowers[i][2] == as ) {\n\t\t\t\tthis.disposeStores(Object.keys(followers[i][3]), 'listeners');\n\t\t\t\treturn followers.splice(i, 1);\n\t\t\t}\n\t}\n\t\n\t/**\n\t * Mount the stores in storeIdList from this scope, its parents and mixed scope\n\t * Bind them to 'to'\n\t * Hook 'to' so it will auto unbind on 'destroy' or 'componentWillUnmount'\n\t * @param target\n\t * @param storeIdList\n\t * @param bind\n\t * @returns {Object} Initial outputs of the stores in 'storesList'\n\t */\n\tmap( target, storeIdList, bind = true, revMap ) {\n\t\tlet Store   = this.constructor.Store;\n\t\tstoreIdList = is.array(storeIdList) ? storeIdList : [storeIdList];\n\t\tlet refList = storeIdList.map(this.parseRef);\n\t\tthis.mount(storeIdList);\n\t\tif ( bind && target instanceof Store ) {\n\t\t\tStore.map(target, storeIdList, this, this, false)\n\t\t}\n\t\telse if ( bind ) {\n\t\t\tthis.bind(target, storeIdList, undefined, false);\n\t\t\t\n\t\t\tlet mixedCWUnmount,\n\t\t\t    unMountKey = target.isReactComponent ? \"componentWillUnmount\" : \"destroy\";\n\t\t\t\n\t\t\tif ( target.hasOwnProperty(unMountKey) ) {\n\t\t\t\tmixedCWUnmount = target[unMountKey];\n\t\t\t}\n\t\t\t\n\t\t\ttarget[unMountKey] = ( ...argz ) => {\n\t\t\t\tdelete target[unMountKey];\n\t\t\t\tif ( mixedCWUnmount )\n\t\t\t\t\ttarget[unMountKey] = mixedCWUnmount;\n\t\t\t\t\n\t\t\t\tthis.unBind(target, storeIdList);\n\t\t\t\treturn target[unMountKey] && target[unMountKey](...argz);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn revMap && this.getUpdates(revMap)\n\t\t\t|| refList.reduce(( data, ref ) => {\n\t\t\t\twalknSet(data, ref.alias || ref.path, this.retrieve(ref.path))\n\t\t\t\treturn data;\n\t\t\t}, {});\n\t}\n\t\n\t/**\n\t * Get current data value from json path\n\t * @param path\n\t * @returns {string|*}\n\t */\n\tretrieve( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\t\n\t\t\n\t\treturn path &&\n\t\t\tthis.stores[path[0]] &&\n\t\t\tthis.stores[path[0]].retrieve &&\n\t\t\tthis.stores[path[0]].retrieve(path.slice(1));\n\t}\n\t\n\t/**\n\t * Restore all nodes in a jsonPath\n\t * @param path\n\t * @returns {string|*}\n\t */\n\trestoreRefPath( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\t\n\t\tlet obj, i = 0, cScope = this;\n\t\t\n\t\twhile ( i < path.length ) {\n\t\t\tobj = cScope.stores[path[i]];\n\t\t\tif ( Scope.isScopeClass(obj)\n\t\t\t\t||\n\t\t\t\tScope.isStoreClass(obj) ) {\n\t\t\t\tcScope.mount(path[0]);\n\t\t\t\tobj = cScope.stores[path[i]];\n\t\t\t}\n\t\t\t\n\t\t\tif ( Scope.isScope(obj) ) {\n\t\t\t\tcScope = obj;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if ( Scope.isStore(obj) ) {\n\t\t\t\tobj.restore();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Get target store from json path\n\t * @param path\n\t * @returns {string|*}\n\t */\n\tretrieveStore( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\treturn path\n\t\t\t&& path.length\n\t\t\t&& (\n\t\t\t\tpath.length != 1 && this.stores[path[0]].retrieveStore\n\t\t\t\t? this.stores[path[0]].retrieveStore(path.slice(1))\n\t\t\t\t: path.length == 1 && this.stores[path[0]]\n\t\t\t);\n\t}\n\t\n\t/**\n\t * Get or update stores revisions in 'storesRevMap'\n\t * @param storesRevMap\n\t * @param local\n\t * @returns {{}}\n\t */\n\tgetStoresRevs( storesRevMap = {}, local ) {\n\t\tlet ctx = this._._scope;\n\t\tif ( !storesRevMap ) {\n\t\t\tstoresRevMap = {};\n\t\t}\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id == \"$parent\" ) return;\n\t\t\t\tif ( !is.fn(ctx[id])\n\t\t\t\t) {\n\t\t\t\t\tstoresRevMap[id] = ctx[id]._rev;\n\t\t\t\t}\n\t\t\t\telse if ( !storesRevMap.hasOwnProperty(id) )\n\t\t\t\t\tstoresRevMap[id] = false\n\t\t\t}\n\t\t);\n\t\tif ( !local ) {\n\t\t\tthis._._mixed.reduce(( updated, ctx ) => (ctx.getStoresRevs(storesRevMap), storesRevMap), storesRevMap);\n\t\t\tthis.parent && this.parent.getStoresRevs(storesRevMap);\n\t\t}\n\t\treturn storesRevMap;\n\t}\n\t\n\t/**\n\t * Recursively get all stores revs\n\t * @param childs\n\t * @returns {Array}\n\t * @private\n\t */\n\t_getRevMap( storesRevMap = {} ) {\n\t\tlet ctx = this._._scope;\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id === \"$parent\" || storesRevMap[id] ) return;\n\t\t\t\tstoresRevMap[id] = { rev: ctx[id]._rev, refs: [] };\n\t\t\t\t\n\t\t\t});\n\t\tthis._._mixed.reduceRight(\n\t\t\t( storesRevMap, ctx ) => (ctx._getRevMap(storesRevMap)), storesRevMap);\n\t\tthis.parent && this.parent._getRevMap(storesRevMap);\n\t\treturn storesRevMap;\n\t}\n\t\n\t/**\n\t * Get updated output basing storesRevMap's revisions.\n\t * If a store in 'storesRevMap' was updated; add it to 'output' & update storesRevMap\n\t * @param storesRevMap\n\t * @param output\n\t * @param updated\n\t * @returns {*|{}}\n\t */\n\tgetRefsUpdates( refs, revMap, output ) {\n\t\trevMap = revMap || refs\n\t\t\t.map(id => (is.string(id) ? id : id.name))\n\t\t\t.map(id => (this.parseRef(id)))\n\t\t\t.reduce(( revs, ref ) => {\n\t\t\t\trevs[ref.storeId] = revs[ref.storeId] || {\n\t\t\t\t\trev : 0,\n\t\t\t\t\trefs: []\n\t\t\t\t};\n\t\t\t\trevs[ref.storeId].refs.push(ref);\n\t\t\t\treturn revs;\n\t\t\t}, {});\n\t\t\n\t\treturn this.getUpdates(revMap, output)\n\t}\n\t\n\t/**\n\t * Get or update output basing storesRevMap's revisions.\n\t * If a store in 'storesRevMap' was updated; add it to 'output' & update storesRevMap\n\t * @param storesRevMap\n\t * @param output\n\t * @param updated\n\t * @returns {*|{}}\n\t */\n\tgetUpdates( storesRevMap, output, updated ) {\n\t\toutput       = output || {};\n\t\tstoresRevMap = storesRevMap || this._getRevMap();\n\t\tObject.keys(storesRevMap).forEach(\n\t\t\tid => {\n\t\t\t\tlet store        = this.stores[id];\n\t\t\t\tstoresRevMap[id] = storesRevMap[id] || { rev: 0, refs: [] };\n\t\t\t\t\n\t\t\t\tif ( store && is.fn(store) ) {\n\t\t\t\t\tupdated    = true;\n\t\t\t\t\toutput[id] = undefined;\n\t\t\t\t}\n\t\t\t\telse if ( store && store._rev > storesRevMap[id].rev ) {\n\t\t\t\t\tstoresRevMap[id].rev = store._rev;\n\t\t\t\t\tupdated              = true;\n\t\t\t\t\tstoresRevMap[id].refs.forEach(\n\t\t\t\t\t\tref => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\toutput[ref.alias] = this.retrieve(ref.path)\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t\treturn updated && output;\n\t}\n\t\n\t/**\n\t * Recursively get all child scopes\n\t * @param childs\n\t * @returns {Array}\n\t * @private\n\t */\n\t_getAllChilds( childs = [] ) {\n\t\tchilds.push(...this._.childScopes);\n\t\tthis._.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\tctx._getAllChilds(childs);\n\t\t\t}\n\t\t);\n\t\treturn childs;\n\t}\n\t\n\t/**\n\t * Serialize all active stores state & data in every childs & mixed scopes\n\t *\n\t * Scopes without key or id are ignored\n\t * @param output\n\t * @returns {{}}\n\t */\n\tserialize( cfg = {}, output = {} ) {\n\t\tlet ctx                                  = this._._scope,\n\t\t    { baseId, key, keyPID, incrementId } = this._,\n\t\t    {\n\t\t\t    alias,\n\t\t\t    parentAlias,\n\t\t    }                                    = cfg,\n\t\t    sid                                  = key\n\t\t                                           ? (parentAlias || keyPID) + '>' + key\n\t\t                                           : alias || parentAlias && (parentAlias + '/' + baseId) || this._id;\n\t\t\n\t\t\n\t\t//alias = alias || baseId;\n\t\treturn this.serialize_ex(cfg, output, sid, alias, [\"$parent\"])\n\t}\n\t\n\tserialize_ex( cfg = {}, output = {}, sid, alias, exclude ) {\n\t\tlet _               = this._,\n\t\t    ctx             = _._scope,\n\t\t    { incrementId } = _,\n\t\t    {\n\t\t\t    withChilds = true,\n\t\t\t    withMixed  = true,\n\t\t\t    norefs,\n\t\t    }               = cfg;\n\t\t\n\t\tif ( keyWalknGet(output, sid) ) {\n\t\t\tif ( !incrementId )// done\n\t\t\t\treturn output;\n\t\t\telse if ( incrementId ) {// generate key id\n\t\t\t\tlet i = -1;\n\t\t\t\twhile ( keyWalknGet(output, sid + '[' + (++i) + ']') ) ;\n\t\t\t\tsid = sid + '[' + i + ']';\n\t\t\t}\n\t\t}\n\t\t\n\t\tkeyWalknSet(output, sid, {});\n\t\t\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( exclude.includes(id) || Scope.isStoreClass(ctx[id]) || Scope.isScopeClass(ctx[id]) )\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tctx[id].serialize({ ...cfg, parentAlias: sid }, output);\n\t\t\t}\n\t\t)\n\t\t\n\t\twithChilds && _.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.serialize({\n\t\t\t\t\t                                  withChild  : true,\n\t\t\t\t\t                                  withParents: false,\n\t\t\t\t\t                                  parentAlias: sid,\n\t\t\t\t\t                                  withMixed,\n\t\t\t\t\t                                  norefs,\n\t\t\t\t                                  }, output);\n\t\t\t}\n\t\t);\n\t\t\n\t\twithMixed && _._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.serialize({\n\t\t\t\t\t                                  withChild  : false,\n\t\t\t\t\t                                  withParents: false,\n\t\t\t\t\t                                  withMixed,\n\t\t\t\t\t                                  norefs\n\t\t\t\t                                  }, output);\n\t\t\t}\n\t\t);\n\t\t\n\t\tif ( alias ) {\n\t\t\toutput = Object.keys(output)\n\t\t\t               .reduce(\n\t\t\t\t               ( h, k ) => (\n\t\t\t\t\t               h[k === this._id\n\t\t\t\t\t                 ? alias\n\t\t\t\t\t                 : k] = output[k],\n\t\t\t\t\t\t               h\n\t\t\t\t               ),\n\t\t\t\t               {}\n\t\t\t               )\n\t\t}\n\t\treturn output;\n\t}\n\t\n\t/**\n\t * Restore state & data from the serialize fn\n\t * @param snapshot\n\t * @param force\n\t */\n\trestore( snapshot, cfg = {}, force = is.bool(cfg) && cfg ) {\n\t\tlet ctx = this._._scope, snap;\n\t\t\n\t\tif ( snapshot && cfg && cfg.alias && cfg.alias != this._id ) {\n\t\t\tsnap = {\n\t\t\t\t...snapshot,\n\t\t\t\t[this._id]: snapshot[cfg.alias]\n\t\t\t}\n\t\t\tdelete snap[cfg.alias];\n\t\t\tsnapshot = snap;\n\t\t}\n\t\tsnapshot = snapshot\n\t\t\t&& keyWalknGet(snapshot, this._id)\n\t\t\t|| this.takeSnapshotByKey(this._id);\n\t\t\n\t\t\n\t\tif ( !snapshot )\n\t\t\treturn;\n\t\t\n\t\tthis._.snapshot = { ...snapshot };\n\t\t\n\t\tsnap          = snapshot['/'];\n\t\tsnapshot['/'] = { ...snap };\n\t\tsnap && Object.keys(snap).forEach(\n\t\t\tname => {\n\t\t\t\tif ( name == \"$parent\" ) return;\n\t\t\t\t\n\t\t\t\tif ( ctx[name] ) {\n\t\t\t\t\t\n\t\t\t\t\tif ( force && !is.fn(ctx[name]) )\n\t\t\t\t\t\tctx[name].destroy();\n\t\t\t\t\t\n\t\t\t\t\tthis._mount(name);// quiet\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t)\n\t\t\n\t\tthis._._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.restore(undefined, force);\n\t\t\t}\n\t\t);\n\t\t\n\t\tthis._.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.restore(undefined, force);\n\t\t\t}\n\t\t);\n\t}\n\t\n\tgetSnapshotByKey( key, local ) {\n\t\t// only have the local snap\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length))\n\t\t\treturn obj;\n\t\t}\n\t\telse {\n\t\t\tlet ret = !local\n\t\t\t\t&& this.parent\n\t\t\t\t&& this.parent.getSnapshotByKey(key)\n\t\t\t\t||\n\t\t\t\tthis.stores.$parent\n\t\t\t\t&& this.stores.$parent.getSnapshotByKey(key);\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t}\n\t\n\tgetSnapshotByKeyExt( snapshot, key, local ) {\n\t\t// only have the local snap\n\t\tif ( snapshot ) {\n\t\t\tlet obj = keyWalknGet(snapshot, key)\n\t\t\treturn obj;\n\t\t}\n\t\t\n\t}\n\t\n\ttakeSnapshotByKey( key, local ) {\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length))\n\t\t\tif ( obj ) {\n\t\t\t\tthis.deleteSnapshotByKey(key, true);\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\telse {\n\t\t\tlet ret = !local\n\t\t\t\t&& this.parent\n\t\t\t\t&& this.parent.takeSnapshotByKey(key)\n\t\t\t\t||\n\t\t\t\tthis.stores.$parent\n\t\t\t\t&& this.stores.$parent.takeSnapshotByKey(key);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tdeleteSnapshotByKey( key, local ) {\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length).replace(/^(.*[\\>|\\/])[^\\>|\\/]+$/ig, '$1'))\n\t\t\tif ( obj )\n\t\t\t\tdelete obj[key.replace(/^.*[\\>|\\/]([^\\>|\\/]+)$/ig, '$1')]\n\t\t}\n\t\treturn !local\n\t\t\t&& this.parent\n\t\t\t&& this.parent.deleteSnapshotByKey(key)\n\t\t\t||\n\t\t\tthis.stores.$parent\n\t\t\t&& this.stores.$parent.deleteSnapshotByKey(key);\n\t}\n\t\n\tsetState( pState ) {\n\t\tObject.keys(pState)\n\t\t      .forEach(k => (this.state[k] = pState[k]))\n\t}\n\t\n\t/**\n\t * get a parsed reference\n\t * @param _ref\n\t * @returns {{storeId, path, alias: *, ref: *}}\n\t */\n\tparseRef( _ref ) {\n\t\tif ( typeof _ref !== 'string' ) {// @todo : rm this\n\t\t\tthis.register({ [_ref.name]: _ref.store });\n\t\t\t_ref = _ref.name;\n\t\t}\n\t\tlet ref = _ref.split(':');\n\t\tref[0]  = ref[0].split('.');\n\t\treturn {\n\t\t\tstoreId: ref[0][0],\n\t\t\tpath   : ref[0],\n\t\t\talias  : ref[1] || ref[0][ref[0].length - 1],\n\t\t\tref    : _ref\n\t\t};\n\t}\n\t\n\t/**\n\t * Dispatch an action to the top parent & mixed scopes, in all stores\n\t * todo\n\t * @param action\n\t * @param data\n\t * @returns {Scope}\n\t */\n\tdispatch( action, ...argz ) {\n\t\tif ( this.dead ) {\n\t\t\tconsole.warn(\"Dispatch was called on a dead scope, check you're async functions in this stack...\", (new Error()).stack);\n\t\t\treturn;\n\t\t}\n\t\tlet bActs = this._._boundedActions;\n\t\tfor ( let storeId in this._._scope ) {\n\t\t\tif ( storeId === \"$parent\" ) continue;\n\t\t\tif ( !is.fn(this._._scope[storeId]) )\n\t\t\t\tthis._._scope[storeId].trigger(action, ...argz);\n\t\t}\n\t\t\n\t\tif ( bActs && bActs.test(action) )\n\t\t\treturn this;\n\t\t\n\t\tthis._._mixed.forEach(( ctx ) => (ctx.dispatch(action, ...argz)));\n\t\tthis.parent && this.parent.dispatch(action, ...argz);\n\t\treturn this;\n\t}\n\t\n\ttrigger() {\n\t\tthis.dispatch(...arguments);\n\t}\n\t\n\t/**\n\t * once('stable', cb)\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tthen( cb ) {\n\t\tif ( !this._stable )\n\t\t\treturn this.once('stable', e => this.then(cb));\n\t\t\n\t\treturn cb(this.data);\n\t}\n\t\n\tonceStableTree( cb ) {\n\t\tif ( this._.unStableChilds )\n\t\t\treturn this.once('stableTree', e => this.onceStableTree(cb));\n\t\treturn cb(this.data);\n\t}\n\t\n\t/**\n\t * Call retain on the scoped stores basing the given list\n\t *\n\t * @param stores\n\t * @param reason\n\t */\n\tretainStores( stores = [], reason ) {\n\t\tstores.forEach(\n\t\t\tid => (this.stores[id] && this.stores[id].retain && this.stores[id].retain(reason))\n\t\t)\n\t}\n\t\n\t/**\n\t * Call retain on the scoped stores\n\t *\n\t * @param stores\n\t * @param reason\n\t */\n\tdisposeStores( stores = [], reason ) {\n\t\tstores.forEach(\n\t\t\tid => (this.stores[id] && this.stores[id].dispose && this.stores[id].dispose(reason))\n\t\t)\n\t}\n\t\n\t/**\n\t * Keep the scope unstable until release is called\n\t * @param reason\n\t */\n\twait( reason ) {\n\t\t//console.log(\"wait\", reason);\n\t\tthis._stable && !this.__locks.all && this.emit(\"unstable\", this);\n\t\tthis._stable = false;\n\t\tthis.__locks.all++;\n\t\tif ( reason ) {\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]++;\n\t\t}\n\t}\n\t\n\t/**\n\t * Stabilize the scope if no more locks remain (wait fn)\n\t * @param reason\n\t */\n\trelease( reason ) {\n\t\t\n\t\tif ( reason ) {\n\t\t\tif ( this.__locks[reason] == 0 )\n\t\t\t\tconsole.error(\"Release more than locking !\", reason);\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]--;\n\t\t}\n\t\tif ( !reason && this.__locks.all == 0 )\n\t\t\tconsole.error(\"Release more than locking !\");\n\t\t\n\t\tthis.__locks.all--;\n\t\tif ( !this.__locks.all ) {\n\t\t\tif ( this._.stabilizerTM )\n\t\t\t\treturn;\n\t\t\tthis._.stabilizerTM && clearTimeout(this._.stabilizerTM);\n\t\t\t\n\t\t\tthis._.stabilizerTM = setTimeout(\n\t\t\t\te => {\n\t\t\t\t\tthis._.stabilizerTM = null;\n\t\t\t\t\tif ( this.__locks.all )\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\t\t\t\tthis._rev++;\n\t\t\t\t\tthis._stable = true;\n\t\t\t\t\tthis.emit(\"stable\", this);\n\t\t\t\t\t\n\t\t\t\t\t!this.dead && this._propag();// stability can induce destroy\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Propag stores updates basing theirs last updates\n\t * todo : data fps?\n\t */\n\tpropag() {\n\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\tthis._.propagTM = setTimeout(\n\t\t\te => {\n\t\t\t\tthis._.propagTM = null;\n\t\t\t\tthis._propag()\n\t\t\t}, 2\n\t\t);\n\t}\n\t\n\t_propag() {\n\t\tif ( this._.followers.length )\n\t\t\tthis._.followers.forEach(( { 0: obj, 1: key, 2: as, 3: lastRevs, 3: remaps } ) => {\n\t\t\t\tlet data = this.getUpdates(lastRevs);\n\t\t\t\tif ( !data ) return;\n\t\t\t\tif ( typeof obj != \"function\" ) {\n\t\t\t\t\t//console.log(\"setState \",obj, Object.keys(data))\n\t\t\t\t\tif ( as ) obj.setState({ [as]: data });\n\t\t\t\t\telse obj.setState(data);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tobj(data, lastRevs && { ...lastRevs } || \"no revs\");\n\t\t\t\t}\n\t\t\t\t// lastRevs &&\n\t\t\t\t// key.forEach(id => (lastRevs[id] = this.stores[id] &&\n\t\t\t\t// this.stores[id]._rev || 0));\n\t\t\t});\n\t\tthis.emit(\"update\", this.getUpdates());\n\t}\n\t\n\t/**\n\t * is stable\n\t * @returns bool\n\t */\n\tisStable() {\n\t\treturn this._stable;\n\t}\n\t\n\t/**\n\t * is stable tree\n\t * @returns bool\n\t */\n\tisStableTree() {\n\t\treturn !this._.unStableChilds;\n\t}\n\t\n\t/**\n\t * Register children\n\t * @param scope\n\t * @private\n\t */\n\t_addChild( scope ) {\n\t\tthis._.childScopes.push(scope);\n\t\tthis._.seenChilds++;\n\t\tlet lists     = {\n\t\t\t    'stable'      : s => {\n\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    },\n\t\t\t    'unstable'    : s => {\n\t\t\t\t    this._.unStableChilds++;\n\t\t\t\t    if ( 1 == this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"unstableTree\", this)\n\t\t\t    },\n\t\t\t    'stableTree'  : s => {\n\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    },\n\t\t\t    'unstableTree': s => {\n\t\t\t\t    this._.unStableChilds++;\n\t\t\t\t    if ( 1 == this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"unstableTree\", this)\n\t\t\t    },\n\t\t\t    'destroy'     : ctx => {\n\t\t\t\t    if ( ctx._.unStableChilds )\n\t\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !ctx.isStable() )\n\t\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    }\n\t\t    },\n\t\t    wasStable = this._.unStableChilds;\n\t\t\n\t\t!scope.isStable() && this._.unStableChilds++;\n\t\tscope._.unStableChilds && this._.unStableChilds++;\n\t\tthis._.childScopesList.push(lists);\n\t\t\n\t\tif ( !wasStable && this._.unStableChilds )\n\t\t\tthis.emit(\"unstableTree\", this);\n\t\t\n\t\tscope.on(lists);\n\t}\n\t\n\t_rmChild( ctx ) {\n\t\tlet i         = this._.childScopes.indexOf(ctx),\n\t\t    wasStable = this._.unStableChilds;\n\t\tif ( i != -1 ) {\n\t\t\tthis._.childScopes.splice(i, 1);\n\t\t\t!ctx.isStable() && this._.unStableChilds--;\n\t\t\tctx._.unStableChilds && this._.unStableChilds--;\n\t\t\tctx.un(this._.childScopesList.splice(i, 1)[0]);\n\t\t\tif ( wasStable && !this._.unStableChilds )\n\t\t\t\tthis.emit(\"stableTree\")\n\t\t}\n\t}\n\t\n\tretain( reason ) {\n\t\tthis.__retains.all++;\n\t\t//console.log(\"retain\", this._id, reason);\n\t\tif ( reason ) {\n\t\t\tthis.__retains[reason] = this.__retains[reason] || 0;\n\t\t\tthis.__retains[reason]++;\n\t\t}\n\t}\n\t\n\tdispose( reason ) {\n\t\t//console.log(\"dispose\", this._id, reason);\n\t\tif ( reason ) {\n\t\t\tif ( !this.__retains[reason] )\n\t\t\t\tthrow new Error(\"Dispose more than retaining : \" + reason);\n\t\t\tthis.__retains[reason]--;\n\t\t}\n\t\t\n\t\tif ( !this.__retains.all )\n\t\t\tthrow new Error(\"Dispose more than retaining !\");\n\t\t\n\t\tthis.__retains.all--;\n\t\t\n\t\tif ( !this.__retains.all ) {\n\t\t\t//console.log(\"dispose do destroy \", this._id, this._persistenceTm);\n\t\t\tif ( this._.persistenceTm ) {\n\t\t\t\tthis._.destroyTM && clearTimeout(this._.destroyTM);\n\t\t\t\tthis._.destroyTM = setTimeout(\n\t\t\t\t\te => {\n\t\t\t\t\t\tthis.then(s => {\n\t\t\t\t\t\t\t!this.__retains.all && !this.dead && this.destroy()\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tthis._.persistenceTm\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.then(s =>\n\t\t\t\t\t          (!this.__retains.all && !this.dead && this.destroy())\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * order destroy of local stores\n\t */\n\tdestroy() {\n\t\tlet ctx = this._._scope;\n\t\t[...this._.childScopes].map(scope => scope.destroy())\n\t\tfor ( let key in ctx )\n\t\t\tif ( !is.fn(ctx[key]) ) {\n\t\t\t\tif ( key == \"$parent\" ) continue;\n\t\t\t\t!ctx[key]._autoDestroy && ctx[key].dispose(\"scoped\");\n\t\t\t}\n\t\tthis._.stabilizerTM && clearTimeout(this._.stabilizerTM);\n\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\tObject.keys(\n\t\t\tthis._._listening\n\t\t).forEach(\n\t\t\tid => ((id !== \"$parent\") && this._._scope[id].removeListener(this._._listening[id]))\n\t\t);\n\t\twhile ( this._._mixedList.length ) {\n\t\t\tthis._._mixed[0].removeListener(this._._mixedList.shift());\n\t\t\tthis._._mixed.shift().dispose(\"mixedTo\");\n\t\t}\n\t\t[...this._.followers].map(follower => this.unBind(...follower));\n\t\tif ( this._._parentList ) {\n\t\t\tthis.parent._rmChild(this);\n\t\t\tthis.parent.removeListener(this._._parentList);\n\t\t\tthis.parent.dispose(\"isMyParent\");\n\t\t\tthis._._parentList = null;\n\t\t}\n\t\tthis.dead = true;\n\t\tdelete allScopes[this._id];\n\t\tthis.emit(\"destroy\", this);\n\t\t\n\t\t\n\t}\n}\n\n\nScope.isScopable = function ( obj ) {\n\treturn Scope.isScope(obj)\n\t\t|| Scope.isScopeClass(obj)\n\t\t|| Scope.isStore(obj)\n\t\t|| Scope.isStoreClass(obj);\n};\n\nScope.isScope = function ( obj ) {\n\treturn obj instanceof Scope\n};\n\nScope.isScopeClass = function ( obj ) {\n\treturn Scope.isPrototypeOf(obj) || obj === Scope\n};\nexport default Scope;","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nlet $global = (typeof window !== 'undefined') ? window : global,\n    Scope   = require('./Scope').default,\n    Store   = require('./Store').default;\n\nconst RS = $global.___rescope || {};\n\nfunction scopeRef( map, key ) {\n\tmap[key] = new Scope.scopeRef(map[key]);\n\treturn map;\n};\nif ( $global.___rescope ) {\n\tconsole.warn(\"ReScope is defined multiple times !! \\nCheck you're packaging\")\n\tScope    = RS.Scope;\n\tStore    = RS.Store;\n\tscopeRef = RS.scopeRef;\n}\nelse {\n\t$global.___rescope = RS;\n\tScope.Store        = Store;\n}\nexport {Scope, Store, scopeRef};\nexport default { Scope, Store, scopeRef };","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/*\n * Copyright (C) 2019 Nathanael Braun\n * All rights reserved\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nconst is                           = require('is'),\n      Scope                        = require('./Scope').default,\n      { keyWalknSet, keyWalknGet } = require('./utils/utils'),\n      EventEmitter                 = require('./utils/Emitter').default,\n      TaskSequencer                = require('./utils/TaskSequencer').default,\n      shortid                      = require('shortid'),\n      objProto                     = Object.getPrototypeOf({});\n\nclass Store extends EventEmitter {\n\t//static use                  = [];// overridable list of source stores\n\tstatic follow;// overridable list of store that will allow push if updated\n\tstatic require;\n\tstatic staticScope   = new Scope({}, { id: \"static\" });\n\tstatic state         = undefined;// default state\n\t/**\n\t * if retain goes to 0 :\n\t * false to not destroy,\n\t * 0 to sync auto destroy\n\t * Ms to autodestroy after tm ms if no retain has been called\n\t * @type {boolean|Int}\n\t */\n\tstatic persistenceTm = false;\n\t\n\t/**\n\t * Constructor, will build a rescope store\n\t *\n\t * (scope, {require,use,apply,state, data})\n\t * (scope)\n\t *\n\t * @param scope {object} scope where to find the other stores (default : static\n\t *     staticScope )\n\t * @param keys {Array} (passed to Store::map) Ex : [\"session\", \"otherNamedStore:key\",\n\t *     otherStore.as(\"otherKey\")]\n\t */\n\tconstructor() {\n\t\tsuper();\n\t\tlet argz         = [...arguments],\n\t\t    _static      = this.constructor,\n\t\t    scope        = argz[0] instanceof Scope\n\t\t                   ? argz.shift()\n\t\t                   : _static.scope ? Scope.getScope(_static.scope)\n\t\t                                   : is.string(argz[0])\n\t\t                                     ? Scope.getScope(argz.shift())\n\t\t                                     : _static.staticScope,\n\t\t    cfg          = argz[0] && !is.array(argz[0]) && !is.string(argz[0])\n\t\t                   ? argz.shift()\n\t\t                   : {},\n\t\t    taskQueue    = is.array(argz[0]) ? argz.shift() : null,\n\t\t    name         = cfg.name || _static.name,\n\t\t    watchs       = cfg.use || [],\n\t\t    apply        = cfg.apply || null,\n\t\t    initialState = _static.state || _static.initialState || _static.defaultState;\n\t\t\n\t\tthis._uid = cfg._uid || shortid.generate();\n\t\t\n\t\tthis.__retains    = { all: 0 };\n\t\tthis.__locks      = { all: 0 };\n\t\tthis._onStabilize = [];\n\t\t\n\t\t// autoDestroyTm\n\t\tthis._autoDestroy   = !!this._persistenceTm;\n\t\tthis._persistenceTm = cfg.persistenceTm || _static.persistenceTm || (cfg.autoDestroy || _static.autoDestroy) && 5;\n\t\tthis._cfg           = cfg;\n\t\t\n\t\tif ( cfg && cfg.on ) {\n\t\t\tthis.on(cfg.on);\n\t\t}\n\t\t\n\t\tthis.name = name;\n\t\t\n\t\tif ( scope.stores ) {\n\t\t\tthis.scopeObj = scope;\n\t\t\tthis.scope    = scope.stores;\n\t\t}\n\t\telse {\n\t\t\tthis.scopeObj = new Scope(scope);\n\t\t\tthis.scope    = scope.stores;\n\t\t}\n\t\t\n\t\t// standardized scope access\n\t\tthis.$scope    = this.scopeObj;\n\t\tthis.$stores   = this.scopeObj.stores;\n\t\tthis.$actions  = this.scopeObj.actions;\n\t\tthis.$dispatch = this.scopeObj.dispatch.bind(this.scopeObj);\n\t\t\n\t\tthis._rev     = this.constructor._rev || 0;\n\t\tthis._revs    = {};\n\t\tthis.stores   = {};\n\t\tthis._require = [];\n\t\tthis._sources = [name];\n\t\t\n\t\t// register source stores\n\t\tif ( is.array(_static.use) ) {\n\t\t\tthis._use = [...watchs, ...(_static.use || []).map(\n\t\t\t\tkey => {\n\t\t\t\t\tlet ref = key.match(/^(\\!?)([^\\:]*)(?:\\:(.*))?$/);\n\t\t\t\t\tif ( ref[1] ) {\n\t\t\t\t\t\tlet ref2 = ref[2].split('.');\n\t\t\t\t\t\tthis._require.push(ref[3] || ref2[ref2.length - 1]);// require check value of the aliased\n\t\t\t\t\t                                                        // imported value\n\t\t\t\t\t\treturn key.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t)];\n\t\t}\n\t\telse {\n\t\t\tthis._use = [...watchs, ...(\n\t\t\t\t_static.use ? Object.keys(_static.use)\n\t\t\t\t                    .map(\n\t\t\t\t\t                    key => {\n\t\t\t\t\t\t                    let ref = key.match(/^(\\!?)(.*)$/);\n\t\t\t\t\t\t                    ref[1] && this._require.push(_static.use[key]);\n\t\t\t\t\t\t                    return ref[2] + ((_static.use[key] === true)\n\t\t\t\t\t\t                                     ? ''\n\t\t\t\t\t\t                                     : ':' + _static.use[key]);\n\t\t\t\t\t                    }\n\t\t\t\t                    ) : []\n\t\t\t)];\n\t\t}\n\t\t\n\t\tif ( _static.require )\n\t\t\tthis._require.push(..._static.require);\n\t\tif ( cfg.require )\n\t\t\tthis._require.push(...cfg.require);\n\t\t\n\t\tthis._followers = [];\n\t\tthis._changesSW = { ...initialState };\n\t\tif ( initialState && Object.keys(initialState).length )\n\t\t\tthis._nextState = this._changesSW;\n\t\tthis.state = initialState && {};\n\t\t\n\t\tif ( apply )\n\t\t\tthis.apply = apply;\n\t\t\n\t\t/**\n\t\t * Initial state isn't fully initialized ( childs constructors can set it )\n\t\t * Scope based instance have taskQueue to delay init synchronously, if not\n\t\t * present we use setTimeout\n\t\t */\n\t\tif ( taskQueue ) {\n\t\t\ttaskQueue.push(this._afterConstructor.bind(this))\n\t\t}\n\t\telse\n\t\t\tsetTimeout(this._afterConstructor.bind(this))\n\t}\n\t\n\t/**\n\t * Get the incoming state ( for immediate state relative actions )\n\t * @returns {{}|*}\n\t */\n\tget nextState() {\n\t\treturn this._nextState || this.state;\n\t}\n\t\n\t_afterConstructor() {\n\t\tlet cfg          = this._cfg,\n\t\t    _static      = this.constructor,\n\t\t    snapshot     = this.restore(undefined, true),\n\t\t    initialState = this.state,\n\t\t    initialData  = this.data,\n\t\t    applied;\n\t\t{\n\t\t\t\n\t\t\tif ( initialData )\n\t\t\t\tthis.data = initialData;\n\t\t\telse if ( _static.data !== undefined )\n\t\t\t\tthis.data = { ..._static.data };\n\t\t\telse if ( cfg.hasOwnProperty(\"data\") )\n\t\t\t\tthis.data = cfg.data;\n\t\t\t\n\t\t\tif ( cfg.hasOwnProperty(\"state\") && cfg.state !== undefined )\n\t\t\t\tinitialState = { ...initialState, ...cfg.state };\n\t\t\t\n\t\t\tif ( this.data === undefined ) {\n\t\t\t\tif ( initialState || this._use.length ) {// sync apply\n\t\t\t\t\tthis._nextState = this._changesSW = {\n\t\t\t\t\t\t...this._changesSW,\n\t\t\t\t\t\t...(initialState || {}),\n\t\t\t\t\t\t...this.$scope.map(this, this._use)\n\t\t\t\t\t};\n\t\t\t\t\tthis.state      = {};\n\t\t\t\t\tif ( this.shouldApply(this._nextState) && this.data === undefined ) {\n\t\t\t\t\t\tthis.data       = this.apply(this.data, this._nextState, this._changesSW);\n\t\t\t\t\t\tapplied         = true;\n\t\t\t\t\t\tthis.state      = this._changesSW;\n\t\t\t\t\t\tthis._nextState = this._changesSW = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tapplied         = true;\n\t\t\t\tthis.state      = {// assume this state is sync with initial data\n\t\t\t\t\t...this._changesSW,\n\t\t\t\t\t...(initialState || {}),\n\t\t\t\t\t...this.$scope.map(this, this._use)\n\t\t\t\t};\n\t\t\t\tthis._nextState = this._changesSW = null;\n\t\t\t}\n\t\t}\n\t\tif ( (this.data !== undefined || applied) && !this.__locks.all ) {\n\t\t\tthis._stable = true;\n\t\t\tthis._rev++;\n\t\t}\n\t\telse {\n\t\t\tthis._stable = false;\n\t\t\tif ( !_static.managed && !this.state && (!this._use || !this._use.length) ) {\n\t\t\t\tconsole.warn(\"ReScope store '\", this.name, \"' have no initial data, state or use. It can't stabilize...\");\n\t\t\t}\n\t\t}\n\t\t!this._stable && this.emit('unstable', this.state);\n\t\t\n\t}\n\t\n\t/**\n\t * Overridable method to know if a data change should be propag to the listening\n\t * stores & components\n\t */\n\tshouldPropag( nDatas ) {\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Overridable method to choose if this store should be serialized,\n\t * If not it will be applied normally when restoring\n\t * @returns {boolean}\n\t */\n\tshouldSerialize() {\n\t\treturn true;\n\t}\n\t\n\thasDataChange( nDatas ) {\n\t\tlet _static = this.constructor, r,\n\t\t    cDatas  = this.data;\n\t\tr           = !cDatas && nDatas || cDatas !== nDatas;\n\t\t!r && cDatas && Object.keys(cDatas).forEach(\n\t\t\t( key ) => {\n\t\t\t\tr = r || (nDatas\n\t\t\t\t          ? cDatas[key] !== nDatas[key]\n\t\t\t\t          : cDatas && cDatas[key])\n\t\t\t}\n\t\t);\n\t\t!r && nDatas && Object.keys(nDatas).forEach(\n\t\t\t( key ) => {\n\t\t\t\tr = r || (nDatas\n\t\t\t\t          ? cDatas[key] !== nDatas[key]\n\t\t\t\t          : cDatas && cDatas[key])\n\t\t\t}\n\t\t);\n\t\treturn r;\n\t}\n\t\n\t/**\n\t * Overridable method to know if a state change should be applied\n\t */\n\tshouldApply( state = this.state ) {\n\t\tlet _static = this.constructor;\n\t\t\n\t\treturn (\n\t\t\t!!this.isComplete(state)\n\t\t) && (is.array(_static.follow)\n\t\t      ? _static.follow\n\t\t               .reduce(( r, i ) => (r || state && state[i]), false)\n\t\t      : _static.follow\n\t\t        ? Object.keys(_static.follow)\n\t\t                .reduce(( r, i ) => (\n\t\t\t                r\n\t\t\t                || state && is.fn(_static.follow[i]) && _static.follow[i].call(this, state[i])\n\t\t\t                || _static.follow[i] && state[i] !== this.state[i]\n\t\t                ), false) : true\n\t\t);\n\t}\n\t\n\t/**\n\t * Overridable applier / remapper\n\t * If state or lastPublicState are simple hash maps apply will return {...data,\n\t * ...state} if not it will return the last private state\n\t * @param data\n\t * @param state\n\t * @returns {*}\n\t */\n\tapply( data, state, changes ) {\n\t\treturn state;\n\t}\n\t\n\t/**\n\t * Debounce this store propagation ( & reducing )\n\t * @param cb\n\t */\n\tstabilize( cb ) {\n\t\tcb && this.once('stable', cb);\n\t\t\n\t\tif ( this._stabilizer )\n\t\t\treturn;\n\t\tthis._stable && this.emit('unstable', this.state, this.data);\n\t\tthis._stable = false;\n\t\t\n\t\tthis._stabilizer = TaskSequencer.pushTask(this, 'pushState');\n\t}\n\t\n\t/**\n\t * Walk n get\n\t * @param path\n\t * @param i\n\t * @param obj\n\t * @returns {*|{}}\n\t */\n\tretrieve( path, i = 0, obj = this.data ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\treturn !obj || !path || !path.length\n\t\t       ? obj\n\t\t       : path.length == i + 1\n\t\t         ? obj[path[i]]\n\t\t         : this.retrieve(path, i + 1, obj[path[i]]);\n\t}\n\t\n\tdispatch( action, ...argz ) {\n\t\tthis.scopeObj.dispatch(action, ...argz);\n\t}\n\t\n\ttrigger( action, ...argz ) {\n\t\tlet { actions } = this.constructor;\n\t\tif ( actions && actions[action] ) {\n\t\t\tlet ns = actions[action].call(this, ...argz);\n\t\t\tif ( is.function(ns) )\n\t\t\t\tns = ns(this.nextState);\n\t\t\tns && this.setState(ns);\n\t\t}\n\t}\n\t\n\t/**\n\t * Set & Push the result data to followers if stable\n\t * @param cb\n\t */\n\tpush( data, force, cb ) {\n\t\tcb    = force === true ? cb : force;\n\t\tforce = force === true;\n\t\tif ( !force &&\n\t\t\t(\n\t\t\t\t!this.hasDataChange(data)\n\t\t\t)\n\t\t) {\n\t\t\tcb && cb();\n\t\t\tif ( !this.__locks.all ) {\n\t\t\t\tlet stable   = this._stable;\n\t\t\t\tthis._stable = true;\n\t\t\t\t!stable && this.emit('stable', this.state, this.data);\n\t\t\t\t//this._stabilizer = null;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.data = data;\n\t\tthis.wait();\n\t\tthis.release(cb);\n\t\t\n\t}\n\t\n\t/**\n\t * Call the apply fn using the current accumulated state update then, push the\n\t * resulting data if stable\n\t * @param forcedState\n\t */\n\tpushState( forcedState ) {\n\t\tthis._stabilizer = null;\n\t\tif ( !forcedState && !this._changesSW && this.data )\n\t\t\treturn;\n\t\t\n\t\tlet nextState = forcedState || this._nextState || this.state,\n\t\t    nextData;\n\t\tObject.keys(nextState).forEach(\n\t\t\tkey => (nextState[key] === undefined && (delete nextState[key]))\n\t\t);\n\t\tnextData = this.apply(this.data, nextState, this._changesSW);\n\t\t\n\t\tthis.state      = nextState;\n\t\tthis._nextState = null;\n\t\tthis._changesSW = null;\n\t\t\n\t\tif ( !forcedState &&\n\t\t\t(\n\t\t\t\t!this.hasDataChange(nextData)\n\t\t\t)\n\t\t) {\n\t\t\tif ( !this.__locks.all ) {\n\t\t\t\tlet stable   = this._stable;\n\t\t\t\tthis._stable = true;\n\t\t\t\t!stable && this.emit('stable', this.state, this.data);\n\t\t\t\tthis._stabilizer = null;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.data = nextData;\n\t\tthis.wait();\n\t\tthis.release();\n\t}\n\t\n\t/**\n\t * Add 'pState' to the current accumulated state updates\n\t * & wait source stores stabilization before pushing these state updates\n\t * @param pState\n\t * @param cb\n\t */\n\tsetState( pState, cb, sync ) {\n\t\tlet change,\n\t\t    changes   = this._changesSW = this._changesSW || {},\n\t\t    nextState = this._nextState = this._nextState || { ...this.state },\n\t\t    key;\n\t\tfor ( key in pState )\n\t\t\tif ( !this.state\n\t\t\t\t|| changes.hasOwnProperty(key)// todo\n\t\t\t\t&& (\n\t\t\t\t\tpState[key] !== changes[key]\n\t\t\t\t) || pState.hasOwnProperty(key)\n\t\t\t\t&& (\n\t\t\t\t\tpState[key] !== this.state[key]\n\t\t\t\t) ) {\n\t\t\t\tchange         = true;\n\t\t\t\tnextState[key] = changes[key] = pState[key];\n\t\t\t}\n\t\t\n\t\tif ( !this.shouldApply(nextState) ) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ( sync ) {\n\t\t\tthis.pushState();\n\t\t\tcb && cb();\n\t\t}\n\t\telse {\n\t\t\tif ( change ) {\n\t\t\t\tthis.stabilize(cb);\n\t\t\t}\n\t\t\telse cb && cb();\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Update the current state & push it\n\t * @param pState\n\t * @param cb\n\t */\n\tsetStateSync( pState ) {\n\t\tlet i       = 0, change,\n\t\t    changes = this._changesSW = this._changesSW || {};\n\t\tfor ( let k in pState )\n\t\t\tif ( !this.state || pState.hasOwnProperty(k)\n\t\t\t\t&& (\n\t\t\t\t\tpState[k] !== this.state[k]\n\t\t\t\t\t//||\n\t\t\t\t\t//(this.state[k] && pState[k] && (pState[k]._rev != this._revs[k]))// rev/hash update\n\t\t\t\t) ) {\n\t\t\t\tchange        = true;\n\t\t\t\tthis._revs[k] = pState[k] && pState[k]._rev || true;\n\t\t\t\tchanges[k]    = pState[k];\n\t\t\t}\n\t\tthis.shouldApply({ ...(this.state || {}), ...changes }) && this.pushState();\n\t\treturn this.data;\n\t}\n\t\n\t/**\n\t * get a store-key pair for Store::map\n\t * @param {string} name\n\t * @returns {{store: Store, name: *}}\n\t */\n\tas( name ) {\n\t\treturn { store: this, name };\n\t}\n\t\n\ton( lists ) {\n\t\tif ( !is.string(lists) && lists )\n\t\t\tObject.keys(lists).forEach(k => super.on(k, lists[k]));\n\t\telse super.on(...arguments);\n\t}\n\t\n\tremoveListener( lists ) {\n\t\tif ( !is.string(lists) && lists )\n\t\t\tObject.keys(lists).forEach(k => super.removeListener(k, lists[k]));\n\t\telse super.removeListener(...arguments);\n\t}\n\t\n\t/**\n\t * is complete (all requiered keys are here)\n\t * @returns bool\n\t */\n\tisComplete( state = this.state ) {\n\t\treturn (\n\t\t\t!this._require\n\t\t\t|| !this._require.length\n\t\t\t|| state && this._require.reduce(\n\t\t\t\t( r, key ) => (r && state[key]),\n\t\t\t\ttrue\n\t\t\t)\n\t\t);\n\t}\n\t\n\t/**\n\t * is stable\n\t * @returns bool\n\t */\n\tisStable() {\n\t\treturn this._stable;\n\t}\n\t\n\t/**\n\t * Serialize state & data with sources refs\n\t * @returns bool\n\t */\n\tserialize( cfg = {}, output = {} ) {\n\t\t\n\t\tlet sId        = cfg.parentAlias || this.scopeObj._id,\n\t\t    refsCount  = 0,\n\t\t    refs       =\n\t\t\t    !cfg.norefs && is.array(this._use) && this._use.reduce(\n\t\t\t    ( map, key ) => {\n\t\t\t\t    let ref   = this.$scope.parseRef(key),\n\t\t\t\t        store = this.$stores[ref.storeId];\n\t\t\t\t    if ( store && Store.isStore(store) && !store.scopeObj._.isLocalId )\n\t\t\t\t\t    refsCount++, map[ref.alias] = ref.path;\n\t\t\t\t\n\t\t\t\t    return map;\n\t\t\t    }, {}\n\t\t\t    ),\n\t\t    state      = this.state || {},\n\t\t    persistent = this.shouldSerialize();\n\t\t\n\t\tif ( !persistent ) {\n\t\t\tkeyWalknSet(\n\t\t\t\toutput,\n\t\t\t\t(sId + '/' + this.name),\n\t\t\t\t{\n\t\t\t\t\tdataRefs: cfg.dataRefs,\n\t\t\t\t\trefs\n\t\t\t\t}\n\t\t\t);\n\t\t\treturn output;\n\t\t}\n\t\t\n\t\tlet\n\t\t\tstateKeys   = Object.keys(state) || [],\n\t\t\tstateRefs   = stateKeys.map(k => state[k]),\n\t\t\tinRefsCount = 0,\n\t\t\tdataRefs    = cfg.dataRefs || {},\n\t\t\tinRefs      =\n\t\t\t\t!cfg.norefs && this.data && (Object.keys(this.data).reduce(\n\t\t\t\t( map, key ) => {\n\t\t\t\t\tlet ref = stateRefs.indexOf(this.data[key])\n\t\t\t\t\tif ( ref != -1 )\n\t\t\t\t\t\tinRefsCount++, map[key] = stateKeys[ref];\n\t\t\t\t\treturn map;\n\t\t\t\t}, {}\n\t\t\t\t)),\n\t\t\tsnap        = {\n\t\t\t\tdataRefs: cfg.dataRefs,\n\t\t\t\tstate   : state &&\n\t\t\t\t\t(\n\t\t\t\t\t\tcfg.norefs\n\t\t\t\t\t\t? { ...state }\n\t\t\t\t\t\t: Object.keys(state).reduce(( h, k ) => (!refs[k] && (h[k] = state[k]), h), {})\n\t\t\t\t\t),\n\t\t\t\tdata    : (\n\t\t\t\t\t\tthis.data &&\n\t\t\t\t\t\tthis.data.__proto__ === objProto ?\n\t\t\t\t\t\tObject\n\t\t\t\t\t\t\t.keys(this.data)\n\t\t\t\t\t\t\t.reduce(\n\t\t\t\t\t\t\t\t( h, k ) => {\n\t\t\t\t\t\t\t\t\tif ( !inRefs[k] && !dataRefs[k] ) {\n\t\t\t\t\t\t\t\t\t\th[k] = this.data[k];\n\t\t\t\t\t\t\t\t\t\tinRefsCount++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn h\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t                                 :\n\t\t\t\t\t\t(is.bool(this.data)\n\t\t\t\t\t\t\t|| is.number(this.data)\n\t\t\t\t\t\t\t|| is.string(this.data)) && this.data\n\t\t\t\t\t)\n\t\t\t\t\t|| undefined\n\t\t\t\t\n\t\t\t};\n\t\t\n\t\trefs && refsCount && (snap.refs = refs);\n\t\tinRefs && inRefsCount && (\n\t\t\tsnap.inRefs = inRefs);\n\t\t\n\t\t\n\t\tkeyWalknSet(\n\t\t\toutput,\n\t\t\t(sId + '/' + this.name),\n\t\t\tsnap\n\t\t);\n\t\treturn output;\n\t}\n\t\n\t/**\n\t * restore state & data\n\t * @returns bool\n\t */\n\trestore( snapshot, immediate ) {\n\t\tsnapshot = snapshot\n\t\t\t&& keyWalknGet(snapshot, this.scopeObj._id + '/' + this.name)\n\t\t\t|| this.$scope.takeSnapshotByKey(this.scopeObj._id + '/' + this.name);\n\t\t\n\t\tif ( !snapshot )\n\t\t\treturn;\n\t\t\n\t\tif ( snapshot ) {\n\t\t\t\n\t\t\tif ( !this.isStable() && !immediate )\n\t\t\t\tthis.then(() => this.restore(snapshot));\n\t\t\t\n\t\t\tthis.state = { ...snapshot.state };\n\t\t\tsnapshot.refs && Object.keys(snapshot.refs).forEach(\n\t\t\t\t( key ) => {//todo\n\t\t\t\t\tthis.$scope.restoreRefPath(snapshot.refs[key]);\n\t\t\t\t\tthis.state[key] = this.$scope.retrieve(snapshot.refs[key]);\n\t\t\t\t}\n\t\t\t)\n\t\t\t\n\t\t\t\n\t\t\tif ( snapshot.inRefs === true ) {\n\t\t\t\tthis.data = { ...this.state };\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.data = snapshot.data;\n\t\t\t\tsnapshot.inRefs && Object.keys(snapshot.inRefs).forEach(\n\t\t\t\t\t( key ) => {//todo\n\t\t\t\t\t\tthis.data[key] = this.state[snapshot.inRefs[key]];\n\t\t\t\t\t\t//else\n\t\t\t\t\t\t//    console.warn('not found : ', key, snap && snap.refs[ key ])\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tif ( snapshot.dataRefs ) {\n\t\t\t\tthis.data = this.data || {};\n\t\t\t\tObject.keys(snapshot.dataRefs).forEach(\n\t\t\t\t\t( key ) => {//todo\n\t\t\t\t\t\tthis.$scope.restoreRefPath(snapshot.dataRefs[key]);\n\t\t\t\t\t\tthis.data[key] = this.$scope.retrieve(snapshot.dataRefs[key]);\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\t/**\n\t * Bind this store changes to the given component-key\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tbind( obj, key, setInitial = true, path ) {\n\t\tthis._followers.push([obj, key, path]);\n\t\tif ( setInitial && this.data && this._stable ) {\n\t\t\tlet data = path ? this.retrieve(path) : this.data;\n\t\t\tif ( typeof obj != \"function\" ) {\n\t\t\t\tif ( key ) obj.setState({ [key]: data });\n\t\t\t\telse obj.setState(data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj(data);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Un bind this store off the given component-key\n\t * @param obj\n\t * @param key\n\t * @returns {Array.<*>}\n\t */\n\tunBind( obj, key, path ) {\n\t\tlet followers = this._followers,\n\t\t    i         = followers && followers.length;\n\t\twhile ( followers && i-- )\n\t\t\tif ( followers[i][0] === obj && followers[i][1] === key && followers[i][2] === path )\n\t\t\t\treturn followers.splice(i, 1);\n\t}\n\t\n\t/**\n\t * once('stable', cb)\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tthen( cb ) {\n\t\tif ( this._stable )\n\t\t\treturn cb(this.data);\n\t\tthis.once('stable', e => cb(this.data));\n\t}\n\t\n\t/**\n\t * Add a lock so the store will not propag it data untill release() is call\n\t * @param previous {Store|number|Array} @optional wf to wait, releases to wait or\n\t *     array of stuff to wait\n\t * @returns {this}\n\t */\n\twait( previous ) {\n\t\tif ( typeof previous == \"number\" )\n\t\t\treturn this.__locks.all += previous;\n\t\tif ( is.array(previous) )\n\t\t\treturn previous.map(this.wait.bind(this));\n\t\t\n\t\tthis._stable && this.emit('unstable', this.state, this.data);\n\t\tthis._stable = false;\n\t\tthis.__locks.all++;\n\t\t\n\t\tlet reason = is.string(previous) ? previous : null;\n\t\tif ( reason ) {\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]++;\n\t\t}\n\t\tif ( previous && is.fn(previous.then) ) {\n\t\t\tprevious.then(this.release.bind(this, null));\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Decrease locks for this store, if it reach 0 ,\n\t * it will be propagated to the followers,\n\t * then, all stuff passed to \"then\" call back will be exec / released\n\t * @param desync\n\t * @returns {*}\n\t */\n\trelease( reason, cb ) {\n\t\tlet _static = this.constructor, me = this;\n\t\tlet i       = 0, wasStable = this._stable;\n\t\t\n\t\tif ( is.fn(reason) ) {\n\t\t\tcb     = reason;\n\t\t\treason = null;\n\t\t}\n\t\t\n\t\tif ( reason ) {\n\t\t\tif ( this.__locks[reason] == 0 )\n\t\t\t\tconsole.error(\"Release more than locking !\", reason);\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]--;\n\t\t}\n\t\t\n\t\tif ( !reason && this.__locks.all == 0 )\n\t\t\tconsole.error(\"Release more than locking !\");\n\t\t\n\t\tif ( !--this.__locks.all && this.isComplete() ) {\n\t\t\tlet propag   = this.shouldPropag(this.data);\n\t\t\tthis._stable = true;\n\t\t\tpropag && this._rev++;//\n\t\t\tif ( propag && this._followers.length )\n\t\t\t\tthis._followers.forEach(function propag( follower ) {\n\t\t\t\t\tlet data = follower[2] ? me.retrieve(follower[2]) : me.data;\n\t\t\t\t\t//if ( !data ) return;\n\t\t\t\t\t\n\t\t\t\t\tif ( typeof follower[0] == \"function\" ) {\n\t\t\t\t\t\tfollower[0](data);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//cb && i++;\n\t\t\t\t\t\tfollower[0].setState(\n\t\t\t\t\t\t\t(follower[1]) ? { [follower[1]]: data }\n\t\t\t\t\t\t\t              : data\n\t\t\t\t\t\t\t//,\n\t\t\t\t\t\t\t//cb && (\n\t\t\t\t\t\t\t//    () => (!(--i) && cb())\n\t\t\t\t\t\t\t//)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t//else\n\t\t\t!wasStable && this.emit('stable', this.data);\n\t\t\tpropag && this.emit('update', this.data);\n\t\t\tcb && cb()\n\t\t}\n\t\telse cb && this.then(cb);\n\t\treturn this;\n\t}\n\t\n\tpropag( data ) {\n\t\tthis.emit('update', data);\n\t}\n\t\n\tretain( reason ) {\n\t\tthis.__retains.all++;\n\t\tif ( reason ) {\n\t\t\tthis.__retains[reason] = this.__retains[reason] || 0;\n\t\t\tthis.__retains[reason]++;\n\t\t}\n\t}\n\t\n\tdispose( reason ) {\n\t\t//console.warn(\"dispose\", reason, this.__retains);\n\t\tif ( reason ) {\n\t\t\tif ( !this.__retains[reason] ) {\n\t\t\t\tthrow new Error(\"RS : Dispose more than retaining on store '\" + this.name + \"' : \" + reason);\n\t\t\t}\n\t\t\t\n\t\t\tthis.__retains[reason]--;\n\t\t}\n\t\tif ( this.__retains.all == 0 ) {\n\t\t\tthrow new Error(\"RS : Dispose more than retaining on store \" + this.name);\n\t\t}\n\t\t\n\t\tthis.__retains.all--;\n\t\t\n\t\tif ( !this.__retains.all ) {\n\t\t\tif ( this._persistenceTm ) {\n\t\t\t\tthis._destroyTM && clearTimeout(this._destroyTM);\n\t\t\t\tthis._destroyTM = setTimeout(\n\t\t\t\t\te => {\n\t\t\t\t\t\tthis._destroyTM = null;\n\t\t\t\t\t\t//this.then(s => {\n\t\t\t\t\t\t!this.__retains.all && !this.dead && this.destroy()\n\t\t\t\t\t\t//});\n\t\t\t\t\t},\n\t\t\t\t\tthis._persistenceTm\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//this.then(s =>\n\t\t\t\t(!this.__retains.all && !this.dead && this.destroy())\n\t\t\t\t//);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdestroy() {\n\t\t//  console.log(\"destroy\", this._uid);\n\t\t\n\t\tif ( this._stabilizer ) {\n\t\t\tthis._stabilizer = null;\n\t\t\tclearTimeout(this._stabilizer);\n\t\t}\n\t\tthis.emit('destroy', this);\n\t\t\n\t\tif ( this._followers.length )\n\t\t\tthis._followers.forEach(\n\t\t\t\t( follower ) => {\n\t\t\t\t\tif ( typeof follower[0] !== \"function\" ) {\n\t\t\t\t\t\tif ( follower[0].stores )\n\t\t\t\t\t\t\tdelete follower[0].stores[follower[1]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\tthis._followers.length = 0;\n\t\tthis.constructor._rev  = this.rev;\n\t\tthis.dead              = true;\n\t\tthis._revs             = this.data = this.state = this.scope = null;\n\t\tthis.removeAllListeners();\n\t}\n}\n\n/**\n * get a static aliased reference of a store\n * @param {string} name\n * @returns {{store: Store, name: *}}\n */\nStore.as = function ( name ) {\n\treturn { store: this, name };\n}\n\n/**\n * @todo\n * Map all named stores in {keys} to the {object}'s state\n * Hook componentWillUnmount (for react comp) or destroy to unBind them automatically\n * @static\n * @param object {Object} target state aware object (React.Component|Store|...)\n * @param keys {Array} Ex : [\"session\", \"otherStaticNamedStore:key\",\n *     store.as('anotherKey')]\n */\nStore.map = function ( cStore, keys, scope, origin, setInitial = false ) {\n\tlet targetRevs     = cStore._revs || {};\n\tlet targetScope    = cStore.stores || (cStore.stores = {});\n\tlet initialOutputs = {};\n\tkeys               = is.array(keys) ? [...keys] : [keys];\n\t\n\t\n\tscope = scope || Store.staticScope;\n\t\n\tkeys = keys.filter(\n\t\t// @todo : use query refs\n\t\t// (store)(\\.store)*(\\[(\\*|(props)\\w+)+)\\])?(\\:alias)\n\t\t( key ) => {\n\t\t\tif ( !key ) {\n\t\t\t\tconsole.error(\"Not a mappable store item '\" + key + \"' in \" + origin + ' !!');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet name,\n\t\t\t    alias,\n\t\t\t    path,\n\t\t\t    store, _key;\n\t\t\tif ( key.store && key.name ) {\n\t\t\t\talias = name = key.name;\n\t\t\t\tstore = key.store;\n\t\t\t}\n\t\t\telse if ( is.fn(key) ) {\n\t\t\t\tname  = alias = key.name || key.defaultName;\n\t\t\t\tstore = key;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_key  = key.match(/([^\\.\\:]+)((?:\\.[^\\.\\:]+)*)(?:\\:([^\\.\\:]+))?/);\n\t\t\t\tname  = _key[1];\n\t\t\t\tpath  = _key[2] && _key[2].substr(1);\n\t\t\t\tstore = scope.stores[_key[1]];\n\t\t\t\talias = _key[3] || path && path.match(/([^\\.]*)$/)[0] || _key[1];\n\t\t\t}\n\t\t\tif ( !store ) {\n\t\t\t\tlet i = [];\n\t\t\t\tfor ( let o in scope.stores )\n\t\t\t\t\ti.push(o)\n\t\t\t\tconsole.error(\"Not a mappable store item '\" + name + \"/\" + alias + \"' in \" + (cStore.name || cStore) + ' !!', store, _key, scope.stores, i);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( Scope.isScopeClass(store) ) scope._mount(name);\n\t\t\tif ( Scope.isScope(store) ) {\n\t\t\t\tstore = scope._mount(key);\n\t\t\t}\n\t\t\telse if ( targetRevs[name] ) return false;// ignore dbl uses for now\n\t\t\t\n\t\t\t\n\t\t\tif ( is.fn(store) ) {\n\t\t\t\tscope._mount(name)\n\t\t\t\tscope.stores[name].bind(cStore, alias, setInitial, path);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstore.bind(cStore, alias, setInitial, path);\n\t\t\t}\n\t\t\t\n\t\t\t// give initial store weight basing sources\n\t\t\tscope.stores[name]._sources && cStore._sources.push(...scope.stores[name]._sources);\n\t\t\t\n\t\t\ttargetRevs[alias] = targetRevs[alias] || true;\n\t\t\t!targetScope[name] && (targetScope[name] = scope.stores[name]);\n\t\t\tif ( scope.stores[name].hasOwnProperty('data') )\n\t\t\t\tinitialOutputs[name] = scope.data[name];\n\t\t\treturn true;\n\t\t}\n\t);\n\t\n\t// ... @todo\n\tcStore.once('destroy', ( ...argz ) => {\n\t\tkeys.map(\n\t\t\t( key ) => {\n\t\t\t\tlet name,\n\t\t\t\t    alias, path,\n\t\t\t\t    store;\n\t\t\t\tif ( key.store && key.name ) {\n\t\t\t\t\talias = name = key.name;\n\t\t\t\t\tstore = key.store;\n\t\t\t\t}\n\t\t\t\telse if ( is.fn(key) ) {\n\t\t\t\t\tname  = alias = key.name || key.defaultName;\n\t\t\t\t\tstore = scope.stores[name];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey   = key.match(/([^\\.\\:]+)((?:\\.[^\\.\\:]+)*)(?:\\:([^\\.\\:]+))?/);\n\t\t\t\t\tname  = key[1];\n\t\t\t\t\tpath  = key[2] && key[2].substr(1);\n\t\t\t\t\tstore = scope.stores[key[1]];\n\t\t\t\t\talias = key[3] || path && path.match(/([^\\.]*)$/)[0] || key[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstore && !is.fn(store) && store.unBind(cStore, alias, path)\n\t\t\t}\n\t\t);\n\t})\n\t\n\treturn initialOutputs;\n};\n\n\nStore.isStore      = Scope.isStore = function ( obj ) {\n\treturn obj instanceof Store\n}\nStore.isStoreClass = Scope.isStoreClass = function ( obj ) {\n\treturn Store.isPrototypeOf(obj) || obj === Store\n}\n\nexport default Store;","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\n/**\n * Minimal push sequencer, apply stores specific task in the right order\n */\nlet taskQueue      = [],\n    curWeight      = 0,\n    maxWeight      = 0,\n    minWeight      = 0,\n    taskCount      = 0,\n    deSync         = false,\n    deSyncMaxTasks = 10,\n    task,\n    isRunning,\n    errorCatcher   = {\n\t    lastError: null,\n\t    dispatch : function ( error ) {\n\t\t    errorCatcher.disable();\n\t\t\n\t\t    if ( task && task[0].handleError ) {\n\t\t\t    task[0].handleError(error, task);\n\t\t    }\n\t\t    else if ( task )\n\t\t\t    console.error(\"ReScope : An apply task has failed !!\", task[1], \" on \", task[0].name || task[0].constructor.name, '\\n', error)\n\t\t\n\t\t    isRunning = false;\n\t\t    task      = null;\n\t\t    runNow();\n\t    },\n\t    enable   : (typeof window !== 'undefined')\n\t               ? () => {\n\t\t\t    window.addEventListener('error', errorCatcher.dispatch)\n\t\t    } : () => {\n\t\t\t    process.on('uncaughtException', errorCatcher.dispatch);\n\t\t    },\n\t    disable  : (typeof window !== 'undefined')\n\t               ? () => {\n\t\t\t    window.removeEventListener('error', errorCatcher.dispatch)\n\t\t    } : () => {\n\t\t\t    process.removeListener('uncaughtException', errorCatcher.dispatch);\n\t\t    }\n    }\n;\n\nfunction runNow() {\n\tif ( !isRunning ) {\n\t\trun();\n\t}\n}\n\nfunction run() {\n\tlet from  = Date.now();\n\tisRunning = true;\n\terrorCatcher.enable();\n\twhile ( taskCount ) {\n\t\t\n\t\t// try for the current weight\n\t\twhile ( !(taskQueue[curWeight] && taskQueue[curWeight].length) )\n\t\t\tcurWeight++;\n\t\t\n\t\ttaskCount--;\n\t\ttask = taskQueue[curWeight].shift();\n\t\t//console.log(\"Task : \", task[1], \" on \", task[0].name);\n\t\ttry {\n\t\t\t!task[0].dead && task[0][task[1]](task[2]);\n\t\t} catch ( e ) {\n\t\t\treturn errorCatcher.dispatch(e);\n\t\t}\n\t}\n\ttask = undefined;\n\terrorCatcher.disable();\n\t\n\tisRunning = false;\n\tif ( taskCount ) {\n\t\tsetTimeout(runNow);\n\t}\n}\n\n//\n//index.setTaskDeSync = ( nb ) => {\n//    if ( nb === false )\n//        return deSync = false;\n//    else if ( nb === true ) {\n//        deSync         = true;\n//        deSyncMaxTasks = 10;\n//    }\n//    else (is.int(nb))\n//    {\n//        deSync         = true;\n//        deSyncMaxTasks = nb;\n//    }\n//};\n\nexport default {\n\tpushTask( obj, fn, argz ) {\n\t\t/**\n\t\t * The more a store have sources, the more it should be processed first\n\t\t * So leafs stores stay sync, and root stores receive merged state updates;\n\t\t * global state stay coherent\n\t\t *\n\t\t * This mean whatever the number of stores & the complexity of the deps,\n\t\t * updating a store state will update its synchrone child stores immediately\n\t\t *\n\t\t *\n\t\t * @type {*|number}\n\t\t */\n\t\tlet weight = obj._sources && obj._sources.length || 1,\n\t\t    stack  = taskQueue[weight] =\n\t\t\t    taskQueue[weight] || [];\n\t\t\n\t\tmaxWeight = Math.max(maxWeight, weight);\n\t\tcurWeight = Math.min(curWeight, weight);\n\t\ttaskCount++;\n\t\t\n\t\t//console.log(\"Push Task : \", fn, \" on \", obj.name, weight);\n\t\tstack.push([obj, fn, argz]);\n\t\tsetTimeout(runNow, 0);\n\t\treturn stack.length;\n\t}\n};","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"sourceRoot":""}