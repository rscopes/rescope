{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"is\"","webpack:///external \"@babel/runtime/helpers/toConsumableArray\"","webpack:///./src/utils/utils.js","webpack:///external \"@babel/runtime/helpers/defineProperty\"","webpack:///external \"@babel/runtime/helpers/assertThisInitialized\"","webpack:///external \"@babel/runtime/helpers/getPrototypeOf\"","webpack:///external \"@babel/runtime/helpers/createClass\"","webpack:///external \"@babel/runtime/helpers/classCallCheck\"","webpack:///external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack:///external \"@babel/runtime/helpers/get\"","webpack:///external \"@babel/runtime/helpers/inherits\"","webpack:///external \"shortid\"","webpack:///./src/utils/Emitter.js","webpack:///./src/Scope.js","webpack:///./src/index.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/Store.js","webpack:///./src/utils/TaskSequencer.js","webpack:///./node_modules/process/browser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","is","walknSet","obj","path","stack","string","split","length","slice","walknGet","isKey","keyWalknSet","filter","v","keyWalknGet","Emitter","_events","evt","cb","keys","forEach","k","on","this","push","un","indexOf","splice","lists","argz","arguments","fn","__proto__push","target","id","parent","_","allScopes","Scope","storesMap","upperScope","snapshot","state","data","incrementId","persistenceTm","autoDestroy","rootEmitter","boundedActions","keyPID","_id","shortid","generate","baseId","isLocalId","register","_rev","actions","stores","_autoDestroy","constructor","dead","Error","sources","childScopes","childScopesList","unStableChilds","seenChilds","_listening","_scope","_mixed","_mixedList","followers","__retains","all","__locks","_boundedActions","array","test","includes","retain","_parentList","_propag","_stable","wait","release","_addChild","restore","setTimeout","tm","dispose","sm","applier","_refs","cpath","scopeRef","Function","Store","as","scopes","skey","sort","a","b","firstname","join","storeIdList","storeId","_mount","ref","parseRef","reduceRight","mounted","ctx","store","taskQueue","isStoreClass","shift","isScopeClass","$parent","mount","isStore","undefined","setState","isScope","_watchStore","relink","singleton","srcCtx","targetCtx","external","force","activeActions","__proto__","__onHotReloaded","configurable","set","console","warn","_mapActions","hotReloading","act","__targetStores","dispatch","isStable","propag","__origin","lastRevs","refKeys","setInitial","revMap","map","reduce","revs","rev","refs","retainStores","getUpdates","disposeStores","refList","mixedCWUnmount","unMountKey","isReactComponent","unBind","alias","retrieve","cScope","retrieveStore","storesRevMap","local","updated","getStoresRevs","_getRevMap","output","childs","_getAllChilds","cfg","parentAlias","sid","serialize_ex","exclude","withChilds","withMixed","norefs","serialize","withChild","withParents","h","snap","bool","takeSnapshotByKey","destroy","startsWith","substr","getSnapshotByKey","deleteSnapshotByKey","replace","pState","_ref","action","bActs","trigger","once","e","then","onceStableTree","reason","emit","error","stabilizerTM","clearTimeout","propagTM","scope","wasStable","destroyTM","removeListener","follower","_rmChild","EventEmitter","isPrototypeOf","$global","window","global","RS","___rescope","g","TaskSequencer","objProto","getPrototypeOf","_static","getScope","staticScope","watchs","use","apply","initialState","defaultState","_uid","_onStabilize","_persistenceTm","_cfg","scopeObj","$scope","$stores","$actions","$dispatch","_revs","_require","_sources","_use","match","ref2","_followers","_changesSW","_afterConstructor","applied","initialData","_nextState","shouldApply","managed","nDatas","cDatas","isComplete","follow","changes","_stabilizer","pushTask","nextState","hasDataChange","stable","forcedState","nextData","sync","change","pushState","stabilize","sId","refsCount","persistent","shouldSerialize","dataRefs","stateKeys","stateRefs","inRefsCount","inRefs","number","immediate","restoreRefPath","previous","me","shouldPropag","_destroyTM","removeAllListeners","cStore","origin","targetRevs","targetScope","initialOutputs","_key","defaultName","task","isRunning","curWeight","maxWeight","taskCount","errorCatcher","lastError","disable","handleError","runNow","enable","addEventListener","process","removeEventListener","Date","now","run","weight","Math","max","min","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","marker","runClearTimeout","Item","noop","nextTick","args","Array","title","browser","env","argv","version","versions","addListener","off","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"reScope.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n","module.exports = require(\"is\");","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nconst is = require('is');\n\nexport function walknSet( obj, path, value, stack ) {\n\tif ( is.string(path) )\n\t\tpath = path.split('.');\n\tif ( !path.length )\n\t\treturn false;\n\telse if ( path.length == 1 )\n\t\treturn obj[path[0]] = stack\n\t\t                      ? [...(obj[path[0]] || []), value]\n\t\t                      : value;\n\telse\n\t\treturn walknSet(\n\t\t\tobj[path[0]] =\n\t\t\t\tobj[path[0]] || {},\n\t\t\tpath.slice(1),\n\t\t\tvalue, stack\n\t\t);\n}\n\nexport function walknGet( obj, path, isKey ) {\n\tif ( is.string(path) )\n\t\tpath = path.split('.');\n\treturn path.length\n\t       ? obj[path[0]] && walknGet(obj[path[0]], path.slice(1))\n\t       : obj;\n}\n\n//@todo\nexport function keyWalknSet( obj, path, value, stack ) {\n\tif ( is.string(path) )\n\t\tpath = path.split(/(\\>|\\/)/ig).filter(v => (v !== '>' && v));\n\treturn walknSet(obj, path, value);\n}\n\nexport function keyWalknGet( obj, path, isKey ) {\n\tif ( is.string(path) )\n\t\tpath = path.split(/(\\>|\\/)/ig).filter(v => (v !== '>' && v));\n\treturn path.length\n\t       ? obj[path[0]] && walknGet(obj[path[0]], path.slice(1))\n\t       : obj;\n}","module.exports = require(\"@babel/runtime/helpers/defineProperty\");","module.exports = require(\"@babel/runtime/helpers/assertThisInitialized\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","module.exports = require(\"@babel/runtime/helpers/get\");","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"shortid\");","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nimport is from 'is';\n\nexport default class Emitter {\n\t_events = {};\n\t\n\ton( evt, cb ) {\n\t\tif ( !is.string(evt) && evt )\n\t\t\treturn Object.keys(evt).forEach(k => this.on(k, evt[k]));\n\t\t\n\t\tthis._events[evt] = this._events[evt] || [];\n\t\tthis._events[evt].push(cb);\n\t}\n\t\n\tun( evt, cb ) {\n\t\tif ( !is.string(evt) && evt )\n\t\t\treturn Object.keys(evt).forEach(k => this.un(k, evt[k]));\n\t\t\n\t\tif ( !this._events[evt] ) return;\n\t\tlet i = this._events[evt].indexOf(cb);\n\t\tthis._events[evt].splice(i, 1);\n\t}\n\t\n\temit( evt, ...argz ) {\n\t\tif ( !this._events[evt] ) return;\n\t\tlet lists = [...this._events[evt]];\n\t\t\n\t\tfor ( let i = 0; i < lists.length; i++ )\n\t\t\tlists[i](...argz)\n\t}\n\t\n\taddListener() {\n\t\tthis.on(...arguments);\n\t}\n\t\n\tremoveListener() {\n\t\tthis.un(...arguments);\n\t}\n\t\n\tremoveAllListeners() {\n\t\tthis._events = {};\n\t}\n\t\n\tonce( evt, cb ) {\n\t\tlet fn;\n\t\tthis.on(evt, fn = ( ...argz ) => {\n\t\t\tthis.un(evt, fn);\n\t\t\tcb(...argz)\n\t\t});\n\t}\n\t\n\t\n}","/*\n *\n * Copyright (C) 2019 Nathanael Braun\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport is                                   from \"is\";\nimport shortid                              from \"shortid\";\nimport EventEmitter                         from \"./utils/Emitter\";\nimport {keyWalknGet, keyWalknSet, walknSet} from './utils/utils';\n\nconst __proto__push = ( target, id, parent ) => {\n\t      let fn       = function () {\n\t      };\n\t      fn.prototype = parent ? new parent._[id]() : target[id] || {};\n\t      target[id]   = new fn();\n\t      target._[id] = fn;\n      },\n      allScopes     = {};\n\n\n/**\n * Base Scope object\n */\nclass Scope extends EventEmitter {\n\t\n\tstatic persistenceTm = 1;// if > 0, will wait 'persistenceTm' ms before destroy when dispose reach 0\n\tstatic Store         = null;\n\tstatic scopeRef      = function scopeRef( path ) {\n\t\tthis.path = path;\n\t};\n\tstatic scopes        = allScopes;// all active scopes\n\t/**\n\t * get a parsed reference list from stateMap\n\t * @param _ref\n\t * @returns {{storeId, path, alias: *, ref: *}}\n\t */\n\tstatic stateMapToRefList( sm, state = {}, _refs = [], actions = {}, path = \"\" ) {\n\t\tlet applier;\n\t\tObject.keys(sm).forEach(\n\t\t\tkey => {\n\t\t\t\tlet cpath = path ? path + '.' + key : key;\n\t\t\t\t\n\t\t\t\tsm[key] instanceof Scope.scopeRef ?\n\t\t\t\t_refs.push(sm[key].path + ':' + cpath) :\n\t\t\t\t(sm[key] && sm[key] instanceof Function) ?\n\t\t\t\tkey === \"$apply\" ?\n\t\t\t\tapplier = sm[key] :\n\t\t\t\tactions[key] = sm[key] :\n\t\t\t\t(sm[key] && sm[key].prototype instanceof Scope.Store) ?\n\t\t\t\t_refs.push(sm[key].as(cpath)) :\n\t\t\t\t\t//key === \"$actions\" ?\n\t\t\t\t\t//Object.assign(actions, sm[key]) :\n\t\t\t\tstate[cpath] = sm[key]\n\t\t\t\t//: this.stateMapToRefList(sm[key], _refs, path + '.' + key)\n\t\t\t}\n\t\t)\n\t\treturn applier;\n\t}\n\t\n\tstatic getScope( scopes ) {\n\t\tlet skey = is.array(scopes) ? scopes.sort(( a, b ) => {\n\t\t\tif ( a.firstname < b.firstname ) return -1;\n\t\t\tif ( a.firstname > b.firstname ) return 1;\n\t\t\treturn 0;\n\t\t}).join('+') : scopes;\n\t\treturn allScopes[skey] = allScopes[skey] || new Scope({}, { id: skey });\n\t};\n\t\n\t\n\t/**\n\t * Init a ReScope scope\n\t *\n\t * @param storesMap {Object} Object with the initial stores definition / instances\n\t * @param config {Object} Scope config\n\t * {\n\t *     parent {scope} @optional parent scope\n\t *\n\t *     id {string} @optional id ( if this id exist storesMap will be merge on the 'id'\n\t *     scope)\n\t *     key {string} @optional key of the scope ( if no id is set, the scope id will be (parent.id+'>'+key)\n\t *     incrementId {bool} @optional true to add a suffix id, if the provided key or id globally exist\n\t *\n\t *     state {Object} @optional initial state by store alias\n\t *     data {Object} @optional initial data by store alias\n\t *\n\t *     rootEmitter {bool} @optional true to not being destabilized by parent\n\t *     boundedActions {array | regexp} @optional list or regexp of actions not propagated to the parent\n\t *     autoDestroy {true | false | 'inherit'}\n\t *     persistenceTm {number) if > 0, will wait 'persistenceTm' ms before destroy when\n\t *     dispose reach 0 autoDestroy  {bool} will trigger retain & dispose after start\n\t *  }\n\t * @returns {Scope}\n\t */\n\tconstructor( storesMap, { parent, upperScope, key, id, snapshot, state, data, incrementId = !!key, persistenceTm, autoDestroy, rootEmitter, boundedActions } = {} ) {\n\t\tsuper();\n\t\tlet _ = {\n\t\t\tkeyPID: (upperScope && upperScope._id || parent && parent._id || shortid.generate()),\n\t\t\tkey,\n\t\t\tincrementId,\n\t\t\tbaseId: id\n\t\t};\n\t\t\n\t\t\n\t\t// generate / set this scope id\n\t\tid = id || key && (_.keyPID + '>' + key);\n\t\t\n\t\t_.isLocalId = !id;\n\t\t\n\t\tid = id || (\"_____\" + shortid.generate());\n\t\t\n\t\tif ( allScopes[id] && !incrementId ) {// overwrite existing scope\n\t\t\tthis._id = id;\n\t\t\tallScopes[id].register(storesMap);\n\t\t\treturn allScopes[id]\n\t\t}\n\t\telse if ( allScopes[id] && incrementId ) {// generate key id\n\t\t\tlet i = -1;\n\t\t\twhile ( allScopes[id + '[' + (++i) + ']'] ) ;\n\t\t\tid = id + '[' + i + ']';\n\t\t}\n\t\t\n\t\t// register this scope in the static Scope.scopes\n\t\tallScopes[id] = this;\n\t\t\n\t\tthis._id  = id;\n\t\tthis._rev = 0;\n\t\t\n\t\tthis._ = _;\n\t\t\n\t\tthis.actions = {};\n\t\tthis.stores  = {};\n\t\tthis.state   = {};\n\t\tthis.data    = {};\n\t\t\n\t\tthis.parent = parent;\n\t\t\n\t\tif ( autoDestroy == 'inherit' )\n\t\t\tautoDestroy = parent && parent._autoDestroy;\n\t\t\n\t\tthis._autoDestroy = autoDestroy;\n\t\t_.persistenceTm   = persistenceTm || this.constructor.persistenceTm;\n\t\t\n\t\tif ( parent && parent.dead )\n\t\t\tthrow new Error(\"Can't use a dead scope as parent !\");\n\t\t\n\t\t__proto__push(this, 'actions', parent);\n\t\t__proto__push(this, 'stores', parent);\n\t\t__proto__push(this, 'state', parent);\n\t\t__proto__push(this, 'data', parent);\n\t\t\n\t\tthis.sources      = [];\n\t\t_.childScopes     = [];\n\t\t_.childScopesList = [];\n\t\t_.unStableChilds  = 0;\n\t\t_.seenChilds      = 0;\n\t\t_._listening      = {};\n\t\t_._scope          = {};\n\t\t_._mixed          = [];\n\t\t_._mixedList      = [];\n\t\t_.followers       = [];\n\t\t\n\t\tthis.__retains = { all: 0 };\n\t\tthis.__locks   = { all: 1 };\n\t\t\n\t\t// todo\n\t\t_._boundedActions = is.array(boundedActions)\n\t\t                    ? { test: boundedActions.includes.bind(boundedActions) }\n\t\t                    : boundedActions;\n\t\t\n\t\t// register to the parent scope\n\t\tif ( parent ) {\n\t\t\tparent.retain(\"isMyParent\");\n\t\t\tif ( !rootEmitter ) {\n\t\t\t\t!parent._stable && this.wait(\"waitingParent\");\n\t\t\t\tparent.on(_._parentList = {\n\t\t\t\t\t'stable'  : s => this.release(\"waitingParent\"),\n\t\t\t\t\t'unstable': s => this.wait(\"waitingParent\"),\n\t\t\t\t\t'update'  : s => this._propag()\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparent.on(_._parentList = {\n\t\t\t\t\t'update': s => this._propag()\n\t\t\t\t});\n\t\t\t}\n\t\t\t// this.register(parent.__scope, state, data);\n\t\t}\n\t\t\n\t\t// register this scope stores\n\t\tthis.register(storesMap, state, data);\n\t\tthis.__locks.all--;\n\t\tthis._stable = !this.__locks.all;\n\t\t\n\t\tif ( parent ) {\n\t\t\tparent._addChild(this);\n\t\t}\n\t\t\n\t\t\n\t\t// restore snapshots\n\t\tthis.restore(snapshot);\n\t\t\n\t\t\n\t\tif ( autoDestroy )\n\t\t\tsetTimeout(\n\t\t\t\ttm => {\n\t\t\t\t\tthis.retain(\"autoDestroy\");\n\t\t\t\t\tthis.dispose(\"autoDestroy\");\n\t\t\t\t}\n\t\t\t)\n\t\t\n\t}\n\t\n\t/**\n\t *\n\t * Mount the stores in storesList, in this scope or in its parents or mixed scopes\n\t *\n\t * @param storeIdList {string|storeRef} Store name, Array of Store names, or Rescope\n\t *     store ref from Store::as or Store:as\n\t * @param state\n\t * @param data\n\t * @returns {Scope}\n\t */\n\tmount( storeIdList, snapshot, state, data ) {\n\t\tif ( is.array(storeIdList) ) {\n\t\t\tstoreIdList.forEach(storeId => this._mount(storeId, snapshot, state, data));\n\t\t}\n\t\telse {\n\t\t\tthis._mount(...arguments);\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t_mount( id, snapshot, state, data ) {\n\t\tlet ref, _ = this._;\n\t\t\n\t\tref = this.parseRef(id)\n\t\t\n\t\tif ( id == \"$parent\" ) return;\n\t\tif ( !_._scope[ref.storeId] ) {//ask mixed || parent\n\t\t\tif ( _._mixed.reduceRight(( mounted, ctx ) => (mounted || ctx._mount(id, snapshot, state, data)), false) ||\n\t\t\t\t!this.parent )\n\t\t\t\treturn;\n\t\t\treturn this.parent._mount(...arguments);\n\t\t}\n\t\telse {\n\t\t\tlet store = _._scope[ref.storeId], taskQueue = [];\n\t\t\tif ( Scope.isStoreClass(store) ) {\n\t\t\t\t_._scope[ref.storeId] = new store(this, {\n\t\t\t\t\t//snapshot,\n\t\t\t\t\tname: ref.storeId,\n\t\t\t\t\tstate,\n\t\t\t\t\tdata\n\t\t\t\t}, taskQueue);\n\t\t\t\twhile ( taskQueue.length ) taskQueue.shift()();\n\t\t\t}\n\t\t\telse if ( Scope.isScopeClass(store) ) {\n\t\t\t\tstore = _._scope[ref.storeId] = new store({ $parent: this }, {\n\t\t\t\t\tkey        : ref.storeId,\n\t\t\t\t\tincrementId: true,\n\t\t\t\t\tupperScope : this\n\t\t\t\t\t//autoDestroy: true\n\t\t\t\t\t//parent: this\n\t\t\t\t});\n\t\t\t\t//_._scope[ ref.storeId ].retain(\"scopedChildScope\");\n\t\t\t\t//_watchStore(ref.storeId);\n\t\t\t\tif ( ref.path.length > 1 )\n\t\t\t\t\t_._scope[ref.storeId].mount(ref.path.slice(1).join('.'), snapshot, state, data)\n\t\t\t\t//else return _._scope[ ref.storeId ];\n\t\t\t}\n\t\t\tif ( Scope.isStore(store) ) {\n\t\t\t\tif ( state !== undefined && data === undefined )\n\t\t\t\t\tstore.setState(state);\n\t\t\t\telse if ( state !== undefined )\n\t\t\t\t\tstore.state = state;\n\t\t\t\t\n\t\t\t\tif ( data !== undefined )\n\t\t\t\t\tstore.push(data);\n\t\t\t}\n\t\t\tif ( Scope.isScope(store) ) {\n\t\t\t\tif ( state !== undefined )\n\t\t\t\t\tstore.setState(state);\n\t\t\t\tif ( ref.path.length > 1 )\n\t\t\t\t\tstore._mount(ref.path.slice(1).join('.'))\n\t\t\t}\n\t\t\tthis._watchStore(ref.storeId);\n\t\t}\n\t\t\n\t\t\n\t\treturn _._scope[ref.storeId];\n\t}\n\t\n\t/**\n\t * Register stores in storesMap & link them in the protos\n\t * @param storesMap\n\t * @param state\n\t * @param data\n\t */\n\tregister( storesMap, state = {}, data = {} ) {\n\t\tthis.relink(storesMap, this, false, false);\n\t\tObject.keys(storesMap).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id == \"$parent\" ) return;\n\t\t\t\tif ( storesMap[id].singleton || (is.fn(storesMap[id]) && (state[id] || data[id])) ) {\n\t\t\t\t\tthis._mount(id, undefined, state[id], data[id])\n\t\t\t\t}\n\t\t\t\telse if ( state[id] || data[id] ) {\n\t\t\t\t\tif ( data[id] ) {\n\t\t\t\t\t\tif ( state[id] )\n\t\t\t\t\t\t\tthis.stores[id].state = state[id];\n\t\t\t\t\t\tthis.stores[id].push(data[id]);\n\t\t\t\t\t}\n\t\t\t\t\telse if ( state[id] ) {\n\t\t\t\t\t\tthis.stores[id].setState(state[id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._watchStore(id);\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t\t\n\t}\n\t\n\t/**\n\t * Map srcCtx store's on targetCtx headers proto's\n\t * @param srcCtx\n\t * @param targetCtx\n\t * @param state\n\t * @param data\n\t */\n\trelink( srcCtx, targetCtx = this, external, force ) {\n\t\tlet _ = this._, me = this;\n\t\tObject.keys(srcCtx)\n\t\t      .forEach(\n\t\t\t      id => {\n\t\t\t\t      let hotReloading, actions, activeActions;\n\t\t\t\t\n\t\t\t\t      // same store def : ignore\n\t\t\t\t      if ( !force && targetCtx._._scope[id] === srcCtx[id] ||\n\t\t\t\t\t      targetCtx._._scope[id] && (targetCtx._._scope[id].constructor === srcCtx[id]) )\n\t\t\t\t\t      return;\n\t\t\t\t\n\t\t\t\t      // hot switch\n\t\t\t\t      if ( !force && targetCtx._._scope[id] ) {\n\t\t\t\t\t\n\t\t\t\t\t      if ( !external && !is.fn(targetCtx._._scope[id]) ) {// mounted store\n\t\t\t\t\t\t      targetCtx._._scope[id].__proto__ = srcCtx[id].prototype;\n\t\t\t\t\t\t      targetCtx._._scope[id].__onHotReloaded\n\t\t\t\t\t\t      && targetCtx._._scope[id].__onHotReloaded(srcCtx[id]);\n\t\t\t\t\t      }\n\t\t\t\t\t      else if ( !external && is.fn(targetCtx._._scope[id]) )\n\t\t\t\t\t\t      targetCtx._._scope[id] = srcCtx[id];\n\t\t\t\t\t\n\t\t\t\t      }\n\t\t\t\t      else if ( !force && !external )\n\t\t\t\t\t      _._scope[id] = srcCtx[id];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t      // map the store id\n\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t      targetCtx._.stores.prototype,\n\t\t\t\t\t      id,\n\t\t\t\t\t      {\n\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t      get         : () => _._scope[id]\n\t\t\t\t\t      }\n\t\t\t\t      );\n\t\t\t\t\n\t\t\t\t      activeActions = targetCtx._.actions.prototype;\n\t\t\t\t      // not mapping hierarchic scopes\n\t\t\t\t      if ( id !== \"$parent\" ) {\n\t\t\t\t\t      // map state & data\n\t\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t\t      targetCtx._.state.prototype,\n\t\t\t\t\t\t      id,\n\t\t\t\t\t\t      {\n\t\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t\t      get         : () => (_._scope[id] && _._scope[id].state),\n\t\t\t\t\t\t\t      set         : ( v ) => (this._mount(id, undefined, v))\n\t\t\t\t\t\t      }\n\t\t\t\t\t      );\n\t\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t\t      targetCtx._.data.prototype,\n\t\t\t\t\t\t      id,\n\t\t\t\t\t\t      {\n\t\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t\t      get         : () => (_._scope[id] && _._scope[id].data),\n\t\t\t\t\t\t\t      set         : ( v ) => (this._mount(id, undefined, undefined, v))\n\t\t\t\t\t\t      }\n\t\t\t\t\t      );\n\t\t\t\t\t      // action mapping\n\t\t\t\t\t      actions = srcCtx[id] instanceof Scope.Store\n\t\t\t\t\t                ? srcCtx[id].constructor.actions\n\t\t\t\t\t                : srcCtx[id].actions;\n\t\t\t\t\t\n\t\t\t\t\t      if ( Scope.isScopeClass(_._scope[id]) )\n\t\t\t\t\t\t      this._mount(id);\n\t\t\t\t\t\n\t\t\t\t\t      if ( Scope.isScope(_._scope[id]) ) {// map hierarchic scopes\n\t\t\t\t\t\t      if ( activeActions[id] )\n\t\t\t\t\t\t\t      console.warn(\"RS : Sub scope actions is mapped over an existing function !\", id);\n\t\t\t\t\t\t\n\t\t\t\t\t\t      activeActions[id] = _._scope[id].actions;\n\t\t\t\t\t      }\n\t\t\t\t\t      else if ( !Scope.isStore(_._scope[id]) && !Scope.isStoreClass(_._scope[id]) )\n\t\t\t\t\t\t      return;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t      actions &&\n\t\t\t\t\t      this._mapActions(actions, activeActions, id)\n\t\t\t\t      }\n\t\t\t\t      else {\n\t\t\t\t\t      activeActions[id] = srcCtx[id].actions;\n\t\t\t\t      }\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t      // remount the store if it was hot reloaded\n\t\t\t\t      if ( hotReloading )\n\t\t\t\t\t      this._mount(id, null, hotReloading);\n\t\t\t      }\n\t\t      )\n\t}\n\t\n\t/**\n\t * Map & bounds actions from stores\n\t * todo : unmap actions\n\t * @param actions\n\t * @param target\n\t * @param storeId\n\t * @private\n\t */\n\t_mapActions( actions, target, storeId ) {\n\t\tfor ( let act in actions ) {\n\t\t\tif ( actions.hasOwnProperty(act) ) {\n\t\t\t\tif ( is.object(actions[act]) ) {// hirarchised actions\n\t\t\t\t\t\n\t\t\t\t\tif ( target[act] && !is.object(target[act]) )\n\t\t\t\t\t\tconsole.warn(\"RS : Actions namespace is mapped over an existing function !\", storeId, act);\n\t\t\t\t\t\n\t\t\t\t\ttarget[act] = target[act] || { __targetStores: 0 };\n\t\t\t\t\tthis._mapActions(actions[act], target[act]);\n\t\t\t\t\ttarget[act].__targetStores++;\n\t\t\t\t}\n\t\t\t\telse if ( target.hasOwnProperty(act) )\n\t\t\t\t\ttarget[act].__targetStores++;\n\t\t\t\telse {\n\t\t\t\t\tif ( is.object(target[act]) )\n\t\t\t\t\t\tconsole.warn(\"RS : Action is mapped over existing namespace  !\", storeId, act);\n\t\t\t\t\ttarget[act]                = this.dispatch.bind(this, act);\n\t\t\t\t\ttarget[act].__targetStores = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Make this scope watching the local store 'id'\n\t * @param id\n\t * @returns {boolean}\n\t * @private\n\t */\n\t_watchStore( id ) {\n\t\tlet _ = this._;\n\t\tif ( !_._listening[id] && !is.fn(_._scope[id]) ) {\n\t\t\t!_._scope[id]._autoDestroy && _._scope[id].retain(\"scoped\");\n\t\t\t!_._scope[id].isStable() && this.wait(id);\n\t\t\t_._scope[id].on(\n\t\t\t\t_._listening[id] = {\n\t\t\t\t\t'destroy' : s => {\n\t\t\t\t\t\tdelete _._listening[id];\n\t\t\t\t\t\t_._scope[id] = _._scope[id].constructor;\n\t\t\t\t\t},\n\t\t\t\t\t'update'  : s => this.propag(),\n\t\t\t\t\t'stable'  : s => this.release(id),\n\t\t\t\t\t'unstable': s => this.wait(id)\n\t\t\t\t});\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Mix targetCtx on this scope\n\t * Mixed scope parents are NOT mapped\n\t * @param targetCtx\n\t */\n\tmixin( targetCtx ) {\n\t\tlet parent = this.parent,\n\t\t    lists,\n\t\t    _      = this._;\n\t\t\n\t\t_._mixed.push(targetCtx);\n\t\t\n\t\ttargetCtx.retain(\"mixedTo\");\n\t\t\n\t\tif ( !targetCtx._stable )\n\t\t\tthis.wait(targetCtx._id);\n\t\t\n\t\t_._mixedList.push(lists = {\n\t\t\t'stable'  : s => this.release(targetCtx._id),\n\t\t\t'unstable': s => this.wait(targetCtx._id),\n\t\t\t'update'  : s => this._propag()\n\t\t});\n\t\t\n\t\ttargetCtx.on(lists);\n\t\t\n\t\t// reset protos\n\t\t// push new proto with parent\n\t\t__proto__push(this, 'actions', parent);\n\t\t__proto__push(this, 'stores', parent);\n\t\t__proto__push(this, 'state', parent);\n\t\t__proto__push(this, 'data', parent);\n\t\t\n\t\t// bind local accessors in the new proto\n\t\tthis.relink(_._scope, this, false, true);\n\t\t\n\t\t_._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t// push protos\n\t\t\t\t__proto__push(this, 'actions');\n\t\t\t\t__proto__push(this, 'stores');\n\t\t\t\t__proto__push(this, 'state');\n\t\t\t\t__proto__push(this, 'data');\n\t\t\t\tthis.stores.__origin = \"mixed \" + ctx._id;\n\t\t\t\t// write mixed accessors\n\t\t\t\tctx.relink(ctx._._scope, this, true, true)\n\t\t\t}\n\t\t)\n\t}\n\t\n\t/**\n\t * Bind stores from this scope, his parents or mixed scopes to obj\n\t *\n\t * @param target {React.Component|Store|function}\n\t * @param key {string} stores keys to bind updates\n\t * @param as\n\t * @param setInitial {boolean} false to not propag initial value (default : true)\n\t */\n\tbind( target, key, as, setInitial = true, revMap = {} ) {\n\t\tlet lastRevs, data, refKeys;\n\t\tif ( key && !is.array(key) )\n\t\t\tkey = [key];\n\t\t\n\t\tif ( as === false || as === true ) {\n\t\t\tsetInitial = as;\n\t\t\tas         = null;\n\t\t}\n\t\t\n\t\trefKeys = key\n\t\t\t.map(id => (is.string(id) ? id : id.name))\n\t\t\t.map(id => (this.parseRef(id)));\n\t\t\n\t\t\n\t\tthis._.followers.push(\n\t\t\t[\n\t\t\t\ttarget,\n\t\t\t\tkey,\n\t\t\t\tas || undefined,\n\t\t\t\tlastRevs = refKeys.reduce(( revs, ref ) => {\n\t\t\t\t\trevs[ref.storeId] = revs[ref.storeId] || {\n\t\t\t\t\t\trev : 0,\n\t\t\t\t\t\trefs: []\n\t\t\t\t\t};\n\t\t\t\t\trevs[ref.storeId].refs.push(ref);\n\t\t\t\t\treturn revs;\n\t\t\t\t}, revMap)\n\t\t\t]);\n\t\t\n\t\tthis.mount(key);\n\t\tthis.retainStores(Object.keys(lastRevs), 'listeners');\n\t\t\n\t\tif ( setInitial && this._stable ) {\n\t\t\tdata = this.getUpdates(lastRevs);\n\t\t\tif ( !data ) return this;\n\t\t\tif ( typeof target != \"function\" ) {\n\t\t\t\tif ( as ) target.setState({ [as]: data });\n\t\t\t\telse target.setState(data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttarget(data);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Un bind this scope off the given component-keys\n\t * @param target\n\t * @param key\n\t * @returns {Array.<*>}\n\t */\n\tunBind( target, key, as ) {\n\t\tlet followers = this._.followers,\n\t\t    i         = followers && followers.length;\n\t\twhile ( followers && i-- )\n\t\t\tif ( followers[i][0] === target &&\n\t\t\t\t('' + followers[i][1]) == ('' + key) &&\n\t\t\t\tfollowers[i][2] == as ) {\n\t\t\t\tthis.disposeStores(Object.keys(followers[i][3]), 'listeners');\n\t\t\t\treturn followers.splice(i, 1);\n\t\t\t}\n\t}\n\t\n\t/**\n\t * Mount the stores in storeIdList from this scope, its parents and mixed scope\n\t * Bind them to 'to'\n\t * Hook 'to' so it will auto unbind on 'destroy' or 'componentWillUnmount'\n\t * @param target\n\t * @param storeIdList\n\t * @param bind\n\t * @returns {Object} Initial outputs of the stores in 'storesList'\n\t */\n\tmap( target, storeIdList, bind = true, revMap ) {\n\t\tlet Store   = this.constructor.Store;\n\t\tstoreIdList = is.array(storeIdList) ? storeIdList : [storeIdList];\n\t\tlet refList = storeIdList.map(this.parseRef);\n\t\tthis.mount(storeIdList);\n\t\tif ( bind && target instanceof Store ) {\n\t\t\tStore.map(target, storeIdList, this, this, false)\n\t\t}\n\t\telse if ( bind ) {\n\t\t\tthis.bind(target, storeIdList, undefined, false);\n\t\t\t\n\t\t\tlet mixedCWUnmount,\n\t\t\t    unMountKey = target.isReactComponent ? \"componentWillUnmount\" : \"destroy\";\n\t\t\t\n\t\t\tif ( target.hasOwnProperty(unMountKey) ) {\n\t\t\t\tmixedCWUnmount = target[unMountKey];\n\t\t\t}\n\t\t\t\n\t\t\ttarget[unMountKey] = ( ...argz ) => {\n\t\t\t\tdelete target[unMountKey];\n\t\t\t\tif ( mixedCWUnmount )\n\t\t\t\t\ttarget[unMountKey] = mixedCWUnmount;\n\t\t\t\t\n\t\t\t\tthis.unBind(target, storeIdList);\n\t\t\t\treturn target[unMountKey] && target[unMountKey](...argz);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn revMap && this.getUpdates(revMap)\n\t\t\t|| refList.reduce(( data, ref ) => {\n\t\t\t\twalknSet(data, ref.alias || ref.path, this.retrieve(ref.path))\n\t\t\t\treturn data;\n\t\t\t}, {});\n\t}\n\t\n\t/**\n\t * Get current data value from json path\n\t * @param path\n\t * @returns {string|*}\n\t */\n\tretrieve( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\t\n\t\t\n\t\treturn path &&\n\t\t\tthis.stores[path[0]] &&\n\t\t\tthis.stores[path[0]].retrieve &&\n\t\t\tthis.stores[path[0]].retrieve(path.slice(1));\n\t}\n\t\n\t/**\n\t * Restore all nodes in a jsonPath\n\t * @param path\n\t * @returns {string|*}\n\t */\n\trestoreRefPath( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\t\n\t\tlet obj, i = 0, cScope = this;\n\t\t\n\t\twhile ( i < path.length ) {\n\t\t\tobj = cScope.stores[path[i]];\n\t\t\tif ( Scope.isScopeClass(obj)\n\t\t\t\t||\n\t\t\t\tScope.isStoreClass(obj) ) {\n\t\t\t\tcScope.mount(path[0]);\n\t\t\t\tobj = cScope.stores[path[i]];\n\t\t\t}\n\t\t\t\n\t\t\tif ( Scope.isScope(obj) ) {\n\t\t\t\tcScope = obj;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if ( Scope.isStore(obj) ) {\n\t\t\t\tobj.restore();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Get target store from json path\n\t * @param path\n\t * @returns {string|*}\n\t */\n\tretrieveStore( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\treturn path\n\t\t\t&& path.length\n\t\t\t&& (\n\t\t\t\tpath.length != 1 && this.stores[path[0]].retrieveStore\n\t\t\t\t? this.stores[path[0]].retrieveStore(path.slice(1))\n\t\t\t\t: path.length == 1 && this.stores[path[0]]\n\t\t\t);\n\t}\n\t\n\t/**\n\t * Get or update stores revisions in 'storesRevMap'\n\t * @param storesRevMap\n\t * @param local\n\t * @returns {{}}\n\t */\n\tgetStoresRevs( storesRevMap = {}, local ) {\n\t\tlet ctx = this._._scope;\n\t\tif ( !storesRevMap ) {\n\t\t\tstoresRevMap = {};\n\t\t}\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id == \"$parent\" ) return;\n\t\t\t\tif ( !is.fn(ctx[id])\n\t\t\t\t) {\n\t\t\t\t\tstoresRevMap[id] = ctx[id]._rev;\n\t\t\t\t}\n\t\t\t\telse if ( !storesRevMap.hasOwnProperty(id) )\n\t\t\t\t\tstoresRevMap[id] = false\n\t\t\t}\n\t\t);\n\t\tif ( !local ) {\n\t\t\tthis._._mixed.reduce(( updated, ctx ) => (ctx.getStoresRevs(storesRevMap), storesRevMap), storesRevMap);\n\t\t\tthis.parent && this.parent.getStoresRevs(storesRevMap);\n\t\t}\n\t\treturn storesRevMap;\n\t}\n\t\n\t/**\n\t * Recursively get all stores revs\n\t * @param childs\n\t * @returns {Array}\n\t * @private\n\t */\n\t_getRevMap( storesRevMap = {} ) {\n\t\tlet ctx = this._._scope;\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id == \"$parent\" || storesRevMap[id] ) return;\n\t\t\t\tstoresRevMap[id] = { rev: ctx[id]._rev, refs: [] };\n\t\t\t\t\n\t\t\t});\n\t\tthis._._mixed.reduceRight(\n\t\t\t( storesRevMap, ctx ) => (ctx._getRevMap(storesRevMap)), storesRevMap);\n\t\tthis.parent && this.parent._getRevMap(storesRevMap);\n\t\treturn storesRevMap;\n\t}\n\t\n\t/**\n\t * Get updated output basing storesRevMap's revisions.\n\t * If a store in 'storesRevMap' was updated; add it to 'output' & update storesRevMap\n\t * @param storesRevMap\n\t * @param output\n\t * @param updated\n\t * @returns {*|{}}\n\t */\n\tgetRefsUpdates( refs, revMap, output ) {\n\t\trevMap = revMap || refs\n\t\t\t.map(id => (is.string(id) ? id : id.name))\n\t\t\t.map(id => (this.parseRef(id)))\n\t\t\t.reduce(( revs, ref ) => {\n\t\t\t\trevs[ref.storeId] = revs[ref.storeId] || {\n\t\t\t\t\trev : 0,\n\t\t\t\t\trefs: []\n\t\t\t\t};\n\t\t\t\trevs[ref.storeId].refs.push(ref);\n\t\t\t\treturn revs;\n\t\t\t}, {});\n\t\t\n\t\treturn this.getUpdates(revMap, output)\n\t}\n\t\n\t/**\n\t * Get or update output basing storesRevMap's revisions.\n\t * If a store in 'storesRevMap' was updated; add it to 'output' & update storesRevMap\n\t * @param storesRevMap\n\t * @param output\n\t * @param updated\n\t * @returns {*|{}}\n\t */\n\tgetUpdates( storesRevMap, output, updated ) {\n\t\toutput       = output || {};\n\t\tstoresRevMap = storesRevMap || this._getRevMap();\n\t\tObject.keys(storesRevMap).forEach(\n\t\t\tid => {\n\t\t\t\tlet store        = this.stores[id];\n\t\t\t\tstoresRevMap[id] = storesRevMap[id] || { rev: 0, refs: [] };\n\t\t\t\t\n\t\t\t\tif ( store && is.fn(store) ) {\n\t\t\t\t\tupdated    = true;\n\t\t\t\t\toutput[id] = undefined;\n\t\t\t\t}\n\t\t\t\telse if ( store && store._rev > storesRevMap[id].rev ) {\n\t\t\t\t\tstoresRevMap[id].rev = store._rev;\n\t\t\t\t\tupdated              = true;\n\t\t\t\t\tstoresRevMap[id].refs.forEach(\n\t\t\t\t\t\tref => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\toutput[ref.alias] = this.retrieve(ref.path)\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t\treturn updated && output;\n\t}\n\t\n\t/**\n\t * Recursively get all child scopes\n\t * @param childs\n\t * @returns {Array}\n\t * @private\n\t */\n\t_getAllChilds( childs = [] ) {\n\t\tchilds.push(...this._.childScopes);\n\t\tthis._.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\tctx._getAllChilds(childs);\n\t\t\t}\n\t\t);\n\t\treturn childs;\n\t}\n\t\n\t/**\n\t * Serialize all active stores state & data in every childs & mixed scopes\n\t *\n\t * Scopes without key or id are ignored\n\t * @param output\n\t * @returns {{}}\n\t */\n\tserialize( cfg = {}, output = {} ) {\n\t\tlet ctx                                  = this._._scope,\n\t\t    { baseId, key, keyPID, incrementId } = this._,\n\t\t    {\n\t\t\t    alias,\n\t\t\t    parentAlias,\n\t\t    }                                    = cfg,\n\t\t    sid                                  = key\n\t\t                                           ? (parentAlias || keyPID) + '>' + key\n\t\t                                           : alias || parentAlias && (parentAlias + '/' + baseId) || this._id;\n\t\t\n\t\t\n\t\t//alias = alias || baseId;\n\t\treturn this.serialize_ex(cfg, output, sid, alias, [\"$parent\"])\n\t}\n\t\n\tserialize_ex( cfg = {}, output = {}, sid, alias, exclude ) {\n\t\tlet _               = this._,\n\t\t    ctx             = _._scope,\n\t\t    { incrementId } = _,\n\t\t    {\n\t\t\t    withChilds = true,\n\t\t\t    withMixed  = true,\n\t\t\t    norefs,\n\t\t    }               = cfg;\n\t\t\n\t\tif ( keyWalknGet(output, sid) ) {\n\t\t\tif ( !incrementId )// done\n\t\t\t\treturn output;\n\t\t\telse if ( incrementId ) {// generate key id\n\t\t\t\tlet i = -1;\n\t\t\t\twhile ( keyWalknGet(output, sid + '[' + (++i) + ']') ) ;\n\t\t\t\tsid = sid + '[' + i + ']';\n\t\t\t}\n\t\t}\n\t\t\n\t\tkeyWalknSet(output, sid, {});\n\t\t\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( exclude.includes(id) || Scope.isStoreClass(ctx[id]) || Scope.isScopeClass(ctx[id]) )\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tctx[id].serialize({ ...cfg, parentAlias: sid }, output);\n\t\t\t}\n\t\t)\n\t\t\n\t\twithChilds && _.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.serialize({\n\t\t\t\t\t                                  withChild  : true,\n\t\t\t\t\t                                  withParents: false,\n\t\t\t\t\t                                  parentAlias: sid,\n\t\t\t\t\t                                  withMixed,\n\t\t\t\t\t                                  norefs,\n\t\t\t\t                                  }, output);\n\t\t\t}\n\t\t);\n\t\t\n\t\twithMixed && _._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.serialize({\n\t\t\t\t\t                                  withChild  : false,\n\t\t\t\t\t                                  withParents: false,\n\t\t\t\t\t                                  withMixed,\n\t\t\t\t\t                                  norefs\n\t\t\t\t                                  }, output);\n\t\t\t}\n\t\t);\n\t\t\n\t\tif ( alias ) {\n\t\t\toutput = Object.keys(output)\n\t\t\t               .reduce(\n\t\t\t\t               ( h, k ) => (\n\t\t\t\t\t               h[k === this._id\n\t\t\t\t\t                 ? alias\n\t\t\t\t\t                 : k] = output[k],\n\t\t\t\t\t\t               h\n\t\t\t\t               ),\n\t\t\t\t               {}\n\t\t\t               )\n\t\t}\n\t\treturn output;\n\t}\n\t\n\t/**\n\t * Restore state & data from the serialize fn\n\t * @param snapshot\n\t * @param force\n\t */\n\trestore( snapshot, cfg = {}, force = is.bool(cfg) && cfg ) {\n\t\tlet ctx = this._._scope, snap;\n\t\t\n\t\tif ( snapshot && cfg && cfg.alias && cfg.alias != this._id ) {\n\t\t\tsnap = {\n\t\t\t\t...snapshot,\n\t\t\t\t[this._id]: snapshot[cfg.alias]\n\t\t\t}\n\t\t\tdelete snap[cfg.alias];\n\t\t\tsnapshot = snap;\n\t\t}\n\t\tsnapshot = snapshot\n\t\t\t&& keyWalknGet(snapshot, this._id)\n\t\t\t|| this.takeSnapshotByKey(this._id);\n\t\t\n\t\t\n\t\tif ( !snapshot )\n\t\t\treturn;\n\t\t\n\t\tthis._.snapshot = { ...snapshot };\n\t\t\n\t\tsnap          = snapshot['/'];\n\t\tsnapshot['/'] = { ...snap };\n\t\tsnap && Object.keys(snap).forEach(\n\t\t\tname => {\n\t\t\t\tif ( name == \"$parent\" ) return;\n\t\t\t\t\n\t\t\t\tif ( ctx[name] ) {\n\t\t\t\t\t\n\t\t\t\t\tif ( force && !is.fn(ctx[name]) )\n\t\t\t\t\t\tctx[name].destroy();\n\t\t\t\t\t\n\t\t\t\t\tthis._mount(name);// quiet\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t)\n\t\t\n\t\tthis._._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.restore(undefined, force);\n\t\t\t}\n\t\t);\n\t\t\n\t\tthis._.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.restore(undefined, force);\n\t\t\t}\n\t\t);\n\t}\n\t\n\tgetSnapshotByKey( key, local ) {\n\t\t// only have the local snap\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length))\n\t\t\treturn obj;\n\t\t}\n\t\telse return !local\n\t\t\t&& this.parent\n\t\t\t&& this.parent.getSnapshotByKey(key)\n\t\t\t||\n\t\t\tthis.stores.$parent\n\t\t\t&& this.stores.$parent.getSnapshotByKey(key);\n\t\t\n\t}\n\t\n\tgetSnapshotByKeyExt( snapshot, key, local ) {\n\t\t// only have the local snap\n\t\tif ( snapshot ) {\n\t\t\tlet obj = keyWalknGet(snapshot, key)\n\t\t\treturn obj;\n\t\t}\n\t\t\n\t}\n\t\n\ttakeSnapshotByKey( key, local ) {\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length))\n\t\t\tif ( obj ) {\n\t\t\t\tthis.deleteSnapshotByKey(key, true);\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\telse return !local\n\t\t\t&& this.parent\n\t\t\t&& this.parent.takeSnapshotByKey(key)\n\t\t\t||\n\t\t\tthis.stores.$parent\n\t\t\t&& this.stores.$parent.takeSnapshotByKey(key);\n\t}\n\t\n\tdeleteSnapshotByKey( key, local ) {\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length).replace(/^(.*[\\>|\\/])[^\\>|\\/]+$/ig, '$1'))\n\t\t\tif ( obj )\n\t\t\t\tdelete obj[key.replace(/^.*[\\>|\\/]([^\\>|\\/]+)$/ig, '$1')]\n\t\t}\n\t\treturn !local\n\t\t\t&& this.parent\n\t\t\t&& this.parent.deleteSnapshotByKey(key)\n\t\t\t||\n\t\t\tthis.stores.$parent\n\t\t\t&& this.stores.$parent.deleteSnapshotByKey(key);\n\t}\n\t\n\tsetState( pState ) {\n\t\tObject.keys(pState)\n\t\t      .forEach(k => (this.state[k] = pState[k]))\n\t}\n\t\n\t/**\n\t * get a parsed reference\n\t * @param _ref\n\t * @returns {{storeId, path, alias: *, ref: *}}\n\t */\n\tparseRef( _ref ) {\n\t\tif ( typeof _ref !== 'string' ) {// @todo : rm this\n\t\t\tthis.register({ [_ref.name]: _ref.store });\n\t\t\t_ref = _ref.name;\n\t\t}\n\t\tlet ref = _ref.split(':');\n\t\tref[0]  = ref[0].split('.');\n\t\treturn {\n\t\t\tstoreId: ref[0][0],\n\t\t\tpath   : ref[0],\n\t\t\talias  : ref[1] || ref[0][ref[0].length - 1],\n\t\t\tref    : _ref\n\t\t};\n\t}\n\t\n\t/**\n\t * Dispatch an action to the top parent & mixed scopes, in all stores\n\t * todo\n\t * @param action\n\t * @param data\n\t * @returns {Scope}\n\t */\n\tdispatch( action, ...argz ) {\n\t\tif ( this.dead ) {\n\t\t\tconsole.warn(\"Dispatch was called on a dead scope, check you're async functions in this stack...\", (new Error()).stack);\n\t\t\treturn;\n\t\t}\n\t\tlet bActs = this._._boundedActions;\n\t\tfor ( let storeId in this._._scope ) {\n\t\t\tif ( storeId === \"$parent\" ) continue;\n\t\t\tif ( !is.fn(this._._scope[storeId]) )\n\t\t\t\tthis._._scope[storeId].trigger(action, ...argz);\n\t\t}\n\t\t\n\t\tif ( bActs && bActs.test(action) )\n\t\t\treturn this;\n\t\t\n\t\tthis._._mixed.forEach(( ctx ) => (ctx.dispatch(action, ...argz)));\n\t\tthis.parent && this.parent.dispatch(action, ...argz);\n\t\treturn this;\n\t}\n\t\n\ttrigger() {\n\t\tthis.dispatch(...arguments);\n\t}\n\t\n\t/**\n\t * once('stable', cb)\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tthen( cb ) {\n\t\tif ( !this._stable )\n\t\t\treturn this.once('stable', e => this.then(cb));\n\t\t\n\t\treturn cb(this.data);\n\t}\n\t\n\tonceStableTree( cb ) {\n\t\tif ( this._.unStableChilds )\n\t\t\treturn this.once('stableTree', e => this.onceStableTree(cb));\n\t\treturn cb(this.data);\n\t}\n\t\n\t/**\n\t * Call retain on the scoped stores basing the given list\n\t *\n\t * @param stores\n\t * @param reason\n\t */\n\tretainStores( stores = [], reason ) {\n\t\tstores.forEach(\n\t\t\tid => (this.stores[id] && this.stores[id].retain && this.stores[id].retain(reason))\n\t\t)\n\t}\n\t\n\t/**\n\t * Call retain on the scoped stores\n\t *\n\t * @param stores\n\t * @param reason\n\t */\n\tdisposeStores( stores = [], reason ) {\n\t\tstores.forEach(\n\t\t\tid => (this.stores[id] && this.stores[id].dispose && this.stores[id].dispose(reason))\n\t\t)\n\t}\n\t\n\t/**\n\t * Keep the scope unstable until release is called\n\t * @param reason\n\t */\n\twait( reason ) {\n\t\t//console.log(\"wait\", reason);\n\t\tthis._stable && !this.__locks.all && this.emit(\"unstable\", this);\n\t\tthis._stable = false;\n\t\tthis.__locks.all++;\n\t\tif ( reason ) {\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]++;\n\t\t}\n\t}\n\t\n\t/**\n\t * Stabilize the scope if no more locks remain (wait fn)\n\t * @param reason\n\t */\n\trelease( reason ) {\n\t\t\n\t\tif ( reason ) {\n\t\t\tif ( this.__locks[reason] == 0 )\n\t\t\t\tconsole.error(\"Release more than locking !\", reason);\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]--;\n\t\t}\n\t\tif ( !reason && this.__locks.all == 0 )\n\t\t\tconsole.error(\"Release more than locking !\");\n\t\t\n\t\tthis.__locks.all--;\n\t\tif ( !this.__locks.all ) {\n\t\t\tif ( this._.stabilizerTM )\n\t\t\t\treturn;\n\t\t\tthis._.stabilizerTM && clearTimeout(this._.stabilizerTM);\n\t\t\t\n\t\t\tthis._.stabilizerTM = setTimeout(\n\t\t\t\te => {\n\t\t\t\t\tthis._.stabilizerTM = null;\n\t\t\t\t\tif ( this.__locks.all )\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\t\t\t\tthis._rev++;\n\t\t\t\t\tthis._stable = true;\n\t\t\t\t\tthis.emit(\"stable\", this);\n\t\t\t\t\t\n\t\t\t\t\t!this.dead && this._propag();// stability can induce destroy\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Propag stores updates basing theirs last updates\n\t */\n\tpropag() {\n\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\tthis._.propagTM = setTimeout(\n\t\t\te => {\n\t\t\t\tthis._.propagTM = null;\n\t\t\t\tthis._propag()\n\t\t\t}, 2\n\t\t);\n\t}\n\t\n\t_propag() {\n\t\tif ( this._.followers.length )\n\t\t\tthis._.followers.forEach(( { 0: obj, 1: key, 2: as, 3: lastRevs, 3: remaps } ) => {\n\t\t\t\tlet data = this.getUpdates(lastRevs);\n\t\t\t\tif ( !data ) return;\n\t\t\t\tif ( typeof obj != \"function\" ) {\n\t\t\t\t\t//console.log(\"setState \",obj, Object.keys(data))\n\t\t\t\t\tif ( as ) obj.setState({ [as]: data });\n\t\t\t\t\telse obj.setState(data);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tobj(data, lastRevs && { ...lastRevs } || \"no revs\");\n\t\t\t\t}\n\t\t\t\t// lastRevs &&\n\t\t\t\t// key.forEach(id => (lastRevs[id] = this.stores[id] &&\n\t\t\t\t// this.stores[id]._rev || 0));\n\t\t\t});\n\t\tthis.emit(\"update\", this.getUpdates());\n\t}\n\t\n\t/**\n\t * is stable\n\t * @returns bool\n\t */\n\tisStable() {\n\t\treturn this._stable;\n\t}\n\t\n\t/**\n\t * is stable tree\n\t * @returns bool\n\t */\n\tisStableTree() {\n\t\treturn !this._.unStableChilds;\n\t}\n\t\n\t/**\n\t * Register children\n\t * @param scope\n\t * @private\n\t */\n\t_addChild( scope ) {\n\t\tthis._.childScopes.push(scope);\n\t\tthis._.seenChilds++;\n\t\tlet lists     = {\n\t\t\t    'stable'      : s => {\n\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    },\n\t\t\t    'unstable'    : s => {\n\t\t\t\t    this._.unStableChilds++;\n\t\t\t\t    if ( 1 == this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"unstableTree\", this)\n\t\t\t    },\n\t\t\t    'stableTree'  : s => {\n\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    },\n\t\t\t    'unstableTree': s => {\n\t\t\t\t    this._.unStableChilds++;\n\t\t\t\t    if ( 1 == this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"unstableTree\", this)\n\t\t\t    },\n\t\t\t    'destroy'     : ctx => {\n\t\t\t\t    if ( ctx._.unStableChilds )\n\t\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !ctx.isStable() )\n\t\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    }\n\t\t    },\n\t\t    wasStable = this._.unStableChilds;\n\t\t\n\t\t!scope.isStable() && this._.unStableChilds++;\n\t\tscope._.unStableChilds && this._.unStableChilds++;\n\t\tthis._.childScopesList.push(lists);\n\t\t\n\t\tif ( !wasStable && this._.unStableChilds )\n\t\t\tthis.emit(\"unstableTree\", this);\n\t\t\n\t\tscope.on(lists);\n\t}\n\t\n\t_rmChild( ctx ) {\n\t\tlet i         = this._.childScopes.indexOf(ctx),\n\t\t    wasStable = this._.unStableChilds;\n\t\tif ( i != -1 ) {\n\t\t\tthis._.childScopes.splice(i, 1);\n\t\t\t!ctx.isStable() && this._.unStableChilds--;\n\t\t\tctx._.unStableChilds && this._.unStableChilds--;\n\t\t\tctx.un(this._.childScopesList.splice(i, 1)[0]);\n\t\t\tif ( wasStable && !this._.unStableChilds )\n\t\t\t\tthis.emit(\"stableTree\")\n\t\t}\n\t}\n\t\n\tretain( reason ) {\n\t\tthis.__retains.all++;\n\t\t//console.log(\"retain\", this._id, reason);\n\t\tif ( reason ) {\n\t\t\tthis.__retains[reason] = this.__retains[reason] || 0;\n\t\t\tthis.__retains[reason]++;\n\t\t}\n\t}\n\t\n\tdispose( reason ) {\n\t\t//console.log(\"dispose\", this._id, reason);\n\t\tif ( reason ) {\n\t\t\tif ( !this.__retains[reason] )\n\t\t\t\tthrow new Error(\"Dispose more than retaining : \" + reason);\n\t\t\tthis.__retains[reason]--;\n\t\t}\n\t\t\n\t\tif ( !this.__retains.all )\n\t\t\tthrow new Error(\"Dispose more than retaining !\");\n\t\t\n\t\tthis.__retains.all--;\n\t\t\n\t\tif ( !this.__retains.all ) {\n\t\t\t//console.log(\"dispose do destroy \", this._id, this._persistenceTm);\n\t\t\tif ( this._.persistenceTm ) {\n\t\t\t\tthis._.destroyTM && clearTimeout(this._.destroyTM);\n\t\t\t\tthis._.destroyTM = setTimeout(\n\t\t\t\t\te => {\n\t\t\t\t\t\tthis.then(s => {\n\t\t\t\t\t\t\t!this.__retains.all && !this.dead && this.destroy()\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tthis._.persistenceTm\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.then(s =>\n\t\t\t\t\t          (!this.__retains.all && !this.dead && this.destroy())\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * order destroy of local stores\n\t */\n\tdestroy() {\n\t\tlet ctx = this._._scope;\n\t\t[...this._.childScopes].map(scope => scope.destroy())\n\t\tfor ( let key in ctx )\n\t\t\tif ( !is.fn(ctx[key]) ) {\n\t\t\t\tif ( key == \"$parent\" ) continue;\n\t\t\t\t!ctx[key]._autoDestroy && ctx[key].dispose(\"scoped\");\n\t\t\t}\n\t\tthis._.stabilizerTM && clearTimeout(this._.stabilizerTM);\n\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\tObject.keys(\n\t\t\tthis._._listening\n\t\t).forEach(\n\t\t\tid => ((id !== \"$parent\") && this._._scope[id].removeListener(this._._listening[id]))\n\t\t);\n\t\twhile ( this._._mixedList.length ) {\n\t\t\tthis._._mixed[0].removeListener(this._._mixedList.shift());\n\t\t\tthis._._mixed.shift().dispose(\"mixedTo\");\n\t\t}\n\t\t[...this._.followers].map(follower => this.unBind(...follower));\n\t\tif ( this._._parentList ) {\n\t\t\tthis.parent._rmChild(this);\n\t\t\tthis.parent.removeListener(this._._parentList);\n\t\t\tthis.parent.dispose(\"isMyParent\");\n\t\t\tthis._._parentList = null;\n\t\t}\n\t\tthis.dead = true;\n\t\tdelete allScopes[this._id];\n\t\tthis.emit(\"destroy\", this);\n\t\t\n\t\t\n\t}\n}\n\n\nScope.isScope = function ( obj ) {\n\treturn obj instanceof Scope\n};\n\nScope.isScopeClass = function ( obj ) {\n\treturn Scope.isPrototypeOf(obj) || obj === Scope\n};\nexport default Scope;","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nlet $global = (typeof window !== 'undefined') ? window : global,\n    Scope   = require('./Scope').default,\n    Store   = require('./Store').default;\n\nconst RS = $global.___rescope || {};\n\nfunction scopeRef( map, key ) {\n\tmap[key] = new Scope.scopeRef(map[key]);\n\treturn map;\n};\nif ( $global.___rescope ) {\n\tconsole.warn(\"ReScope is defined multiple times !! \\nCheck you're packaging\")\n\tScope    = RS.Scope;\n\tStore    = RS.Store;\n\tscopeRef = RS.scopeRef;\n}\nelse {\n\t$global.___rescope = RS;\n\tScope.Store        = Store;\n}\nexport {Scope, Store, scopeRef};\nexport default { Scope, Store, scopeRef };","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nconst is                           = require('is'),\n      Scope                        = require('./Scope').default,\n      { keyWalknSet, keyWalknGet } = require('./utils/utils'),\n      EventEmitter                 = require('./utils/Emitter').default,\n      TaskSequencer                = require('./utils/TaskSequencer').default,\n      shortid                      = require('shortid'),\n      objProto                     = Object.getPrototypeOf({});\n\nclass Store extends EventEmitter {\n\t//static use                  = [];// overridable list of source stores\n\tstatic follow;// overridable list of store that will allow push if updated\n\tstatic require;\n\tstatic staticScope   = new Scope({}, { id: \"static\" });\n\tstatic state         = undefined;// default state\n\t/**\n\t * if retain goes to 0 :\n\t * false to not destroy,\n\t * 0 to sync auto destroy\n\t * Ms to autodestroy after tm ms if no retain has been called\n\t * @type {boolean|Int}\n\t */\n\tstatic persistenceTm = false;\n\t\n\t/**\n\t * Constructor, will build a rescope store\n\t *\n\t * (scope, {require,use,apply,state, data})\n\t * (scope)\n\t *\n\t * @param scope {object} scope where to find the other stores (default : static\n\t *     staticScope )\n\t * @param keys {Array} (passed to Store::map) Ex : [\"session\", \"otherNamedStore:key\",\n\t *     otherStore.as(\"otherKey\")]\n\t */\n\tconstructor() {\n\t\tsuper();\n\t\tlet argz         = [...arguments],\n\t\t    _static      = this.constructor,\n\t\t    scope        = argz[0] instanceof Scope\n\t\t                   ? argz.shift()\n\t\t                   : _static.scope ? Scope.getScope(_static.scope)\n\t\t                                   : is.string(argz[0])\n\t\t                                     ? Scope.getScope(argz.shift())\n\t\t                                     : _static.staticScope,\n\t\t    cfg          = argz[0] && !is.array(argz[0]) && !is.string(argz[0])\n\t\t                   ? argz.shift()\n\t\t                   : {},\n\t\t    taskQueue    = is.array(argz[0]) ? argz.shift() : null,\n\t\t    name         = cfg.name || _static.name,\n\t\t    watchs       = cfg.use || [],\n\t\t    apply        = cfg.apply || null,\n\t\t    initialState = _static.state || _static.initialState || _static.defaultState;\n\t\t\n\t\tthis._uid = cfg._uid || shortid.generate();\n\t\t\n\t\tthis.__retains    = { all: 0 };\n\t\tthis.__locks      = { all: 0 };\n\t\tthis._onStabilize = [];\n\t\t\n\t\t// autoDestroyTm\n\t\tthis._autoDestroy   = !!this._persistenceTm;\n\t\tthis._persistenceTm = cfg.persistenceTm || _static.persistenceTm || (cfg.autoDestroy || _static.autoDestroy) && 5;\n\t\tthis._cfg           = cfg;\n\t\t\n\t\tif ( cfg && cfg.on ) {\n\t\t\tthis.on(cfg.on);\n\t\t}\n\t\t\n\t\tthis.name = name;\n\t\t\n\t\tif ( scope.stores ) {\n\t\t\tthis.scopeObj = scope;\n\t\t\tthis.scope    = scope.stores;\n\t\t}\n\t\telse {\n\t\t\tthis.scopeObj = new Scope(scope);\n\t\t\tthis.scope    = scope.stores;\n\t\t}\n\t\t\n\t\t// standardized scope access\n\t\tthis.$scope    = this.scopeObj;\n\t\tthis.$stores   = this.scopeObj.stores;\n\t\tthis.$actions  = this.scopeObj.actions;\n\t\tthis.$dispatch = this.scopeObj.dispatch.bind(this.scopeObj);\n\t\t\n\t\tthis._rev     = this.constructor._rev || 0;\n\t\tthis._revs    = {};\n\t\tthis.stores   = {};\n\t\tthis._require = [];\n\t\tthis._sources = [name];\n\t\t\n\t\t// register source stores\n\t\tif ( is.array(_static.use) ) {\n\t\t\tthis._use = [...watchs, ...(_static.use || []).map(\n\t\t\t\tkey => {\n\t\t\t\t\tlet ref = key.match(/^(\\!?)([^\\:]*)(?:\\:(.*))?$/);\n\t\t\t\t\tif ( ref[1] ) {\n\t\t\t\t\t\tlet ref2 = ref[2].split('.');\n\t\t\t\t\t\tthis._require.push(ref[3] || ref2[ref2.length - 1]);// require check value of the aliased\n\t\t\t\t\t                                                        // imported value\n\t\t\t\t\t\treturn key.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t)];\n\t\t}\n\t\telse {\n\t\t\tthis._use = [...watchs, ...(\n\t\t\t\t_static.use ? Object.keys(_static.use)\n\t\t\t\t                    .map(\n\t\t\t\t\t                    key => {\n\t\t\t\t\t\t                    let ref = key.match(/^(\\!?)(.*)$/);\n\t\t\t\t\t\t                    ref[1] && this._require.push(_static.use[key]);\n\t\t\t\t\t\t                    return ref[2] + ((_static.use[key] === true)\n\t\t\t\t\t\t                                     ? ''\n\t\t\t\t\t\t                                     : ':' + _static.use[key]);\n\t\t\t\t\t                    }\n\t\t\t\t                    ) : []\n\t\t\t)];\n\t\t}\n\t\t\n\t\tif ( _static.require )\n\t\t\tthis._require.push(..._static.require);\n\t\tif ( cfg.require )\n\t\t\tthis._require.push(...cfg.require);\n\t\t\n\t\tthis._followers = [];\n\t\tthis._changesSW = initialState || {};\n\t\tthis.state      = initialState && {};\n\t\t\n\t\tif ( apply )\n\t\t\tthis.apply = apply;\n\t\t\n\t\t/**\n\t\t * Initial state isn't fully initialized ( childs constructors can set it )\n\t\t * Scope based instance have taskQueue to delay init synchronously, if not\n\t\t * present we use setTimeout\n\t\t */\n\t\tif ( taskQueue ) {\n\t\t\ttaskQueue.push(this._afterConstructor.bind(this))\n\t\t}\n\t\telse\n\t\t\tsetTimeout(this._afterConstructor.bind(this))\n\t}\n\t\n\t/**\n\t * Get the incoming state ( for immediate state relative actions )\n\t * @returns {{}|*}\n\t */\n\tget nextState() {\n\t\treturn this._nextState || this.state;\n\t}\n\t\n\t_afterConstructor() {\n\t\tlet cfg          = this._cfg,\n\t\t    _static      = this.constructor,\n\t\t    snapshot     = this.restore(undefined, true),\n\t\t    initialState = this.state,\n\t\t    initialData  = this.data,\n\t\t    applied;\n\t\t{\n\t\t\t\n\t\t\tif ( initialData )\n\t\t\t\tthis.data = initialData;\n\t\t\telse if ( _static.data !== undefined )\n\t\t\t\tthis.data = { ..._static.data };\n\t\t\telse if ( cfg.hasOwnProperty(\"data\") )\n\t\t\t\tthis.data = cfg.data;\n\t\t\t\n\t\t\tif ( cfg.hasOwnProperty(\"state\") && cfg.state !== undefined )\n\t\t\t\tinitialState = { ...initialState, ...cfg.state };\n\t\t\t\n\t\t\tif ( this.data === undefined ) {\n\t\t\t\tif ( initialState || this._use.length ) {// sync apply\n\t\t\t\t\tthis._nextState = this._changesSW = {\n\t\t\t\t\t\t...this._changesSW,\n\t\t\t\t\t\t...(initialState || {}),\n\t\t\t\t\t\t...this.$scope.map(this, this._use)\n\t\t\t\t\t};\n\t\t\t\t\tthis.state      = {};\n\t\t\t\t\tif ( this.shouldApply(this._nextState) && this.data === undefined ) {\n\t\t\t\t\t\tthis.data       = this.apply(this.data, this._nextState, this._changesSW);\n\t\t\t\t\t\tapplied         = true;\n\t\t\t\t\t\tthis.state      = this._changesSW;\n\t\t\t\t\t\tthis._nextState = this._changesSW = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tapplied         = true;\n\t\t\t\tthis.state      = {// assume this state is sync with initial data\n\t\t\t\t\t...this._changesSW,\n\t\t\t\t\t...(initialState || {}),\n\t\t\t\t\t...this.$scope.map(this, this._use)\n\t\t\t\t};\n\t\t\t\tthis._nextState = this._changesSW = null;\n\t\t\t}\n\t\t}\n\t\tif ( (this.data !== undefined || applied) && !this.__locks.all ) {\n\t\t\tthis._stable = true;\n\t\t\tthis._rev++;\n\t\t}\n\t\telse {\n\t\t\tthis._stable = false;\n\t\t\tif ( !_static.managed && !this.state && (!this._use || !this._use.length) ) {\n\t\t\t\tconsole.warn(\"ReScope store '\", this.name, \"' have no initial data, state or use. It can't stabilize...\");\n\t\t\t}\n\t\t}\n\t\t!this._stable && this.emit('unstable', this.state);\n\t\t\n\t}\n\t\n\t/**\n\t * Overridable method to know if a data change should be propag to the listening\n\t * stores & components\n\t */\n\tshouldPropag( nDatas ) {\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Overridable method to choose if this store should be serialized,\n\t * If not it will be applied normally when restoring\n\t * @returns {boolean}\n\t */\n\tshouldSerialize() {\n\t\treturn true;\n\t}\n\t\n\thasDataChange( nDatas ) {\n\t\tlet _static = this.constructor, r,\n\t\t    cDatas  = this.data;\n\t\tr           = !cDatas && nDatas || cDatas !== nDatas;\n\t\t!r && cDatas && Object.keys(cDatas).forEach(\n\t\t\t( key ) => {\n\t\t\t\tr = r || (nDatas\n\t\t\t\t          ? cDatas[key] !== nDatas[key]\n\t\t\t\t          : cDatas && cDatas[key])\n\t\t\t}\n\t\t);\n\t\t!r && nDatas && Object.keys(nDatas).forEach(\n\t\t\t( key ) => {\n\t\t\t\tr = r || (nDatas\n\t\t\t\t          ? cDatas[key] !== nDatas[key]\n\t\t\t\t          : cDatas && cDatas[key])\n\t\t\t}\n\t\t);\n\t\treturn r;\n\t}\n\t\n\t/**\n\t * Overridable method to know if a state change should be applied\n\t */\n\tshouldApply( state = this.state ) {\n\t\tlet _static = this.constructor;\n\t\t\n\t\treturn (\n\t\t\t!!this.isComplete(state)\n\t\t) && (is.array(_static.follow)\n\t\t      ? _static.follow\n\t\t               .reduce(( r, i ) => (r || state && state[i]), false)\n\t\t      : _static.follow\n\t\t        ? Object.keys(_static.follow)\n\t\t                .reduce(( r, i ) => (\n\t\t\t                r\n\t\t\t                || state && is.fn(_static.follow[i]) && _static.follow[i].call(this, state[i])\n\t\t\t                || _static.follow[i] && state[i] !== this.state[i]\n\t\t                ), false) : true\n\t\t);\n\t}\n\t\n\t/**\n\t * Overridable applier / remapper\n\t * If state or lastPublicState are simple hash maps apply will return {...data,\n\t * ...state} if not it will return the last private state\n\t * @param data\n\t * @param state\n\t * @returns {*}\n\t */\n\tapply( data, state, changes ) {\n\t\treturn state;\n\t}\n\t\n\t/**\n\t * Debounce this store propagation ( & reducing )\n\t * @param cb\n\t */\n\tstabilize( cb ) {\n\t\tcb && this.once('stable', cb);\n\t\t\n\t\tif ( this._stabilizer )\n\t\t\treturn;\n\t\tthis._stable && this.emit('unstable', this.state, this.data);\n\t\tthis._stable = false;\n\t\t\n\t\tthis._stabilizer = TaskSequencer.pushTask(this, 'pushState');\n\t}\n\t\n\t/**\n\t * Walk n get\n\t * @param path\n\t * @param i\n\t * @param obj\n\t * @returns {*|{}}\n\t */\n\tretrieve( path, i = 0, obj = this.data ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\treturn !obj || !path || !path.length\n\t\t       ? obj\n\t\t       : path.length == i + 1\n\t\t         ? obj[path[i]]\n\t\t         : this.retrieve(path, i + 1, obj[path[i]]);\n\t}\n\t\n\tdispatch( action, ...argz ) {\n\t\tthis.scopeObj.dispatch(action, ...argz);\n\t}\n\t\n\ttrigger( action, ...argz ) {\n\t\tlet { actions } = this.constructor;\n\t\tif ( actions && actions[action] ) {\n\t\t\tlet ns = actions[action].call(this, ...argz);\n\t\t\tif ( is.function(ns) )\n\t\t\t\tns = ns(this.nextState);\n\t\t\tns && this.setState(ns);\n\t\t}\n\t}\n\t\n\t/**\n\t * Set & Push the result data to followers if stable\n\t * @param cb\n\t */\n\tpush( data, force, cb ) {\n\t\tcb    = force === true ? cb : force;\n\t\tforce = force === true;\n\t\tif ( !force &&\n\t\t\t(\n\t\t\t\t!this.hasDataChange(data)\n\t\t\t)\n\t\t) {\n\t\t\tcb && cb();\n\t\t\tif ( !this.__locks.all ) {\n\t\t\t\tlet stable   = this._stable;\n\t\t\t\tthis._stable = true;\n\t\t\t\t!stable && this.emit('stable', this.state, this.data);\n\t\t\t\t//this._stabilizer = null;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.data = data;\n\t\tthis.wait();\n\t\tthis.release(cb);\n\t\t\n\t}\n\t\n\t/**\n\t * Call the apply fn using the current accumulated state update then, push the\n\t * resulting data if stable\n\t * @param forcedState\n\t */\n\tpushState( forcedState ) {\n\t\tthis._stabilizer = null;\n\t\tif ( !forcedState && !this._changesSW && this.data )\n\t\t\treturn;\n\t\t\n\t\tlet nextState = forcedState || this._nextState || this.state,\n\t\t    nextData;\n\t\tObject.keys(nextState).forEach(\n\t\t\tkey => (nextState[key] === undefined && (delete nextState[key]))\n\t\t);\n\t\tnextData = this.apply(this.data, nextState, this._changesSW);\n\t\t\n\t\tthis.state      = nextState;\n\t\tthis._nextState = null;\n\t\tthis._changesSW = null;\n\t\t\n\t\tif ( !forcedState &&\n\t\t\t(\n\t\t\t\t!this.hasDataChange(nextData)\n\t\t\t)\n\t\t) {\n\t\t\tif ( !this.__locks.all ) {\n\t\t\t\tlet stable   = this._stable;\n\t\t\t\tthis._stable = true;\n\t\t\t\t!stable && this.emit('stable', this.state, this.data);\n\t\t\t\tthis._stabilizer = null;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.data = nextData;\n\t\tthis.wait();\n\t\tthis.release();\n\t}\n\t\n\t/**\n\t * Add 'pState' to the current accumulated state updates\n\t * & wait source stores stabilization before pushing these state updates\n\t * @param pState\n\t * @param cb\n\t */\n\tsetState( pState, cb, sync ) {\n\t\tlet change,\n\t\t    changes   = this._changesSW = this._changesSW || {},\n\t\t    nextState = this._nextState = this._nextState || { ...this.state },\n\t\t    key;\n\t\tfor ( key in pState )\n\t\t\tif ( !this.state\n\t\t\t\t|| changes.hasOwnProperty(key)// todo\n\t\t\t\t&& (\n\t\t\t\t\tpState[key] !== changes[key]\n\t\t\t\t) || pState.hasOwnProperty(key)\n\t\t\t\t&& (\n\t\t\t\t\tpState[key] !== this.state[key]\n\t\t\t\t) ) {\n\t\t\t\tchange         = true;\n\t\t\t\tnextState[key] = changes[key] = pState[key];\n\t\t\t}\n\t\t\n\t\tif ( !this.shouldApply(nextState) ) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ( sync ) {\n\t\t\tthis.pushState();\n\t\t\tcb && cb();\n\t\t}\n\t\telse {\n\t\t\tif ( change ) {\n\t\t\t\tthis.stabilize(cb);\n\t\t\t}\n\t\t\telse cb && cb();\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Update the current state & push it\n\t * @param pState\n\t * @param cb\n\t */\n\tsetStateSync( pState ) {\n\t\tlet i       = 0, change,\n\t\t    changes = this._changesSW = this._changesSW || {};\n\t\tfor ( let k in pState )\n\t\t\tif ( !this.state || pState.hasOwnProperty(k)\n\t\t\t\t&& (\n\t\t\t\t\tpState[k] !== this.state[k]\n\t\t\t\t\t//||\n\t\t\t\t\t//(this.state[k] && pState[k] && (pState[k]._rev != this._revs[k]))// rev/hash update\n\t\t\t\t) ) {\n\t\t\t\tchange        = true;\n\t\t\t\tthis._revs[k] = pState[k] && pState[k]._rev || true;\n\t\t\t\tchanges[k]    = pState[k];\n\t\t\t}\n\t\tthis.shouldApply({ ...(this.state || {}), ...changes }) && this.pushState();\n\t\treturn this.data;\n\t}\n\t\n\t/**\n\t * get a store-key pair for Store::map\n\t * @param {string} name\n\t * @returns {{store: Store, name: *}}\n\t */\n\tas( name ) {\n\t\treturn { store: this, name };\n\t}\n\t\n\ton( lists ) {\n\t\tif ( !is.string(lists) && lists )\n\t\t\tObject.keys(lists).forEach(k => super.on(k, lists[k]));\n\t\telse super.on(...arguments);\n\t}\n\t\n\tremoveListener( lists ) {\n\t\tif ( !is.string(lists) && lists )\n\t\t\tObject.keys(lists).forEach(k => super.removeListener(k, lists[k]));\n\t\telse super.removeListener(...arguments);\n\t}\n\t\n\t/**\n\t * is complete (all requiered keys are here)\n\t * @returns bool\n\t */\n\tisComplete( state = this.state ) {\n\t\treturn (\n\t\t\t!this._require\n\t\t\t|| !this._require.length\n\t\t\t|| state && this._require.reduce(\n\t\t\t\t( r, key ) => (r && state[key]),\n\t\t\t\ttrue\n\t\t\t)\n\t\t);\n\t}\n\t\n\t/**\n\t * is stable\n\t * @returns bool\n\t */\n\tisStable() {\n\t\treturn this._stable;\n\t}\n\t\n\t/**\n\t * Serialize state & data with sources refs\n\t * @returns bool\n\t */\n\tserialize( cfg = {}, output = {} ) {\n\t\t\n\t\tlet sId        = cfg.parentAlias || this.scopeObj._id,\n\t\t    refsCount  = 0,\n\t\t    refs       =\n\t\t\t    !cfg.norefs && is.array(this._use) && this._use.reduce(\n\t\t\t    ( map, key ) => {\n\t\t\t\t    let ref   = this.$scope.parseRef(key),\n\t\t\t\t        store = this.$stores[ref.storeId];\n\t\t\t\t    if ( store && Store.isStore(store) && !store.scopeObj._.isLocalId )\n\t\t\t\t\t    refsCount++, map[ref.alias] = ref.path;\n\t\t\t\t\n\t\t\t\t    return map;\n\t\t\t    }, {}\n\t\t\t    ),\n\t\t    state      = this.state || {},\n\t\t    persistent = this.shouldSerialize();\n\t\t\n\t\tif ( !persistent ) {\n\t\t\tkeyWalknSet(\n\t\t\t\toutput,\n\t\t\t\t(sId + '/' + this.name),\n\t\t\t\t{\n\t\t\t\t\tdataRefs: cfg.dataRefs,\n\t\t\t\t\trefs\n\t\t\t\t}\n\t\t\t);\n\t\t\treturn output;\n\t\t}\n\t\t\n\t\tlet\n\t\t\tstateKeys   = Object.keys(state) || [],\n\t\t\tstateRefs   = stateKeys.map(k => state[k]),\n\t\t\tinRefsCount = 0,\n\t\t\tdataRefs    = cfg.dataRefs || {},\n\t\t\tinRefs      =\n\t\t\t\t!cfg.norefs && this.data && (Object.keys(this.data).reduce(\n\t\t\t\t( map, key ) => {\n\t\t\t\t\tlet ref = stateRefs.indexOf(this.data[key])\n\t\t\t\t\tif ( ref != -1 )\n\t\t\t\t\t\tinRefsCount++, map[key] = stateKeys[ref];\n\t\t\t\t\treturn map;\n\t\t\t\t}, {}\n\t\t\t\t)),\n\t\t\tsnap        = {\n\t\t\t\tdataRefs: cfg.dataRefs,\n\t\t\t\tstate   : state &&\n\t\t\t\t\t(\n\t\t\t\t\t\tcfg.norefs\n\t\t\t\t\t\t? { ...state }\n\t\t\t\t\t\t: Object.keys(state).reduce(( h, k ) => (!refs[k] && (h[k] = state[k]), h), {})\n\t\t\t\t\t),\n\t\t\t\tdata    : (\n\t\t\t\t\t\tthis.data &&\n\t\t\t\t\t\tthis.data.__proto__ === objProto ?\n\t\t\t\t\t\tObject\n\t\t\t\t\t\t\t.keys(this.data)\n\t\t\t\t\t\t\t.reduce(\n\t\t\t\t\t\t\t\t( h, k ) => {\n\t\t\t\t\t\t\t\t\tif ( !inRefs[k] && !dataRefs[k] ) {\n\t\t\t\t\t\t\t\t\t\th[k] = this.data[k];\n\t\t\t\t\t\t\t\t\t\tinRefsCount++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn h\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t                                 :\n\t\t\t\t\t\t(is.bool(this.data)\n\t\t\t\t\t\t\t|| is.number(this.data)\n\t\t\t\t\t\t\t|| is.string(this.data)) && this.data\n\t\t\t\t\t)\n\t\t\t\t\t|| undefined\n\t\t\t\t\n\t\t\t};\n\t\t\n\t\trefs && refsCount && (snap.refs = refs);\n\t\tinRefs && inRefsCount && (\n\t\t\tsnap.inRefs = inRefs);\n\t\t\n\t\t\n\t\tkeyWalknSet(\n\t\t\toutput,\n\t\t\t(sId + '/' + this.name),\n\t\t\tsnap\n\t\t);\n\t\treturn output;\n\t}\n\t\n\t/**\n\t * restore state & data\n\t * @returns bool\n\t */\n\trestore( snapshot, immediate ) {\n\t\tsnapshot = snapshot\n\t\t\t&& keyWalknGet(snapshot, this.scopeObj._id + '/' + this.name)\n\t\t\t|| this.$scope.takeSnapshotByKey(this.scopeObj._id + '/' + this.name);\n\t\t\n\t\tif ( !snapshot )\n\t\t\treturn;\n\t\t\n\t\tif ( snapshot ) {\n\t\t\t\n\t\t\tif ( !this.isStable() && !immediate )\n\t\t\t\tthis.then(() => this.restore(snapshot));\n\t\t\t\n\t\t\tthis.state = { ...snapshot.state };\n\t\t\tsnapshot.refs && Object.keys(snapshot.refs).forEach(\n\t\t\t\t( key ) => {//todo\n\t\t\t\t\tthis.state[key] = this.$scope.retrieve(snapshot.refs[key]);\n\t\t\t\t}\n\t\t\t)\n\t\t\t\n\t\t\t\n\t\t\tif ( snapshot.inRefs === true ) {\n\t\t\t\tthis.data = { ...this.state };\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.data = snapshot.data;\n\t\t\t\tsnapshot.inRefs && Object.keys(snapshot.inRefs).forEach(\n\t\t\t\t\t( key ) => {//todo\n\t\t\t\t\t\tthis.data[key] = this.state[snapshot.inRefs[key]];\n\t\t\t\t\t\t//else\n\t\t\t\t\t\t//    console.warn('not found : ', key, snap && snap.refs[ key ])\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tif ( snapshot.dataRefs ) {\n\t\t\t\tthis.data = this.data || {};\n\t\t\t\tObject.keys(snapshot.dataRefs).forEach(\n\t\t\t\t\t( key ) => {//todo\n\t\t\t\t\t\tthis.$scope.restoreRefPath(snapshot.dataRefs[key]);\n\t\t\t\t\t\tthis.data[key] = this.$scope.retrieve(snapshot.dataRefs[key]);\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\t/**\n\t * Bind this store changes to the given component-key\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tbind( obj, key, setInitial = true, path ) {\n\t\tthis._followers.push([obj, key, path]);\n\t\tif ( setInitial && this.data && this._stable ) {\n\t\t\tlet data = path ? this.retrieve(path) : this.data;\n\t\t\tif ( typeof obj != \"function\" ) {\n\t\t\t\tif ( key ) obj.setState({ [key]: data });\n\t\t\t\telse obj.setState(data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj(data);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Un bind this store off the given component-key\n\t * @param obj\n\t * @param key\n\t * @returns {Array.<*>}\n\t */\n\tunBind( obj, key, path ) {\n\t\tlet followers = this._followers,\n\t\t    i         = followers && followers.length;\n\t\twhile ( followers && i-- )\n\t\t\tif ( followers[i][0] === obj && followers[i][1] === key && followers[i][2] === path )\n\t\t\t\treturn followers.splice(i, 1);\n\t}\n\t\n\t/**\n\t * once('stable', cb)\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tthen( cb ) {\n\t\tif ( this._stable )\n\t\t\treturn cb(this.data);\n\t\tthis.once('stable', e => cb(this.data));\n\t}\n\t\n\t/**\n\t * Add a lock so the store will not propag it data untill release() is call\n\t * @param previous {Store|number|Array} @optional wf to wait, releases to wait or\n\t *     array of stuff to wait\n\t * @returns {this}\n\t */\n\twait( previous ) {\n\t\tif ( typeof previous == \"number\" )\n\t\t\treturn this.__locks.all += previous;\n\t\tif ( is.array(previous) )\n\t\t\treturn previous.map(this.wait.bind(this));\n\t\t\n\t\tthis._stable && this.emit('unstable', this.state, this.data);\n\t\tthis._stable = false;\n\t\tthis.__locks.all++;\n\t\t\n\t\tlet reason = is.string(previous) ? previous : null;\n\t\tif ( reason ) {\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]++;\n\t\t}\n\t\tif ( previous && is.fn(previous.then) ) {\n\t\t\tprevious.then(this.release.bind(this, null));\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Decrease locks for this store, if it reach 0 ,\n\t * it will be propagated to the followers,\n\t * then, all stuff passed to \"then\" call back will be exec / released\n\t * @param desync\n\t * @returns {*}\n\t */\n\trelease( reason, cb ) {\n\t\tlet _static = this.constructor, me = this;\n\t\tlet i       = 0, wasStable = this._stable;\n\t\t\n\t\tif ( is.fn(reason) ) {\n\t\t\tcb     = reason;\n\t\t\treason = null;\n\t\t}\n\t\t\n\t\tif ( reason ) {\n\t\t\tif ( this.__locks[reason] == 0 )\n\t\t\t\tconsole.error(\"Release more than locking !\", reason);\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]--;\n\t\t}\n\t\t\n\t\tif ( !reason && this.__locks.all == 0 )\n\t\t\tconsole.error(\"Release more than locking !\");\n\t\t\n\t\tif ( !--this.__locks.all && this.isComplete() ) {\n\t\t\tlet propag   = this.shouldPropag(this.data);\n\t\t\tthis._stable = true;\n\t\t\tpropag && this._rev++;//\n\t\t\tif ( propag && this._followers.length )\n\t\t\t\tthis._followers.forEach(function propag( follower ) {\n\t\t\t\t\tlet data = follower[2] ? me.retrieve(follower[2]) : me.data;\n\t\t\t\t\t//if ( !data ) return;\n\t\t\t\t\t\n\t\t\t\t\tif ( typeof follower[0] == \"function\" ) {\n\t\t\t\t\t\tfollower[0](data);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//cb && i++;\n\t\t\t\t\t\tfollower[0].setState(\n\t\t\t\t\t\t\t(follower[1]) ? { [follower[1]]: data }\n\t\t\t\t\t\t\t              : data\n\t\t\t\t\t\t\t//,\n\t\t\t\t\t\t\t//cb && (\n\t\t\t\t\t\t\t//    () => (!(--i) && cb())\n\t\t\t\t\t\t\t//)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t//else\n\t\t\t!wasStable && this.emit('stable', this.data);\n\t\t\tpropag && this.emit('update', this.data);\n\t\t\tcb && cb()\n\t\t}\n\t\telse cb && this.then(cb);\n\t\treturn this;\n\t}\n\t\n\tpropag( data ) {\n\t\tthis.emit('update', data);\n\t}\n\t\n\tretain( reason ) {\n\t\tthis.__retains.all++;\n\t\tif ( reason ) {\n\t\t\tthis.__retains[reason] = this.__retains[reason] || 0;\n\t\t\tthis.__retains[reason]++;\n\t\t}\n\t}\n\t\n\tdispose( reason ) {\n\t\t//console.warn(\"dispose\", reason, this.__retains);\n\t\tif ( reason ) {\n\t\t\tif ( !this.__retains[reason] ) {\n\t\t\t\tthrow new Error(\"RS : Dispose more than retaining on store '\" + this.name + \"' : \" + reason);\n\t\t\t}\n\t\t\t\n\t\t\tthis.__retains[reason]--;\n\t\t}\n\t\tif ( this.__retains.all == 0 ) {\n\t\t\tthrow new Error(\"RS : Dispose more than retaining on store \" + this.name);\n\t\t}\n\t\t\n\t\tthis.__retains.all--;\n\t\t\n\t\tif ( !this.__retains.all ) {\n\t\t\tif ( this._persistenceTm ) {\n\t\t\t\tthis._destroyTM && clearTimeout(this._destroyTM);\n\t\t\t\tthis._destroyTM = setTimeout(\n\t\t\t\t\te => {\n\t\t\t\t\t\tthis._destroyTM = null;\n\t\t\t\t\t\t//this.then(s => {\n\t\t\t\t\t\t!this.__retains.all && !this.dead && this.destroy()\n\t\t\t\t\t\t//});\n\t\t\t\t\t},\n\t\t\t\t\tthis._persistenceTm\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//this.then(s =>\n\t\t\t\t(!this.__retains.all && !this.dead && this.destroy())\n\t\t\t\t//);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdestroy() {\n\t\t//  console.log(\"destroy\", this._uid);\n\t\t\n\t\tif ( this._stabilizer ) {\n\t\t\tthis._stabilizer = null;\n\t\t\tclearTimeout(this._stabilizer);\n\t\t}\n\t\tthis.emit('destroy', this);\n\t\t\n\t\tif ( this._followers.length )\n\t\t\tthis._followers.forEach(\n\t\t\t\t( follower ) => {\n\t\t\t\t\tif ( typeof follower[0] !== \"function\" ) {\n\t\t\t\t\t\tif ( follower[0].stores )\n\t\t\t\t\t\t\tdelete follower[0].stores[follower[1]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\tthis._followers.length = 0;\n\t\tthis.constructor._rev  = this.rev;\n\t\tthis.dead              = true;\n\t\tthis._revs             = this.data = this.state = this.scope = null;\n\t\tthis.removeAllListeners();\n\t}\n}\n\n/**\n * get a static aliased reference of a store\n * @param {string} name\n * @returns {{store: Store, name: *}}\n */\nStore.as = function ( name ) {\n\treturn { store: this, name };\n}\n\n/**\n * @todo\n * Map all named stores in {keys} to the {object}'s state\n * Hook componentWillUnmount (for react comp) or destroy to unBind them automatically\n * @static\n * @param object {Object} target state aware object (React.Component|Store|...)\n * @param keys {Array} Ex : [\"session\", \"otherStaticNamedStore:key\",\n *     store.as('anotherKey')]\n */\nStore.map = function ( cStore, keys, scope, origin, setInitial = false ) {\n\tlet targetRevs     = cStore._revs || {};\n\tlet targetScope    = cStore.stores || (cStore.stores = {});\n\tlet initialOutputs = {};\n\tkeys               = is.array(keys) ? [...keys] : [keys];\n\t\n\t\n\tscope = scope || Store.staticScope;\n\t\n\tkeys = keys.filter(\n\t\t// @todo : use query refs\n\t\t// (store)(\\.store)*(\\[(\\*|(props)\\w+)+)\\])?(\\:alias)\n\t\t( key ) => {\n\t\t\tif ( !key ) {\n\t\t\t\tconsole.error(\"Not a mappable store item '\" + key + \"' in \" + origin + ' !!');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet name,\n\t\t\t    alias,\n\t\t\t    path,\n\t\t\t    store, _key;\n\t\t\tif ( key.store && key.name ) {\n\t\t\t\talias = name = key.name;\n\t\t\t\tstore = key.store;\n\t\t\t}\n\t\t\telse if ( is.fn(key) ) {\n\t\t\t\tname  = alias = key.name || key.defaultName;\n\t\t\t\tstore = key;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_key  = key.match(/([^\\.\\:]+)((?:\\.[^\\.\\:]+)*)(?:\\:([^\\.\\:]+))?/);\n\t\t\t\tname  = _key[1];\n\t\t\t\tpath  = _key[2] && _key[2].substr(1);\n\t\t\t\tstore = scope.stores[_key[1]];\n\t\t\t\talias = _key[3] || path && path.match(/([^\\.]*)$/)[0] || _key[1];\n\t\t\t}\n\t\t\tif ( !store ) {\n\t\t\t\tlet i = [];\n\t\t\t\tfor ( let o in scope.stores )\n\t\t\t\t\ti.push(o)\n\t\t\t\tconsole.error(\"Not a mappable store item '\" + name + \"/\" + alias + \"' in \" + (cStore.name || cStore) + ' !!', store, _key, scope.stores, i);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( Scope.isScopeClass(store) ) scope._mount(name);\n\t\t\tif ( Scope.isScope(store) ) {\n\t\t\t\tstore = scope._mount(key);\n\t\t\t}\n\t\t\telse if ( targetRevs[name] ) return false;// ignore dbl uses for now\n\t\t\t\n\t\t\t\n\t\t\tif ( is.fn(store) ) {\n\t\t\t\tscope._mount(name)\n\t\t\t\tscope.stores[name].bind(cStore, alias, setInitial, path);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstore.bind(cStore, alias, setInitial, path);\n\t\t\t}\n\t\t\t\n\t\t\t// give initial store weight basing sources\n\t\t\tscope.stores[name]._sources && cStore._sources.push(...scope.stores[name]._sources);\n\t\t\t\n\t\t\ttargetRevs[alias] = targetRevs[alias] || true;\n\t\t\t!targetScope[name] && (targetScope[name] = scope.stores[name]);\n\t\t\tif ( scope.stores[name].hasOwnProperty('data') )\n\t\t\t\tinitialOutputs[name] = scope.data[name];\n\t\t\treturn true;\n\t\t}\n\t);\n\t\n\t// ... @todo\n\tcStore.once('destroy', ( ...argz ) => {\n\t\tkeys.map(\n\t\t\t( key ) => {\n\t\t\t\tlet name,\n\t\t\t\t    alias, path,\n\t\t\t\t    store;\n\t\t\t\tif ( key.store && key.name ) {\n\t\t\t\t\talias = name = key.name;\n\t\t\t\t\tstore = key.store;\n\t\t\t\t}\n\t\t\t\telse if ( is.fn(key) ) {\n\t\t\t\t\tname  = alias = key.name || key.defaultName;\n\t\t\t\t\tstore = scope.stores[name];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey   = key.match(/([^\\.\\:]+)((?:\\.[^\\.\\:]+)*)(?:\\:([^\\.\\:]+))?/);\n\t\t\t\t\tname  = key[1];\n\t\t\t\t\tpath  = key[2] && key[2].substr(1);\n\t\t\t\t\tstore = scope.stores[key[1]];\n\t\t\t\t\talias = key[3] || path && path.match(/([^\\.]*)$/)[0] || key[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstore && !is.fn(store) && store.unBind(cStore, alias, path)\n\t\t\t}\n\t\t);\n\t})\n\t\n\treturn initialOutputs;\n};\n\n\nStore.isStore      = Scope.isStore = function ( obj ) {\n\treturn obj instanceof Store\n}\nStore.isStoreClass = Scope.isStoreClass = function ( obj ) {\n\treturn Store.isPrototypeOf(obj) || obj === Store\n}\n\nexport default Store;","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\n/**\n * Minimal push sequencer, apply stores specific task in the right order\n */\nlet taskQueue      = [],\n    curWeight      = 0,\n    maxWeight      = 0,\n    minWeight      = 0,\n    taskCount      = 0,\n    deSync         = false,\n    deSyncMaxTasks = 10,\n    task,\n    isRunning,\n    errorCatcher   = {\n\t    lastError: null,\n\t    dispatch : function ( error ) {\n\t\t    errorCatcher.disable();\n\t\t\n\t\t    if ( task && task[0].handleError ) {\n\t\t\t    task[0].handleError(error, task);\n\t\t    }\n\t\t    else if ( task )\n\t\t\t    console.error(\"ReScope : An apply task has failed !!\", task[1], \" on \", task[0].name || task[0].constructor.name)\n\t\t\n\t\t    isRunning = false;\n\t\t    task      = null;\n\t\t    runNow();\n\t    },\n\t    enable   : (typeof window !== 'undefined')\n\t               ? () => {\n\t\t\t    window.addEventListener('error', errorCatcher.dispatch)\n\t\t    } : () => {\n\t\t\t    process.on('uncaughtException', errorCatcher.dispatch);\n\t\t    },\n\t    disable  : (typeof window !== 'undefined')\n\t               ? () => {\n\t\t\t    window.removeEventListener('error', errorCatcher.dispatch)\n\t\t    } : () => {\n\t\t\t    process.removeListener('uncaughtException', errorCatcher.dispatch);\n\t\t    }\n    }\n;\n\nfunction runNow() {\n\tif ( !isRunning ) {\n\t\trun();\n\t}\n}\n\nfunction run() {\n\tlet from  = Date.now();\n\tisRunning = true;\n\terrorCatcher.enable();\n\twhile ( taskCount ) {\n\t\t\n\t\t// try for the current weight\n\t\twhile ( !(taskQueue[curWeight] && taskQueue[curWeight].length) )\n\t\t\tcurWeight++;\n\t\t\n\t\ttaskCount--;\n\t\ttask = taskQueue[curWeight].shift();\n\t\t//console.log(\"Task : \", task[1], \" on \", task[0].name);\n\t\ttry {\n\t\t\t!task[0].dead && task[0][task[1]](task[2]);\n\t\t} catch ( e ) {\n\t\t\treturn errorCatcher.dispatch(e);\n\t\t}\n\t}\n\ttask = undefined;\n\terrorCatcher.disable();\n\t\n\tisRunning = false;\n\tif ( taskCount ) {\n\t\tsetTimeout(runNow);\n\t}\n}\n\n//\n//index.setTaskDeSync = ( nb ) => {\n//    if ( nb === false )\n//        return deSync = false;\n//    else if ( nb === true ) {\n//        deSync         = true;\n//        deSyncMaxTasks = 10;\n//    }\n//    else (is.int(nb))\n//    {\n//        deSync         = true;\n//        deSyncMaxTasks = nb;\n//    }\n//};\n\nexport default {\n\tpushTask( obj, fn, argz ) {\n\t\t/**\n\t\t * The more a store have sources, the more it should be processed first\n\t\t * So leafs stores stay sync, and root stores receive merged state updates;\n\t\t * global state stay coherent\n\t\t *\n\t\t * This mean whatever the number of stores & the complexity of the deps,\n\t\t * updating a store state will update its synchrone child stores immediately\n\t\t *\n\t\t *\n\t\t * @type {*|number}\n\t\t */\n\t\tlet weight = obj._sources && obj._sources.length || 1,\n\t\t    stack  = taskQueue[weight] =\n\t\t\t    taskQueue[weight] || [];\n\t\t\n\t\tmaxWeight = Math.max(maxWeight, weight);\n\t\tcurWeight = Math.min(curWeight, weight);\n\t\ttaskCount++;\n\t\t\n\t\t//console.log(\"Push Task : \", fn, \" on \", obj.name, weight);\n\t\tstack.push([obj, fn, argz]);\n\t\tsetTimeout(runNow, 0);\n\t\treturn stack.length;\n\t}\n};","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"sourceRoot":""}